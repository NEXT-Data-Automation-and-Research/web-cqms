<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Audit Details | CQMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="intercom-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="dark-mode.js"></script>
    <script src="search.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f9fafb;
        }
        
        .full-width-container {
            width: 100%;
            padding: 0;
            margin: 0;
        }
        
        /* Override main-content padding and width for full-width form */
        .main-content {
            padding: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }

        /* Dark Mode Styles */
        [data-theme="dark"] body {
            background-color: var(--background-color) !important;
        }

        [data-theme="dark"] .full-width-container {
            background-color: var(--background-color) !important;
        }

        [data-theme="dark"] [style*="background: #f9fafb"],
        [data-theme="dark"] [style*="background:#f9fafb"],
        [data-theme="dark"] [style*="background-color: #f9fafb"],
        [data-theme="dark"] [style*="background-color:#f9fafb"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        [data-theme="dark"] [style*="background: white"],
        [data-theme="dark"] [style*="background:white"],
        [data-theme="dark"] [style*="background-color: white"],
        [data-theme="dark"] [style*="background-color:white"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        [data-theme="dark"] [style*="color: #374151"],
        [data-theme="dark"] [style*="color:#374151"],
        [data-theme="dark"] [style*="color: #1f2937"],
        [data-theme="dark"] [style*="color:#1f2937"] {
            color: var(--text-color) !important;
        }

        /* Text colors - ensure maximum contrast */
        [data-theme="dark"] [style*="color: #000000"],
        [data-theme="dark"] [style*="color:#000000"] {
            color: #ffffff !important; /* Pure white for maximum contrast in dark mode */
        }

        [data-theme="dark"] [style*="color: #1f2937"],
        [data-theme="dark"] [style*="color:#1f2937"],
        [data-theme="dark"] [style*="color: #374151"],
        [data-theme="dark"] [style*="color:#374151"] {
            color: #ffffff !important; /* Pure white for maximum contrast in dark mode */
        }

        [data-theme="dark"] [style*="border:"] [style*="#e5e7eb"],
        [data-theme="dark"] [style*="border-color: #e5e7eb"],
        [data-theme="dark"] [style*="border-color:#e5e7eb"],
        [data-theme="dark"] [style*="border:"] [style*="#d1d5db"],
        [data-theme="dark"] [style*="border-color: #d1d5db"],
        [data-theme="dark"] [style*="border-color:#d1d5db"] {
            border-color: var(--border-light) !important;
        }

        [data-theme="dark"] select,
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] input[type="date"],
        [data-theme="dark"] textarea {
            background-color: var(--background-white) !important;
            color: #ffffff !important; /* Pure white text for maximum contrast */
            border-color: var(--border-light) !important;
        }

        /* Error Details Header and containers - Make dark */
        [data-theme="dark"] [style*="background-color: #f8f9fa"],
        [data-theme="dark"] [style*="background-color:#f8f9fa"] {
            background-color: var(--background-white) !important;
        }

        /* Error Details table container - ensure dark background */
        [data-theme="dark"] [style*="background: #f9fafb"][style*="Error Details"],
        [data-theme="dark"] div[style*="background: #f9fafb"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        /* Transcript Chat View Background - Make dark */
        [data-theme="dark"] #transcriptChatView {
            background: var(--background-white) !important;
        }

        [data-theme="dark"] #transcriptChatView::-webkit-scrollbar-track {
            background: var(--gray-100) !important;
        }

        [data-theme="dark"] #transcriptChatView::-webkit-scrollbar-thumb {
            background: var(--gray-400) !important;
        }

        [data-theme="dark"] #transcriptChatView::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500) !important;
        }

        /* Transcript Text View Background - Make dark */
        [data-theme="dark"] #transcriptTextView {
            background: var(--background-white) !important;
        }

        /* Chat Message Bubbles - Adjust for dark mode */
        [data-theme="dark"] [style*="background: white"][style*="color: #374151"] {
            background: var(--gray-100) !important;
            color: #ffffff !important; /* Pure white for maximum contrast */
            border-color: var(--border-light) !important;
        }

        /* User message bubbles in dark mode */
        [data-theme="dark"] .message-bubble-user {
            background: var(--gray-100) !important;
            color: #ffffff !important; /* Pure white for maximum contrast */
            border-color: var(--border-light) !important;
        }

        /* AI message bubbles - use purplish color in dark mode for better visibility */
        [data-theme="dark"] [style*="background: #1d1d1d"],
        [data-theme="dark"] [style*="background: #2d2d2d"],
        [data-theme="dark"] [style*="background:#1d1d1d"],
        [data-theme="dark"] [style*="background:#2d2d2d"] {
            background: #6b46c1 !important; /* Purple-600 for better visibility in dark mode */
        }

        /* Dividers - Reduce contrast */
        [data-theme="dark"] [style*="border-bottom"][style*="#f3f4f6"],
        [data-theme="dark"] [style*="border-bottom"][style*="#e5e7eb"] {
            border-bottom-color: var(--border-light) !important;
            opacity: 0.5;
        }

        
    </style>
    <script>
    // Update inline styles on theme change - single unified handler
    document.addEventListener('themeChange', function(e) {
        const isDark = e.detail.theme === 'dark';
        const root = document.documentElement;
        const bgWhite = getComputedStyle(root).getPropertyValue('--background-white').trim();
        const gray100 = getComputedStyle(root).getPropertyValue('--gray-100').trim();
        const borderLight = getComputedStyle(root).getPropertyValue('--border-light').trim();
        
        // Text colors - use pure white in dark mode, pure black in light mode for maximum contrast
        const textColorDark = '#ffffff'; // Pure white for maximum contrast
        const textColorLight = '#000000'; // Pure black for maximum contrast
        
        // Update background colors
        document.querySelectorAll('[style*="background: #f9fafb"], [style*="background:#f9fafb"], [style*="background-color: #f9fafb"], [style*="background-color:#f9fafb"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background', bgWhite, 'important');
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background', '#f9fafb', 'important');
                el.style.setProperty('background-color', '#f9fafb', 'important');
            }
        });
        
        document.querySelectorAll('[style*="background: white"], [style*="background:white"], [style*="background-color: white"], [style*="background-color:white"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background', bgWhite, 'important');
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background', 'white', 'important');
                el.style.setProperty('background-color', 'white', 'important');
            }
        });
        
        // Error details header and containers
        document.querySelectorAll('[style*="background-color: #f8f9fa"], [style*="background-color:#f8f9fa"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background-color', '#f8f9fa', 'important');
            }
        });
        
        // Transcript chat view background
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.style.setProperty('background', isDark ? bgWhite : '#f0f2f5', 'important');
        }
        
        // Transcript text view background
        const transcriptTextView = document.getElementById('transcriptTextView');
        if (transcriptTextView) {
            transcriptTextView.style.setProperty('background', isDark ? bgWhite : '#ffffff', 'important');
        }
        
        // Chat message bubbles - user messages
        document.querySelectorAll('[style*="background: white"][style*="color: #374151"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background', gray100, 'important');
                el.style.setProperty('color', textColorDark, 'important');
                el.style.setProperty('border-color', borderLight, 'important');
            } else {
                el.style.setProperty('background', 'white', 'important');
                el.style.setProperty('color', textColorLight, 'important');
            }
        });
        
        // Dividers - reduce contrast in dark mode
        document.querySelectorAll('[style*="border-bottom"][style*="#f3f4f6"], [style*="border-bottom"][style*="#e5e7eb"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('border-bottom-color', borderLight, 'important');
                el.style.setProperty('opacity', '0.5', 'important');
            } else {
                el.style.setProperty('border-bottom-color', '#e5e7eb', 'important');
                el.style.setProperty('opacity', '1', 'important');
            }
        });
        
        // Update all text colors - single unified handler
        const textColorSelectors = [
            '[style*="color: #000000"]',
            '[style*="color:#000000"]',
            '[style*="color: #374151"]',
            '[style*="color:#374151"]',
            '[style*="color: #1f2937"]',
            '[style*="color:#1f2937"]'
        ];
        
        textColorSelectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(el => {
                if (isDark) {
                    el.style.setProperty('color', textColorDark, 'important');
                } else {
                    // Reset to appropriate light mode color based on original
                    const style = el.getAttribute('style') || '';
                    if (style.includes('#000000')) {
                        el.style.setProperty('color', textColorLight, 'important');
                    } else if (style.includes('#374151') || style.includes('#1f2937')) {
                        el.style.setProperty('color', textColorLight, 'important');
                    }
                }
            });
        });
    });
    </script>
</head>

<body style="margin: 0; padding: 0;">
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
<main class="main-content" role="main">
<div class="full-width-container">

    <!-- Reversal Request Form (hidden by default) -->
    <div id="reversalFormContainer" class="no-print" style="display: none; background: #fff3cd; border: 0.0703rem solid #ffc107; border-radius: 0.375rem; padding: 0.75rem; margin: 1.125rem; box-shadow: 0 0.0703rem 0.2812rem rgba(0,0,0,0.1);">
        <div style="display: flex; align-items: center; gap: 0.375rem; margin-bottom: 0.5625rem;">
            <svg style="width: 0.9375rem; height: 0.9375rem; color: #f59e0b;" viewBox="0 0 24 24" fill="currentColor">
                <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
            </svg>
            <h3 style="margin: 0; font-size: 0.75rem; font-weight: 700; color: #b45309; font-family: 'Poppins', sans-serif;">Submit Reversal Request</h3>
        </div>
        
        <p style="font-size: 0.6094rem; color: #92400e; margin-bottom: 0.75rem; line-height: 1.5; font-family: 'Poppins', sans-serif;">
            If you believe this audit contains errors or inaccuracies, please add comments to the parameters using the comment icon next to each parameter's feedback, then select the affected parameters below.
        </p>
        
        <form id="reversalForm" style="display: grid; gap: 0.5625rem;">
            <!-- Two-column grid for compact layout -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5625rem;">
                <!-- Reversal Type -->
                <div>
                    <label for="reversalType" style="display: block; font-size: 0.5625rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                        Reversal Type <span style="color: #ef4444;">*</span>
                    </label>
                    <select id="reversalType" required style="width: 100%; padding: 0.375rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: white;">
                        <option value="Revision Requested" selected>Revision Requested</option>
                    </select>
                </div>
                
                <!-- Reversal Reason Dropdown -->
                <div>
                    <label for="reversalReasonDropdown" style="display: block; font-size: 0.5625rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                        Reversal Reason <span style="color: #ef4444;">*</span>
                    </label>
                    <select id="reversalReasonDropdown" required style="width: 100%; padding: 0.375rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: white;">
                        <option value="">Select reason...</option>
                        <option value="Error in Scoring">Error in Scoring</option>
                        <option value="Incorrect Parameter Applied">Incorrect Parameter Applied</option>
                        <option value="Misinterpretation">Misinterpretation of Interaction</option>
                        <option value="Technical Issue">Technical Issue</option>
                        <option value="Policy Clarification">Policy Clarification Needed</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; padding-top: 0.375rem;">
                <button type="button" onclick="toggleReversalForm()" style="padding: 0.4688rem 0.9375rem; background-color: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                    Cancel
                </button>
                <button type="submit" style="padding: 0.4688rem 0.9375rem; background-color: #ef4444; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13"/>
                        <path d="M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                    Submit Reversal Request
                </button>
            </div>
        </form>
    </div>

    <!-- Audit Content Container -->
    <div id="auditContainer" style="width: 100%; box-sizing: border-box;">
        <!-- Loading indicator -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; padding: 3rem; width: 100%;">
            <div style="text-align: center;">
                <div style="border: 0.1406rem solid #f3f4f6; border-top: 0.1406rem solid #1A733E; border-radius: 50%; width: 2.25rem; height: 2.25rem; animation: spin 1s linear infinite; margin: 0 auto 0.75rem;"></div>
                <p style="color: #000000; font-family: 'Poppins', sans-serif;">Loading audit details...</p>
            </div>
        </div>

        <!-- Error message -->
        <div id="errorMessage" style="display: none; text-align: center; padding: 1.5rem; color: #ef4444; font-family: 'Poppins', sans-serif; width: 100%;">
            <p style="font-size: 0.8438rem; font-weight: 600; margin-bottom: 0.375rem;">Error Loading Audit</p>
            <p id="errorText" style="font-size: 0.6562rem;"></p>
            <button onclick="window.history.back()" style="margin-top: 0.75rem; padding: 0.375rem 1.125rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer;">Go Back</button>
        </div>

        <!-- Audit content will be dynamically loaded here -->
        <div id="auditContent"></div>
    </div>

</div>
<!-- End full-width-container -->
</main>

<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes pulse-attention {
        0%, 100% { 
            opacity: 1;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.02);
        }
    }

    @keyframes spin-slow {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes flash-text {
        0%, 100% { 
            opacity: 1;
        }
        50% { 
            opacity: 0.6;
        }
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
        20%, 40%, 60%, 80% { transform: translateX(2px); }
    }


/* Chat view scrollbar styling */
#transcriptChatView::-webkit-scrollbar {
    width: 0.3234rem;
}

#transcriptChatView::-webkit-scrollbar-track {
    background: #f0f2f5;
}

#transcriptChatView::-webkit-scrollbar-thumb {
    background: #9ca3af;
    border-radius: 0.1617rem;
}

#transcriptChatView::-webkit-scrollbar-thumb:hover {
    background: #6b7280;
    }

/* Rating Modal Styles */
@keyframes slideUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.rating-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
}

.rating-modal {
    background: white;
    border-radius: 1rem;
    padding: 0.75rem;
    max-width: 500px;
    width: 90%;
    max-height: 85vh;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    animation: slideUp 0.3s ease-out;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.rating-modal.compact {
    padding: 0.625rem;
    max-height: 80vh;
}

[data-theme="dark"] .rating-modal {
    background: var(--background-white);
}

.star-rating {
    display: flex;
    justify-content: center;
    gap: 0.25rem;
    margin: 0.375rem 0;
    flex-shrink: 0;
}

.rating-modal.compact .star-rating {
    margin: 0.25rem 0;
}
    
.star {
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    color: #d1d5db;
    user-select: none;
    flex-shrink: 0;
}

.star:hover,
.star.active {
    color: #fbbf24;
    transform: scale(1.1);
}

.star:active {
    transform: scale(0.95);
}

.rating-title {
    text-align: center;
    font-size: 0.8125rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 0.125rem;
    font-family: 'Poppins', sans-serif;
    flex-shrink: 0;
}

.rating-modal.compact .rating-title {
    font-size: 0.75rem;
    margin-bottom: 0.0625rem;
}

[data-theme="dark"] .rating-title {
    color: #ffffff;
}

.rating-subtitle {
    text-align: center;
    font-size: 0.625rem;
    color: #6b7280;
    margin-bottom: 0.375rem;
    font-family: 'Poppins', sans-serif;
    flex-shrink: 0;
}

.rating-modal.compact .rating-subtitle {
    font-size: 0.5625rem;
    margin-bottom: 0.25rem;
}

[data-theme="dark"] .rating-subtitle {
    color: #9ca3af;
}

.rating-buttons {
    display: flex;
    gap: 0.375rem;
    margin-top: 0.5rem;
    flex-shrink: 0;
    padding-top: 0.375rem;
}

.rating-modal.compact .rating-buttons {
    margin-top: 0.375rem;
    padding-top: 0.25rem;
}

.rating-btn {
    flex: 1;
    padding: 0.5rem;
    border: none;
    border-radius: 0.5rem;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Poppins', sans-serif;
}

.rating-btn.cancel {
    background: #f3f4f6;
    color: #374151;
}

.rating-btn.cancel:hover {
    background: #e5e7eb;
}

[data-theme="dark"] .rating-btn.cancel {
    background: #374151;
    color: #f3f4f6;
}

[data-theme="dark"] .rating-btn.cancel:hover {
    background: #4b5563;
}

.rating-btn.submit {
    background: #1A733E;
    color: white;
    opacity: 0.5;
    cursor: not-allowed;
}

.rating-btn.submit.enabled {
    opacity: 1;
    cursor: pointer;
}

.rating-btn.submit.enabled:hover {
    background: #15592f;
}

/* Feedback Modal Styles */
.feedback-title {
    font-size: 0.75rem;
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 0.125rem;
    font-family: 'Poppins', sans-serif;
}

[data-theme="dark"] .feedback-title {
    color: #ffffff;
}

.feedback-subtitle {
    font-size: 0.625rem;
    color: #6b7280;
    margin-bottom: 0.5rem;
    font-family: 'Poppins', sans-serif;
}

[data-theme="dark"] .feedback-subtitle {
    color: #9ca3af;
}

.feedback-textarea {
    width: 100%;
    min-height: 40px;
    padding: 0.375rem;
    border: 2px solid #e5e7eb;
    border-radius: 0.5rem;
    font-size: 0.6875rem;
    font-family: 'Poppins', sans-serif;
    resize: vertical;
    box-sizing: border-box;
}

.feedback-textarea:focus {
    outline: none;
    border-color: #1A733E;
}

[data-theme="dark"] .feedback-textarea {
    background: var(--background-color);
    border-color: var(--border-light);
    color: var(--text-color);
}

[data-theme="dark"] .feedback-textarea:focus {
    border-color: #1A733E;
}

.feedback-option {
    transition: all 0.2s ease;
}

.feedback-option:hover {
    transform: translateX(4px);
}

/* Compliment Button Styles */
.compliment-option-btn {
    transition: all 0.2s ease;
}

.compliment-option-btn:hover {
    transform: scale(1.02);
}

.compliment-option-btn:active {
    transform: scale(0.98);
}

.compliment-option-btn svg {
    transition: all 0.2s ease;
}

.compliment-option-btn.selected svg {
    color: white !important;
}

[data-theme="dark"] .compliment-option-btn {
    background: var(--background-color) !important;
    border-color: var(--border-light) !important;
    color: var(--text-color) !important;
}

[data-theme="dark"] .compliment-option-btn:hover:not(.selected) {
    background: rgba(26, 115, 62, 0.1) !important;
    border-color: #1A733E !important;
}

[data-theme="dark"] .compliment-option-btn.selected {
    background: #1A733E !important;
    color: white !important;
    border-color: #1A733E !important;
}

[data-theme="dark"] .compliment-option-btn.selected svg {
    color: white !important;
}

/* Footer Rating Stars Styles - Match modal stars but smaller */
.footer-star-rating {
    display: flex;
    justify-content: center;
    gap: 0.25rem;
}

.footer-star {
    font-size: 1.25rem;
    cursor: pointer;
    transition: all 0.2s ease;
    color: #d1d5db;
    user-select: none;
}

.footer-star:hover,
.footer-star.active {
    color: #fbbf24;
    transform: scale(1.1);
}

.footer-star:active {
    transform: scale(0.95);
}

/* For acknowledged footer (green background) */
#footerBar[style*="065f46"] .footer-star,
#footerBar[style*="rgb(6, 95, 70)"] .footer-star {
    color: rgba(255, 255, 255, 0.3);
}

#footerBar[style*="065f46"] .footer-star:hover,
#footerBar[style*="rgb(6, 95, 70)"] .footer-star:hover,
#footerBar[style*="065f46"] .footer-star.active,
#footerBar[style*="rgb(6, 95, 70)"] .footer-star.active {
    color: #fbbf24;
}

.feedback-option input[type="checkbox"] {
    transition: all 0.2s ease;
}

[data-theme="dark"] .feedback-option {
    background: var(--background-white) !important;
    border-color: var(--border-light) !important;
}

[data-theme="dark"] .feedback-option span {
    color: var(--text-color) !important;
}

[data-theme="dark"] .feedback-option:hover {
    background: var(--gray-100) !important;
}

.feedback-buttons {
    display: flex;
    gap: 0.75rem;
    margin-top: 1rem;
}

.feedback-btn {
    flex: 1;
    padding: 0.75rem;
    border: none;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Poppins', sans-serif;
}

.feedback-btn.skip {
    background: #f3f4f6;
    color: #374151;
}

.feedback-btn.skip:hover {
    background: #e5e7eb;
}

[data-theme="dark"] .feedback-btn.skip {
    background: #374151;
    color: #f3f4f6;
}

[data-theme="dark"] .feedback-btn.skip:hover {
    background: #4b5563;
}

.feedback-btn.submit {
    background: #1A733E;
    color: white;
}

.feedback-btn.submit:hover {
    background: #15592f;
}
</style>

<script>
// Feature flag: Enable/disable rating system
const ENABLE_RATING_SYSTEM = true; // Set to true to enable rating features

// Feature flag: Enable/disable reversal window time constraint
// When false, agents have no time constraints for reversals (reversal button always available)
// When true, reversal button is hidden after REVERSAL_WINDOW_HOURS hours from audit submission
const ENABLE_REVERSAL_WINDOW = false; // Set to true to enable time constraint
const REVERSAL_WINDOW_HOURS = 150; // Number of hours for reversal window (only used when ENABLE_REVERSAL_WINDOW is true)

// Global audit data
let currentAudit = null;
let currentScorecardId = null;
let currentTableName = null;
let currentErrorFields = [];
let currentAuditScorecard = null;
let currentUserEmail = null;

// Get current logged-in user email
function getCurrentUserEmail() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            const user = JSON.parse(userInfo);
            return user?.email || null;
        }
    } catch (error) {
        console.error('Error getting current user email:', error);
    }
    return null;
}

// Get current logged-in user info
function getCurrentUserInfo() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            return JSON.parse(userInfo);
        }
    } catch (error) {
        console.error('Error getting current user info:', error);
    }
    return null;
}

// Build reversal journey map/roadmap indicator
async function buildReversalJourneyMap(workflowState, teamLeadApproved, audit) {
    // Check if this reversal actually went through Team Lead Review
    // This should be shown if:
    // 1. The workflow state includes team_lead_review or team_lead_approved/rejected
    // 2. OR team_lead_reviewed_by is populated (indicating it went through TL review)
    // 3. OR there's a team_lead_review state in reversal_workflow_states
    const hasTeamLeadReview = 
        workflowState === 'team_lead_review' || 
        workflowState === 'team_lead_approved' || 
        workflowState === 'team_lead_rejected' ||
        (audit && (audit.teamLeadReviewedBy || audit.team_lead_reviewed_by)) ||
        (audit && (audit.teamLeadApproved !== null && audit.teamLeadApproved !== undefined)) ||
        (audit && (audit.team_lead_approved !== null && audit.team_lead_approved !== undefined)) ||
        (audit && audit.acknowledgement_status && audit.acknowledgement_status.toLowerCase().includes('team_lead'));
    
    // Also check reversal_workflow_states if available
    let hasTeamLeadReviewInWorkflow = false;
    if (audit && audit.id && currentTableName) {
        try {
            const { data: reversalRequest, error: rrError } = await window.supabaseClient
                .from('reversal_requests')
                .select('id')
                .eq('audit_id', audit.id)
                .eq('scorecard_table_name', currentTableName)
                .order('requested_at', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!rrError && reversalRequest) {
                const { data: workflowStates, error: wsError } = await window.supabaseClient
                    .from('reversal_workflow_states')
                    .select('state')
                    .eq('reversal_request_id', reversalRequest.id)
                    .in('state', ['team_lead_review', 'team_lead_approved', 'team_lead_rejected']);
                
                if (!wsError && workflowStates && workflowStates.length > 0) {
                    hasTeamLeadReviewInWorkflow = true;
                }
            }
        } catch (err) {
            console.warn('Error checking workflow states for Team Lead Review:', err);
        }
    }
    
    // Show Team Lead Review stage if the reversal actually went through it
    const showTeamLeadReview = hasTeamLeadReview || hasTeamLeadReviewInWorkflow;
    
    // Define all stages in order - compact checkout-style
    // Include team_lead_review stage if the reversal actually went through it
    const stages = [
        { 
            key: 'submitted', 
            label: 'Submitted'
        }
    ];
    
    // Add team lead review stage if this reversal went through it
    if (showTeamLeadReview) {
        stages.push({
            key: 'team_lead_review', 
            label: 'Team Lead Review'
        });
    }
    
    stages.push(
        { 
            key: 'qa_review', 
            label: 'QC Review'
        },
        { 
            key: 'final_decision', 
            label: 'Final Decision'
        }
    );
    
    // Determine current stage index (accounting for conditional team_lead_review stage)
    let currentStageIndex = 0;
    let currentStageKey = 'submitted';
    
    if (showTeamLeadReview) {
        // Team lead review stage exists - use index logic with TL review
        // Check if team lead has already approved - if so, move to QC Review stage (use mapped fields)
        const isTeamLeadApproved = teamLeadApproved === true || teamLeadApproved === 'true' || teamLeadApproved === 1 || teamLeadApproved === '1' ||
                                   (audit && (audit.teamLeadApproved === true || audit.teamLeadApproved === 'true' || audit.teamLeadApproved === 1 || audit.teamLeadApproved === '1')) ||
                                   (audit && (audit.team_lead_approved === true || audit.team_lead_approved === 'true' || audit.team_lead_approved === 1 || audit.team_lead_approved === '1'));
        
        console.log('buildReversalJourneyMap (audit-view) - Stage determination:', {
            workflowState,
            teamLeadApproved,
            isTeamLeadApproved,
            auditTeamLeadApproved: audit?.team_lead_approved,
            ackStatus: audit?.acknowledgement_status
        });
        
        if (workflowState === 'team_lead_rejected') {
            currentStageIndex = 1;
            currentStageKey = 'team_lead_rejected';
            console.log('Journey Map: Team Lead Rejected - Stage 1');
        } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
            // Already at QA review stage
            currentStageIndex = 2;
            currentStageKey = 'qa_review';
            console.log('Journey Map: QA Review - Stage 2');
        } else if (isTeamLeadApproved) {
            // Team lead has approved - move to QC Review stage (even if workflowState hasn't updated yet)
            currentStageIndex = 2;
            currentStageKey = 'qa_review';
            console.log('Journey Map: Team Lead Approved - Moving to Stage 2 (QA Review)');
        } else if (workflowState === 'team_lead_review' || workflowState === 'pending') {
            // Still waiting for team lead review
            currentStageIndex = 1;
            currentStageKey = 'team_lead_review';
            console.log('Journey Map: Waiting for Team Lead - Stage 1');
        } else if (workflowState === 'approved' || workflowState === 'rejected') {
            // Final Decision is completed - mark it as completed, not current
            currentStageIndex = 4; // One past the last stage (Final Decision is at index 3)
            currentStageKey = workflowState === 'approved' ? 'approved' : 'rejected';
            console.log('Journey Map: Final Decision - Stage 4');
        } else if (workflowState === 'acknowledged') {
            // Acknowledged is after final decision - Final Decision is completed
            currentStageIndex = 4; // One past the last stage (Final Decision is at index 3)
            currentStageKey = 'acknowledged';
            console.log('Journey Map: Acknowledged - Stage 4');
        } else {
            console.log('Journey Map: Default - Stage 0 (Submitted)');
        }
        
        console.log('Journey Map Final State (audit-view):', { currentStageIndex, currentStageKey, totalStages: stages.length });
    } else {
        // Team lead review stage doesn't exist - skip that stage
        if (workflowState === 'qa_review' || workflowState === 'cqc_review' || workflowState === 'pending') {
            currentStageIndex = 1; // qa_review is now at index 1 (after submitted)
            currentStageKey = 'qa_review';
        } else if (workflowState === 'approved' || workflowState === 'rejected') {
            // Final Decision is completed - mark it as completed, not current
            currentStageIndex = 3; // One past the last stage (Final Decision is at index 2)
            currentStageKey = workflowState === 'approved' ? 'approved' : 'rejected';
        } else if (workflowState === 'acknowledged') {
            // Acknowledged is after final decision - Final Decision is completed
            currentStageIndex = 3; // One past the last stage (Final Decision is at index 2)
            currentStageKey = 'acknowledged';
        }
    }
    
    // Build compact checkout-style journey map
    let journeyMapHtml = '<div style="display: flex; align-items: flex-start; width: 100%; position: relative; padding: 0.5rem 0;">';
    
    stages.forEach((stage, index) => {
        const isCompleted = index < currentStageIndex;
        const isCurrent = index === currentStageIndex;
        const isRejected = (stage.key === 'team_lead_review' && currentStageKey === 'team_lead_rejected') || 
                          (stage.key === 'final_decision' && currentStageKey === 'rejected');
        const isFuture = index > currentStageIndex;
        
        // Determine circle styles (like checkout progress)
        let circleBg = '#ffffff';
        let circleBorder = '#d1d5db';
        let circleContent = '';
        let labelColor = '#6b7280';
        let labelWeight = '500';
        
        if (isCompleted) {
            circleBg = '#16a34a';
            circleBorder = '#16a34a';
            circleContent = '<svg style="width: 0.75rem; height: 0.75rem; color: white;" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
            labelColor = '#16a34a';
            labelWeight = '600';
        } else if (isCurrent) {
            circleBg = '#ffffff';
            circleBorder = '#2563eb';
            circleContent = `<span style="font-size: 0.625rem; font-weight: 700; color: #2563eb;">${index + 1}</span>`;
            labelColor = '#2563eb';
            labelWeight = '700';
        } else if (isRejected) {
            circleBg = '#dc2626';
            circleBorder = '#dc2626';
            circleContent = '<svg style="width: 0.75rem; height: 0.75rem; color: white;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>';
            labelColor = '#dc2626';
            labelWeight = '600';
        } else {
            circleContent = `<span style="font-size: 0.625rem; font-weight: 600; color: #6b7280;">${index + 1}</span>`;
        }
        
        // Connector line color (green if previous step completed, grey otherwise)
        const connectorColor = isCompleted ? '#16a34a' : '#e5e7eb';
        
        journeyMapHtml += `
            <div style="display: flex; flex-direction: column; align-items: center; flex: 1; position: relative;">
                ${index < stages.length - 1 ? `
                <div style="position: absolute; top: 0.625rem; left: calc(50% + 0.625rem); width: calc(100% - 1.25rem); height: 0.125rem; background: ${connectorColor}; z-index: 0;"></div>
                ` : ''}
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background: ${circleBg}; border: 0.125rem solid ${circleBorder}; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-bottom: 0.375rem; position: relative; z-index: 1;">
                    ${circleContent}
                    </div>
                <span style="font-size: 0.5rem; font-weight: ${labelWeight}; color: ${labelColor}; text-align: center; font-family: 'Poppins', sans-serif; white-space: nowrap;">
                        ${stage.label}
                    </span>
            </div>
        `;
    });
    
    journeyMapHtml += '</div>';
    
    return journeyMapHtml;
}

// Check if current user is the audited employee
function isCurrentUserAuditedEmployee() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditEmployeeEmail = currentAudit.employeeEmail || currentAudit.employee_email || '';
    return auditEmployeeEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is a Quality Analyst or above (not an Agent/Employee)
function isCurrentUserQualityAnalyst() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    // Allow Quality Analyst and any role above (not Employee)
    return role !== 'Employee' && role !== '';
}

// Check if current user is the auditor of the current audit
function isCurrentUserAuditor() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditAuditorEmail = currentAudit.auditorEmail || currentAudit.auditor_email || '';
    return auditAuditorEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is the original auditor of a specific audit
function isCurrentUserOriginalAuditor(audit) {
    if (!currentUserEmail || !audit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditAuditorEmail = audit.auditorEmail || audit.auditor_email || '';
    return auditAuditorEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is a Team Lead
// Note: Team Lead is not a role, but a relationship - a team lead is someone whose email/name
// is mentioned in the team_supervisor field of the users table for the audited employee
// This function is kept synchronous for backward compatibility, but team lead check should
// use isCurrentUserTeamSupervisor() which is async and checks the actual relationship
function isCurrentUserTeamLead() {
    // This function is deprecated - team leads are identified via team_supervisor relationship
    // Use isCurrentUserTeamSupervisor() instead for accurate team lead detection
    // Returning false here since there's no "team lead" role
    return false;
}

// Check if current user is CQC (Quality Control)
function isCurrentUserCQC() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = (userInfo.role || '').toLowerCase();
    return role.includes('cqc') || role.includes('quality control');
}

// Check if current user is Admin or Super Admin
function isCurrentUserAdmin() {
    if (!window.accessControl) {
        // Fallback: check userInfo directly
        const userInfo = getCurrentUserInfo();
        if (!userInfo) {
            return false;
        }
        
        const role = (userInfo.role || '').toLowerCase();
        return role === 'admin' || role === 'super admin';
    }
    
    return window.accessControl.isAdminOrAbove();
}

// Helper function to check if acknowledgement status is considered "acknowledged" (locked, no edits/comments)
function isAcknowledgedStatus(status) {
    if (!status) return false;
    const statusLower = status.toLowerCase();
    return statusLower === 'acknowledged' || 
           statusLower === 'acknowledged - after reversal approved' || 
           statusLower === 'acknowledged - after reversal rejected';
}

// Get reversal workflow state - checks reversal_requests table first, then falls back to acknowledgement_status
// This function is synchronous for backward compatibility, but can be enhanced to be async if needed
function getReversalWorkflowState(audit) {
    try {
        if (!audit) return null; // No audit, no workflow state
        
        // First check if a reversal was actually requested
        const reversalRequestedAt = audit?.reversal_requested_at || audit?.reversalRequestedAt;
        if (!reversalRequestedAt) {
            return null; // No reversal requested, no workflow state
        }
        
        // Priority 1: Check if workflow state was already loaded from reversal_workflow_states (cached on audit object)
        if (audit.reversal_workflow_state) {
            return audit.reversal_workflow_state;
        }
        
        // Priority 1.5: Try to load workflow state from reversal_requests if available (async, but we'll try to get it)
        // This is a fallback if the state wasn't cached during audit load
        if (audit.reversal_requested_at && !audit.reversal_workflow_state) {
            // Try to get it from the cached reversalRequestData if available
            // (This would require the reversal data to be loaded, which should happen in loadAuditFromURL)
            // For now, we'll rely on the acknowledgement_status parsing below
        }
        
        // Priority 2: Parse from acknowledgement_status
        const ackStatusRaw = audit?.acknowledgement_status || audit?.acknowledgementStatus;
        if (ackStatusRaw && typeof ackStatusRaw === 'string') {
            const ackStatus = ackStatusRaw.toLowerCase();
            
            // Check if team lead has approved - if so, move to QA review stage (use mapped fields)
            const teamLeadApproved = audit?.teamLeadApproved === true || audit?.teamLeadApproved === 'true' || audit?.teamLeadApproved === 1 || audit?.teamLeadApproved === '1' ||
                                     (audit?.team_lead_approved === true || audit?.team_lead_approved === 'true' || audit?.team_lead_approved === 1 || audit?.team_lead_approved === '1');
            const teamLeadRejected = audit?.teamLeadApproved === false || audit?.teamLeadApproved === 'false' || audit?.teamLeadApproved === 0 || audit?.teamLeadApproved === '0' ||
                                     (audit?.team_lead_approved === false || audit?.team_lead_approved === 'false' || audit?.team_lead_approved === 0 || audit?.team_lead_approved === '0');
            
            // If team lead rejected, return rejected state
            if (teamLeadRejected || ackStatus.includes('team_lead_rejected')) return 'team_lead_rejected';
            
            // If team lead approved, move to QA review (even if ackStatus still says team_lead_review)
            if (teamLeadApproved && (ackStatus.includes('team_lead_review') || ackStatus === 'pending' || ackStatus.includes('pending'))) {
                return 'qa_review';
            }
            
            if (ackStatus.includes('team_lead_review')) return 'team_lead_review';
            if (ackStatus.includes('qa_review') || ackStatus.includes('auditor_review')) return 'qa_review';
            if (ackStatus.includes('cqc_review')) return 'cqc_review';
            if (ackStatus.includes('cqc_sent_back')) return 'cqc_sent_back';
            if (ackStatus.includes('agent_re_review')) return 'agent_re_review';
            if (ackStatus.includes('reversal_approved')) return 'approved';
            if (ackStatus.includes('reversal_rejected')) return 'rejected';
            if (ackStatus === 'acknowledged' || ackStatus.includes('acknowledged')) return 'acknowledged';
        }
        
        // Priority 3: Fallback to old logic using reversal_approved
        const approved = audit?.reversal_approved;
        if (approved === null || approved === undefined) return 'pending';
        if (approved === true || approved === 'true' || approved === 1 || approved === '1') return 'approved';
        if (approved === false || approved === 'false' || approved === 0 || approved === '0') return 'rejected';
        
        return 'pending';
    } catch (error) {
        console.error('Error in getReversalWorkflowState:', error, audit);
        return null; // Safe fallback - return null instead of 'pending' to indicate no state
    }
}

// Async function to load workflow state from reversal_requests table and attach to audit object
async function loadReversalWorkflowState(audit) {
    if (!audit || !audit.id || !currentTableName) {
        return audit;
    }
    
    try {
        // Check if workflow state is already cached
        if (audit.reversal_workflow_state) {
            return audit;
        }
        
        // Query reversal_requests table to get current workflow state
        const { data: reversalRequest, error: rrError } = await window.supabaseClient
            .from('reversal_requests')
            .select('id, current_state_id')
            .eq('audit_id', audit.id)
            .eq('scorecard_table_name', currentTableName)
            .order('requested_at', { ascending: false })
            .limit(1)
            .maybeSingle();
        
        if (!rrError && reversalRequest && reversalRequest.current_state_id) {
            // Get the current workflow state
            const { data: workflowState, error: wsError } = await window.supabaseClient
                .from('reversal_workflow_states')
                .select('state')
                .eq('id', reversalRequest.current_state_id)
                .maybeSingle();
            
            if (!wsError && workflowState) {
                // Cache the workflow state on the audit object
                audit.reversal_workflow_state = workflowState.state;
                console.log('Loaded workflow state from reversal_requests:', workflowState.state);
            }
        }
    } catch (error) {
        console.warn('Error loading reversal workflow state:', error);
    }
    
    return audit;
}

// Check if there's a pending reversal request
function hasPendingReversalRequest() {
    if (!currentAudit) {
        return false;
    }
    
    const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
    if (!reversalRequestedAt) {
        return false; // No reversal requested
    }
    
    // Check workflow state
    const workflowState = getReversalWorkflowState(currentAudit);
    
    // Pending states that prevent acknowledgment
    const pendingStates = [
        'pending',
        'team_lead_review',
        'qa_review',
        'cqc_review'
    ];
    
    // If Team Lead rejected, it's not pending anymore - agent can acknowledge
    if (workflowState === 'team_lead_rejected') {
        return false;
    }
    
    if (pendingStates.includes(workflowState)) {
        return true;
    }
    
    // Fallback: check old logic
    const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
    const reversalApproved = currentAudit.reversal_approved || currentAudit.reversalApproved;
    
    // Pending if reversal was requested but not yet responded to
    if (reversalRequestedAt && !reversalRespondedAt) {
        return true;
    }
    
    // Also check if reversal_approved is null (which means pending)
    if (reversalRequestedAt && (reversalApproved === null || reversalApproved === undefined)) {
        return true;
    }
    
    return false;
}

// Check if reversal approval interface should be shown
// Shows for: Original Auditor of the audit, Admins and above, Team Leads (for team_lead_review stage only)
// Note: This function is synchronous but checks are done asynchronously in displayReversalApprovalInterface
function shouldShowReversalApprovalInterface() {
    if (!hasPendingReversalRequest()) {
        console.log('shouldShowReversalApprovalInterface: No pending reversal request');
        return false;
    }
    
    const workflowState = getReversalWorkflowState(currentAudit);
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    const userInfo = getCurrentUserInfo();
    
    console.log('shouldShowReversalApprovalInterface:', {
        workflowState,
        isOriginalAuditor,
        isAdmin,
        isTeamLead,
        userRole: userInfo?.role
    });
    
    // Only allow:
    // 1. Original auditor of the audit
    // 2. Admins and above
    if (isOriginalAuditor || isAdmin) {
        console.log('shouldShowReversalApprovalInterface: User is original auditor or admin - showing interface');
        return true;
    }
    
    // For team_lead_review state, also allow team leads (they can approve/reject before it goes to QA)
    // But they cannot process the final reversal decision
    const teamLeadCondition = (workflowState === 'team_lead_review' || workflowState === 'pending') && isTeamLead;
    if (teamLeadCondition) {
        // Check if user is team supervisor (async check happens in displayReversalApprovalInterface)
        // For now, allow team leads to see the interface
        console.log('shouldShowReversalApprovalInterface: User is team lead - showing interface for team lead review');
        return true;
    }
    
    console.log('shouldShowReversalApprovalInterface: No conditions met - NOT showing interface');
    return false;
}

// Check if edit button should be shown
function shouldShowEditButton() {
    // Check if audit is acknowledged - if so, lock editing for everyone
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status || '';
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        return false; // Locked - no edits allowed
    }
    
    // Auditors can edit anytime unless acknowledged
    if (isCurrentUserAuditor()) {
        return true;
    }
    
    // For Quality Analysts (non-auditors), can only edit when reversal is pending
    if (hasPendingReversalRequest() && isCurrentUserQualityAnalyst()) {
        return true;
    }
    
    return false;
}

// Check if there are any errors or feedback from auditors
function hasErrorsOrFeedback(audit, errorFields) {
    if (!errorFields || errorFields.length === 0) {
        return false;
    }
    
    // Check all error fields for errors or feedback
    for (const field of errorFields) {
        // Check for errors (non-zero counts)
        const rawValue = audit[field.key];
        let hasError = false;
        
        if (field.field_type === 'radio') {
            // For radio buttons, check if YES (error exists)
            const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
            hasError = isYes;
        } else {
            // For counters, check if count > 0
            const count = rawValue ? parseInt(rawValue) : 0;
            hasError = count > 0;
        }
        
        if (hasError) {
            return true; // Found an error
        }
        
        // Check for feedback from auditor
        const feedbackData = audit[field.feedback];
        if (feedbackData) {
            let feedbackArray = [];
            
            if (typeof feedbackData === 'string') {
                // Try to parse as JSON array, fallback to single string
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch (e) {
                    // If not valid JSON, treat as single string (backward compatibility)
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
            
            // Filter out empty feedbacks
            feedbackArray = feedbackArray.filter(f => f && f.trim());
            
            if (feedbackArray.length > 0) {
                return true; // Found feedback
            }
        }
    }
    
    return false; // No errors or feedback found
}

// Check if reversal button should be shown (hide after REVERSAL_WINDOW_HOURS hours from audit submission if window is enabled)
function checkIfReversalButtonShouldShow(auditSubmissionTime) {
    // If reversal window is disabled, always show the button (no time constraints)
    if (!ENABLE_REVERSAL_WINDOW) {
        return true;
    }
    
    if (!auditSubmissionTime) {
        return true; // If no timestamp, show button (fallback)
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const diffMs = now - submissionDate;
    const diffHours = diffMs / (1000 * 60 * 60);
    
    // Hide after REVERSAL_WINDOW_HOURS hours (only when window is enabled)
    return diffHours < REVERSAL_WINDOW_HOURS;
}

// Get time remaining until REVERSAL_WINDOW_HOURS expires (in seconds)
function getTimeRemainingUntil48Hours(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return null;
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const expirationTime = new Date(submissionDate.getTime() + (REVERSAL_WINDOW_HOURS * 60 * 60 * 1000)); // REVERSAL_WINDOW_HOURS hours
    const remainingMs = expirationTime - now;
    
    if (remainingMs <= 0) {
        return 0; // Already expired
    }
    
    return Math.floor(remainingMs / 1000); // Return seconds
}

// Format time remaining for display (always show seconds)
function formatTimeRemaining(seconds) {
    if (seconds <= 0) {
        return 'Expired';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}h ${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else {
        return `${secs}s`;
    }
}

// Handle closing/navigating away - check if acknowledgement is pending or comments without reversal
async function handleCloseAuditView() {
    // Check if user is the audited employee
    if (isCurrentUserAuditedEmployee() && currentAudit) {
        // Check if user has comments but hasn't submitted a reversal
        const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const hasComments = Object.keys(parameterComments).some(key => {
            const comment = parameterComments[key];
            if (!comment) return false;
            // Check for single comment format: {comment: "text"}
            if (comment.comment && comment.comment.trim()) return true;
            // Check for array format: {comments: ["text1", "text2"]}
            if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
            return false;
        });
        
        // Check if reversal has been submitted (check both camelCase and snake_case)
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        const hasSubmittedReversal = !!reversalRequestedAt;
        
        // If user has comments but hasn't submitted reversal, prevent navigation
        // Only check if reversal hasn't been submitted yet
        if (hasComments && !hasSubmittedReversal) {
            // Wait for confirmation dialog to be available
            if (!window.confirmationDialog) {
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!window.confirmationDialog) {
                    alert('Warning: You have unsaved parameter comments. If you leave now, your comments will be lost. Please submit a reversal request to save them.');
                    return false; // Prevent navigation
                }
            }
            
            const result = await window.confirmationDialog.show({
                title: ' Unsaved Comments',
                message: 'You have added parameter comments but haven\'t submitted a reversal request yet. If you leave now, your comments will be lost (they are only saved when you submit a reversal request).\n\nPlease submit a reversal request to save your comments before leaving.',
                confirmText: 'Request Reversal',
                cancelText: 'Leave Anyway (Comments will be lost)'
            });
            
            if (result) {
                // User wants to submit reversal - open the reversal form
                toggleReversalForm();
                return false; // Prevent navigation
            } else {
                // User chose to leave anyway - they understand comments will be lost
                // Allow navigation but warn them one more time
                const confirmLeave = confirm('Are you sure you want to leave? Your parameter comments have not been saved and will be lost.');
                if (!confirmLeave) {
                    return false; // User changed their mind
                }
                
                // Clear comments from local object (comments are only stored locally until reversal submission)
                if (currentAudit) {
                    currentAudit.parameterComments = {};
                    currentAudit.parameter_comments = {};
                }
                
                return true; // Allow navigation
            }
        }
        
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
        
        // Determine reversal status
        const reversalRespondedAt = currentAudit.reversalRespondedAt || currentAudit.reversal_responded_at;
        const reversalStatus = reversalRequestedAt && !reversalRespondedAt ? 'Pending' : 
                              (currentAudit.reversalApproved === true || currentAudit.reversal_approved === true) ? 'Approved' :
                              (currentAudit.reversalApproved === false || currentAudit.reversal_approved === false) ? 'Rejected' : null;
        
        // If a reversal is pending, user cannot acknowledge - allow navigation without showing modal
        if (reversalStatus === 'Pending') {
            return true; // Allow navigation
        }
        
        // If acknowledgement is pending (not acknowledged) and no reversal is pending, show the same confirmation as acknowledge button
        if (acknowledgementStatusLower !== 'acknowledged') {
            // Use the same confirmation dialog that appears when clicking acknowledge button
            // Create a wrapper that tracks success and shows the same confirmation
            const acknowledgeWithNavigation = async () => {
                try {
                    // Verify that current user is the audited employee
                    if (!isCurrentUserAuditedEmployee()) {
                        return false;
                    }
                    
                    // Wait for confirmation dialog to be available
                    if (!window.confirmationDialog) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.confirmationDialog) {
                            alert('Error: Confirmation dialog not available. Please refresh the page.');
                            return false;
                        }
                    }
                    
                    // Show the same confirmation dialog as the acknowledge button
                    const result = await window.confirmationDialog.show({
                        title: 'Acknowledge Audit',
                        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
                        confirmText: 'Acknowledge',
                        cancelText: 'Cancel'
                    });
                    
                    if (!result) {
                        return false; // User cancelled
                    }
                    
                    if (!currentAudit || !currentTableName) {
                        alert('Error: Audit data not available');
                        return false;
                    }
                    
                    // Record acknowledgment in the database
                    const acknowledgementTime = new Date().toISOString();
                    const { data, error } = await window.supabaseClient
                        .from(currentTableName)
                        .update({
                            acknowledgement_status: 'Acknowledged',
                            acknowledgement_status_updated_at: acknowledgementTime
                        })
                        .eq('id', currentAudit.id)
                        .select();
                    
                    if (error) throw error;
                    
                    // Show success message
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Success',
                            message: ' Audit acknowledged. Thank you for your confirmation.',
                            confirmText: 'OK',
                            type: 'success'
                        });
                    } else {
                        alert(' Audit acknowledged. Thank you for your confirmation.');
                    }
                    
                    // Update currentAudit to reflect acknowledgement
                    if (currentAudit) {
                        currentAudit.acknowledgementStatus = 'Acknowledged';
                        currentAudit.acknowledgement_status = 'Acknowledged';
                        currentAudit.acknowledgementStatusUpdatedAt = acknowledgementTime;
                        currentAudit.acknowledgement_status_updated_at = acknowledgementTime;
                    }
                    
                    return true; // Success
                    
                } catch (error) {
                    console.error('Error acknowledging audit:', error);
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to record acknowledgment. Please try again.',
                            confirmText: 'OK',
                            type: 'error'
                        });
                    } else {
                        alert('Failed to record acknowledgment. Please try again.');
                    }
                    return false;
                }
            };
            
            // Call the acknowledge function
            acknowledgementSuccessful = await acknowledgeWithNavigation();
            
            // If acknowledgement was successful, allow navigation
            // If user cancelled, prevent navigation
            return acknowledgementSuccessful;
        }
    }
    
    // If no acknowledgement pending or not the audited employee, allow navigation
    return true;
}

// Function to fetch user by name
async function getUserByName(userName) {
    if (!userName || !window.supabaseClient) return null;
    
    try {
        const { data, error } = await window.supabaseClient
            .from('users')
            .select('*')
            .ilike('name', userName)
            .limit(1)
            .single();
        
        if (error) {
            // Try case-insensitive search if exact match fails
            const { data: allUsers } = await window.supabaseClient
                .from('users')
                .select('*')
                .limit(1000);
            
            const foundUser = allUsers?.find(u => 
                u.name && u.name.toLowerCase().trim() === userName.toLowerCase().trim()
            );
            return foundUser || null;
        }
    
        return data;
    } catch (error) {
        console.error('Error fetching user by name:', error);
        return null;
    }
}

// Function to show user profile modal
function showUserProfileModal(userData, element) {
    // Remove existing modal if any
    const existingModal = document.getElementById('userProfileModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    if (!userData) {
        return; // No user data to show
    }
    
    // Get element position
    const rect = element.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'userProfileModal';
    modal.style.cssText = `
        position: absolute;
        top: ${rect.bottom + scrollTop + 5}px;
        left: ${rect.left + scrollLeft}px;
        background: white;
        border-radius: 0.375rem;
        box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.15);
        padding: 0.75rem;
        min-width: 12.5rem;
        max-width: 18.75rem;
        z-index: 10000;
        border: 0.0625rem solid #e5e7eb;
        font-family: 'Poppins', sans-serif;
    `;
    
    // Get user avatar or initials
    const avatarUrl = userData.avatar_url || userData.avatar;
    const initials = userData.name ? userData.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2) : '?';
    
    // Build modal content
    modal.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 0.5625rem;">
            <div style="display: flex; align-items: center; gap: 0.5625rem; padding-bottom: 0.5625rem; border-bottom: 0.0625rem solid #e5e7eb;">
                ${avatarUrl ? `
                    <img src="${escapeHtml(avatarUrl)}" style="width: 2.5rem; height: 2.5rem; border-radius: 50%; object-fit: cover;" alt="${escapeHtml(userData.name || '')}">
                ` : `
                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 50%; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.875rem;">
                        ${initials}
                    </div>
                `}
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; font-size: 0.75rem; color: #1f2937; margin-bottom: 0.125rem;">${escapeHtml(userData.name || 'Unknown')}</div>
                    <div style="font-size: 0.5625rem; color: #6b7280;">${escapeHtml(userData.email || '')}</div>
                </div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 0.375rem; font-size: 0.6094rem;">
                ${userData.role ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Role:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.role)}</span>
                    </div>
                ` : ''}
                ${userData.department ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Department:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.department)}</span>
                    </div>
                ` : ''}
                ${userData.team ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Team:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.team)}</span>
                    </div>
                ` : ''}
                ${userData.channel ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Channel:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.channel)}</span>
                    </div>
                ` : ''}
                ${userData.designation ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Designation:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.designation)}</span>
                    </div>
                ` : ''}
                ${userData.employee_id ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Employee ID:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.employee_id)}</span>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Position modal to stay within viewport
    const modalRect = modal.getBoundingClientRect();
    if (modalRect.right > window.innerWidth) {
        modal.style.left = `${window.innerWidth - modalRect.width - 10}px`;
    }
    if (modalRect.bottom > window.innerHeight) {
        modal.style.top = `${rect.top + scrollTop - modalRect.height - 5}px`;
    }
    
    // Close modal when clicking outside or when mouse leaves
    const closeModal = (e) => {
        if (!modal.contains(e.target) && !element.contains(e.target)) {
            modal.remove();
            document.removeEventListener('click', closeModal);
        }
    };
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', closeModal);
    }, 100);
    
    // Close when mouse leaves the element and modal
    element.addEventListener('mouseleave', (e) => {
        const relatedTarget = e.relatedTarget;
        if (!modal.contains(relatedTarget)) {
            setTimeout(() => {
                if (!element.matches(':hover') && !modal.matches(':hover')) {
                    modal.remove();
                }
            }, 200);
        }
    });
    
    modal.addEventListener('mouseleave', () => {
        setTimeout(() => {
            if (!element.matches(':hover') && !modal.matches(':hover')) {
                modal.remove();
            }
        }, 200);
    });
}

// Setup hover event listeners for user profile
function setupUserProfileHovers() {
    // Use event delegation for dynamically created elements
    document.addEventListener('mouseenter', async function(e) {
        // Check if e.target is an Element before calling closest
        if (!e.target || typeof e.target.closest !== 'function') return;
        const hoverElement = e.target.closest('.user-profile-hover');
        if (!hoverElement) return;
        
        const userName = hoverElement.getAttribute('data-user-name');
        if (!userName || userName === 'Team Lead') return;
        
        // Fetch user data
        const userData = await getUserByName(userName);
        if (userData) {
            showUserProfileModal(userData, hoverElement);
        }
    }, true);
}

// Load audit on page load
document.addEventListener('DOMContentLoaded', async function() {
    try {
        // Check page access using centralized access control (basic check)
        // Resource-level check will be done after loading audit data
        if (!window.accessControl || !window.accessControl.enforcePageAccess('audit-view.html')) {
            return; // Access denied, user will be redirected
        }
        
        // Get current user email first
        currentUserEmail = getCurrentUserEmail();
        
        // Setup user profile hovers
        setupUserProfileHovers();
        
        await loadAuditFromURL();
        
        // Add escape key listener - check acknowledgement before closing
        document.addEventListener('keydown', async function(event) {
            if (event.key === 'Escape') {
                event.preventDefault(); // Prevent default escape behavior
                const canNavigate = await handleCloseAuditView();
                if (canNavigate) {
                    window.location.href = 'audit-reports.html';
                }
            }
        });
        
        // Prevent browser close/refresh when user has unsaved comments
        window.addEventListener('beforeunload', function(event) {
            if (isCurrentUserAuditedEmployee() && currentAudit) {
                const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
                const hasComments = Object.keys(parameterComments).some(key => {
                    const comment = parameterComments[key];
                    if (!comment) return false;
                    // Check for single comment format: {comment: "text"}
                    if (comment.comment && comment.comment.trim()) return true;
                    // Check for array format: {comments: ["text1", "text2"]}
                    if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
                    return false;
                });
                
                const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                const hasSubmittedReversal = !!reversalRequestedAt;
                
                // If user has comments but hasn't submitted reversal, prevent page unload
                if (hasComments && !hasSubmittedReversal) {
                    // Modern browsers ignore custom messages, but we still need to set returnValue
                    event.preventDefault();
                    event.returnValue = 'You have unsaved parameter comments. If you leave now, your comments will be lost (they are only saved when you submit a reversal request).';
                    return event.returnValue;
                }
            }
        });
    } catch (error) {
        console.error('Error loading audit:', error);
        showError('Failed to load audit: ' + error.message);
    }
});

// Load audit from URL parameters
async function loadAuditFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');

    if (!auditId || !tableName) {
        showError('Invalid URL parameters. Missing audit ID or table name.');
        return;
    }

    currentTableName = tableName;

    try {
        // Wait for Supabase to initialize
        let attempts = 0;
        const maxAttempts = 50;
        while (!window.supabaseClient && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            throw new Error('Supabase client not initialized');
        }

        // Load audit data
        // Try to get the audit - if .single() fails, check if it's because no results were found
        let data, error;
        const result = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId);
        
        if (result.error) {
            error = result.error;
            data = null;
        } else if (result.data && result.data.length === 0) {
            // No results found
            error = { message: `Audit with ID "${auditId}" not found in table "${tableName}"` };
            data = null;
        } else if (result.data && result.data.length === 1) {
            // Exactly one result - success
            data = result.data[0];
            error = null;
        } else if (result.data && result.data.length > 1) {
            // Multiple results - use first one but log warning
            console.warn(`Multiple audits found with ID "${auditId}" in table "${tableName}". Using first result.`);
            data = result.data[0];
            error = null;
        } else {
            error = { message: 'Unknown error loading audit' };
            data = null;
        }

        if (error) throw error;
        if (!data) throw new Error('Audit not found');

        currentAudit = data;
        
        // Get scorecard ID from URL parameter, or try to get it from audit data or table name
        let finalScorecardId = scorecardId;
        
        // If not in URL, try to get from audit data
        if (!finalScorecardId && data.scorecard_id) {
            finalScorecardId = data.scorecard_id;
        }
        
        // If still not found, try to find scorecard by matching table name
        if (!finalScorecardId && tableName) {
            try {
                const { data: scorecards, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('id')
                    .eq('table_name', tableName)
                    .limit(1);
                
                if (!scorecardError && scorecards && scorecards.length > 0) {
                    finalScorecardId = scorecards[0].id;
                }
            } catch (err) {
                console.warn('Could not find scorecard by table name:', err);
            }
        }
        
        currentScorecardId = finalScorecardId;

        // Fetch reversal_requests data if reversal exists (for new structure)
        let reversalRequestData = null;
        if (data.reversal_requested_at) {
            try {
                const { data: reversalRequest, error: rrError } = await window.supabaseClient
                    .from('reversal_requests')
                    .select('id, final_decision_by_name, final_decision_by_email, final_decision_at, final_decision, current_state_id, team_lead_response')
                    .eq('audit_id', auditId)
                    .eq('scorecard_table_name', tableName)
                    .order('requested_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();
                
                if (!rrError && reversalRequest) {
                    reversalRequestData = reversalRequest;
                    
                    // Get team lead review data from workflow states and cache workflow state
                    if (reversalRequest.current_state_id) {
                        const { data: currentState, error: wsError } = await window.supabaseClient
                            .from('reversal_workflow_states')
                            .select('entered_by_name, entered_by_email, entered_at, state, rejection_reason')
                            .eq('id', reversalRequest.current_state_id)
                            .eq('is_current', true)
                            .maybeSingle();
                        
                        if (!wsError && currentState) {
                            // Cache the workflow state on reversalRequestData for getReversalWorkflowState to use
                            reversalRequestData.workflow_state = currentState.state;
                            
                            // Get team lead review data if applicable
                            if (currentState.state === 'team_lead_approved' || currentState.state === 'team_lead_rejected' || currentState.state === 'team_lead_review') {
                                reversalRequestData.teamLeadReviewData = {
                                    reviewed_by: currentState.entered_by_name,
                                    reviewed_at: currentState.entered_at,
                                    approved: currentState.state === 'team_lead_approved',
                                    rejected: currentState.state === 'team_lead_rejected',
                                    rejection_reason: currentState.rejection_reason || null
                                };
                            }
                        }
                    }
                    
                    // Also check for team_lead_approved or team_lead_rejected states (might not be current if workflow progressed)
                    if (reversalRequest.id && !reversalRequestData.teamLeadReviewData) {
                        const { data: teamLeadState, error: tlError } = await window.supabaseClient
                            .from('reversal_workflow_states')
                            .select('entered_by_name, entered_by_email, entered_at, state, rejection_reason')
                            .eq('reversal_request_id', reversalRequest.id)
                            .in('state', ['team_lead_approved', 'team_lead_rejected'])
                            .order('entered_at', { ascending: false })
                            .limit(1)
                            .maybeSingle();
                        
                        if (!tlError && teamLeadState) {
                            reversalRequestData.teamLeadReviewData = {
                                reviewed_by: teamLeadState.entered_by_name,
                                reviewed_at: teamLeadState.entered_at,
                                approved: teamLeadState.state === 'team_lead_approved',
                                rejected: teamLeadState.state === 'team_lead_rejected',
                                rejection_reason: teamLeadState.rejection_reason || null
                            };
                        }
                    }
                }
            } catch (err) {
                console.warn('Error fetching reversal_requests data:', err);
            }
        }

        // Map snake_case to camelCase
        const audit = {
            ...data,
            id: data.id,
            submittedAt: data.submitted_at || data.audit_timestamp,
            auditTimestamp: data.submitted_at || data.audit_timestamp, // Using submitted_at for backward compatibility
            auditDuration: data.audit_duration,
            auditorEmail: data.auditor_email,
            auditorName: data.auditor_name,
            employeeName: data.employee_name,
            employeeEmail: data.employee_email,
            employeeType: data.employee_type,
            employeeDepartment: data.employee_department,
            interactionId: data.interaction_id,
            interactionDate: data.interaction_date,
            auditType: data.audit_type,
            channel: data.channel,
            quarter: data.quarter,
            week: data.week,
            countryOfEmployee: data.country_of_employee,
            clientEmail: data.client_email,
            agentPreStatus: data.agent_pre_status,
            agentPostStatus: data.agent_post_status,
            passingStatus: data.passing_status,
            validationStatus: data.validation_status,
            averageScore: data.average_score,
            criticalErrors: data.critical_errors,
            totalErrorsCount: data.total_errors_count,
            transcript: data.transcript,
            errorDescription: data.error_description,
            criticalFailError: data.critical_fail_error,
            criticalError: data.critical_error,
            significantError: data.significant_error,
            recommendations: data.recommendations,
            // Reversal tracking fields
            reversalRequestedAt: data.reversal_requested_at,
            reversalRespondedAt: data.reversal_responded_at,
            reversalStatus: data.reversal_status, // Map reversal_status
            slaInHours: data.sla_in_hours,
            reasonForReversalResponseDelay: data.response_from_auditor,
            reversalApproved: data.reversal_approved,
            withinAuditorScope: data.within_auditor_scope,
            scoreBeforeAppeal: data.score_before_appeal,
            scoreAfterAppeal: data.score_after_appeal,
            didResultInPass: data.did_result_in_pass,
            reversalType: data.reversal_type,
            reversalMetricsParameters: data.reversal_metrics_parameters,
            reversalJustificationFromAgent: data.reversal_justification_from_agent,
            reversalAttachments: data.reversal_attachments,
            reversalApprovedBy: data.reversal_approved_by,
            // reversalResolvedBy: Use final_decision_by_name from reversal_requests (new structure) with fallback to audit table (old structure)
            reversalResolvedBy: reversalRequestData?.final_decision_by_name || data.reversal_resolved_by,
            // Cache workflow state from reversal_workflow_states for getReversalWorkflowState to use
            reversal_workflow_state: reversalRequestData?.workflow_state || null,
            // Team Lead review fields: Use from reversal_workflow_states (new structure) with fallback to audit table (backward compatibility)
            teamLeadApproved: reversalRequestData?.teamLeadReviewData?.approved !== undefined 
                ? reversalRequestData.teamLeadReviewData.approved 
                : (data.team_lead_approved !== undefined ? (data.team_lead_approved === true || data.team_lead_approved === 'true' || data.team_lead_approved === 1 || data.team_lead_approved === '1') : null),
            team_lead_approved: reversalRequestData?.teamLeadReviewData?.approved !== undefined 
                ? reversalRequestData.teamLeadReviewData.approved 
                : data.team_lead_approved,
            teamLeadReviewedBy: reversalRequestData?.teamLeadReviewData?.reviewed_by || data.team_lead_reviewed_by || '',
            team_lead_reviewed_by: reversalRequestData?.teamLeadReviewData?.reviewed_by || data.team_lead_reviewed_by || '',
            teamLeadReviewedAt: reversalRequestData?.teamLeadReviewData?.reviewed_at || data.team_lead_reviewed_at || null,
            team_lead_reviewed_at: reversalRequestData?.teamLeadReviewData?.reviewed_at || data.team_lead_reviewed_at || null,
            teamLeadRejectionReason: reversalRequestData?.teamLeadReviewData?.rejection_reason || data.team_lead_rejection_reason || '',
            team_lead_rejection_reason: reversalRequestData?.teamLeadReviewData?.rejection_reason || data.team_lead_rejection_reason || '',
            // Team Lead response: Use from reversal_requests (new structure) - not stored in audit table
            responseFromTeamLead: reversalRequestData?.team_lead_response || null,
            response_from_team_lead: reversalRequestData?.team_lead_response || null,
            // Acknowledgement tracking fields
            acknowledgementStatus: data.acknowledgement_status,
            acknowledgementStatusUpdatedAt: data.acknowledgement_status_updated_at,
            // Rating fields
            audit_rating: data.audit_rating,
            audit_rating_feedback: data.audit_rating_feedback,
            audit_rated_at: data.audit_rated_at,
            // Parameter comments
            parameterComments: data.parameter_comments || {},
            parameter_comments: data.parameter_comments || {},
            _scorecard_id: finalScorecardId,
            scorecardId: finalScorecardId,
            scorecard_id: finalScorecardId,
            _scorecard_table: tableName
        };

        // Load scorecard parameters
        let errorFields = [];
        let auditScorecard = null;

        if (finalScorecardId) {
            try {
                // Load scorecard info
                const { data: scorecardData, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('*')
                    .eq('id', finalScorecardId)
                    .single();

                if (!scorecardError && scorecardData) {
                    auditScorecard = scorecardData;
                }

                // Load parameters
                const { data: parameters, error: paramsError } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .select('*')
                    .eq('scorecard_id', finalScorecardId)
                    .eq('is_active', true)
                    .order('display_order', { ascending: true });

                if (!paramsError && parameters) {
                    errorFields = parameters.map(param => {
                        // Map error category to severity label
                        const category = param.error_category || '';
                        let severity = 'Significant'; // default
                        if (category.includes('Fail')) {
                            severity = 'Critical Fail';
                        } else if (category.includes('Critical')) {
                            severity = 'Critical';
                        } else if (category.includes('Significant')) {
                            severity = 'Significant';
                        } else if (category.includes('Major')) {
                            severity = 'Major';
                        } else if (category.includes('Minor')) {
                            severity = 'Minor';
                        }
                        
                        return {
                            key: param.field_id,
                            label: param.error_name,
                            feedback: `feedback_${param.field_id}`,
                            severity: severity,
                            field_type: param.field_type || 'counter',
                            parameter_type: param.parameter_type || 'error',
                            points: param.penalty_points || 0
                        };
                    });
                }
            } catch (err) {
                console.error('Error loading scorecard parameters:', err);
            }
        }

        // Store errorFields globally for reversal form
        currentErrorFields = errorFields;
        
        // Store scorecard globally for score calculation
        currentAuditScorecard = auditScorecard;
        
        // Update currentAudit to the mapped version (with camelCase fields)
        currentAudit = audit;

        // Render the audit
        try {
        await renderAudit(audit, auditScorecard, errorFields);

        // Hide loading indicator
        document.getElementById('loadingIndicator').style.display = 'none';
        } catch (renderError) {
            console.error('Error rendering audit:', renderError);
            showError('Error rendering audit: ' + (renderError.message || 'Unknown error'));
        }

    } catch (error) {
        console.error('Error loading audit:', error);
        showError(error.message);
    }
}

// Show error message
function showError(message) {
    document.getElementById('loadingIndicator').style.display = 'none';
    document.getElementById('errorMessage').style.display = 'block';
    document.getElementById('errorText').textContent = message;
}

// Copy audit ID to clipboard
window.copyAuditId = function(auditId, element) {
    if (!auditId) return;
    
    navigator.clipboard.writeText(auditId).then(() => {
        // Visual feedback - temporarily change text
        const originalText = element.textContent;
        element.textContent = 'Copied!';
        element.style.background = 'rgba(26, 115, 62, 0.4)';
        element.style.borderColor = 'rgba(255,255,255,0.8)';
        
        // Show notification if available
        if (typeof showNotification === 'function') {
            showNotification('Audit ID copied!', 'success');
        }
        
        // Reset after 1.5 seconds
        setTimeout(() => {
            element.textContent = originalText;
            element.style.background = 'rgba(0,0,0,0.2)';
            element.style.borderColor = 'rgba(255,255,255,0.3)';
        }, 1500);
    }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = auditId;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            if (typeof showNotification === 'function') {
                showNotification('Audit ID copied!', 'success');
            }
        } catch (err) {
            if (typeof showNotification === 'function') {
                showNotification('Failed to copy Audit ID', 'error');
            }
        }
        document.body.removeChild(textArea);
    });
};

// Edit current audit
function editCurrentAudit() {
    if (!currentAudit || !currentScorecardId || !currentTableName) {
        alert('Cannot edit audit: missing required data');
        return;
    }
    
    // Check if audit is acknowledged - lock editing for everyone
    const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        alert('This audit has been acknowledged and cannot be edited.');
        return;
    }
    
    // Verify that current user has permission to edit
    if (!shouldShowEditButton()) {
        alert('Error: You do not have permission to edit this audit.');
        return;
    }
    
    window.location.href = `edit-audit.html?id=${currentAudit.id}&scorecard=${currentScorecardId}&table=${currentTableName}`;
}

// Helper function to convert URLs in text to clickable links
function convertUrlsToLinks(text) {
    if (!text) return '';
    
    // URL pattern: matches http://, https://, and www. URLs
    const urlPattern = /(https?:\/\/[^\s<>"']+|www\.[^\s<>"']+)/gi;
    
    // Split text by URLs and process each part
    const parts = [];
    let lastIndex = 0;
    let match;
    
    while ((match = urlPattern.exec(text)) !== null) {
        // Add text before URL (escaped)
        if (match.index > lastIndex) {
            parts.push({
                type: 'text',
                content: escapeHtml(text.substring(lastIndex, match.index))
            });
        }
        
        // Add URL as link
        let url = match[0];
        // Add http:// if it's a www. URL
        if (url.startsWith('www.')) {
            url = 'https://' + url;
        }
        
        parts.push({
            type: 'link',
            content: url
        });
        
        lastIndex = match.index + match[0].length;
    }
    
    // Add remaining text after last URL
    if (lastIndex < text.length) {
        parts.push({
            type: 'text',
            content: escapeHtml(text.substring(lastIndex))
        });
    }
    
    // If no URLs found, just escape and return the text
    if (parts.length === 0) {
        return escapeHtml(text);
    }
    
    // Build HTML with links
    return parts.map(part => {
        if (part.type === 'link') {
            return `<a href="${escapeHtml(part.content)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline;">${escapeHtml(part.content)}</a>`;
        }
        return part.content;
    }).join('');
}

// Generate error details HTML
function generateErrorDetails(audit, errorFields) {
    // Check if current user is the audited employee (for showing comment boxes)
    const isAuditedEmployee = isCurrentUserAuditedEmployee();
    
    // Check if reversal has been submitted (disable inputs if so)
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    const hasReversalSubmitted = !!reversalRequestedAt;
    
    // Check if audit is acknowledged (hide comment input boxes if so)
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';
    const isAcknowledged = acknowledgementStatus.toLowerCase() === 'acknowledged';
    
    // Load parameter comments from audit data (check both audit parameter and currentAudit global)
    let parameterComments = audit.parameterComments || audit.parameter_comments || {};
    
    // Also check currentAudit for comments (may have real-time updates)
    if (typeof currentAudit !== 'undefined' && currentAudit) {
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        // Merge: currentAudit takes precedence as it has the latest data
        parameterComments = { ...parameterComments, ...currentComments };
    }
    
    // Also check inline comment inputs in the DOM (real-time fallback)
    const inlineComments = {};
    try {
        errorFields.forEach(field => {
            const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
            const comments = [];
            commentInputs.forEach(input => {
                if (input.value && input.value.trim()) {
                    comments.push(input.value.trim());
                }
            });
            if (comments.length > 0) {
                inlineComments[field.key] = { comments: comments };
            }
        });
        // Merge inline comments (takes precedence as they're most up-to-date)
        parameterComments = { ...parameterComments, ...inlineComments };
    } catch (e) {
        // If DOM check fails (e.g., function called before DOM is ready), continue with audit data only
        console.warn('Could not check inline comments from DOM:', e);
    }
    
    // Filter error parameters: only show error parameters that have feedback from the auditor
    const filteredErrorFields = errorFields.filter(field => {
        // If it's not an error parameter, always show it
        if (field.parameter_type !== 'error') {
            return true;
        }
        
        // For error parameters, only show if they have feedback from the auditor
        // Check feedback field (stored in audit[field.feedback])
        const feedbackData = audit[field.feedback];
        if (!feedbackData) return false;
        
        // Handle feedback - support both old format (string) and new format (JSON array)
        let feedbackArray = [];
        if (typeof feedbackData === 'string') {
            // Try to parse as JSON array, fallback to single string
            try {
                const parsed = JSON.parse(feedbackData);
                feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
            } catch (e) {
                // If not valid JSON, treat as single string (backward compatibility)
                feedbackArray = feedbackData.trim() ? [feedbackData] : [];
            }
        } else if (Array.isArray(feedbackData)) {
            feedbackArray = feedbackData;
        } else {
            feedbackArray = feedbackData ? [feedbackData] : [];
        }
        
        // Filter out empty feedbacks
        feedbackArray = feedbackArray.filter(f => f && f.trim());
        
        // Only show if there's at least one non-empty feedback
        return feedbackArray.length > 0;
    });
    
    // Calculate actual totals from filtered error counts (only visible error parameters)
    let criticalFailTotal = 0;
    let criticalTotal = 0;
    let significantTotal = 0;
    let majorTotal = 0;
    let minorTotal = 0;
    
    filteredErrorFields.forEach(field => {
        const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
        if (count > 0) {
            if (field.severity === 'Critical Fail') {
                criticalFailTotal += count;
            } else if (field.severity === 'Critical') {
                criticalTotal += count;
            } else if (field.severity === 'Significant') {
                significantTotal += count;
            } else if (field.severity === 'Major') {
                majorTotal += count;
            } else if (field.severity === 'Minor') {
                minorTotal += count;
            }
        }
    });
    
    // Determine column header based on field types
    let statusColumnHeader = 'Status';
    if (filteredErrorFields.length > 0) {
        const allCounters = filteredErrorFields.every(field => field.field_type === 'counter');
        const allRadio = filteredErrorFields.every(field => field.field_type === 'radio');
        
        if (allCounters) {
            statusColumnHeader = 'Counts';
        } else if (allRadio) {
            statusColumnHeader = 'Achieved?';
        }
    }
    
    // Check if any parameter has a comment (handle both single comment and comments array format)
    const hasAnyComments = filteredErrorFields.some(field => {
        const comment = parameterComments[field.key];
        if (!comment) return false;
        // Check for single comment format
        if (comment.comment && comment.comment.trim()) return true;
        // Check for comments array format
        if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
        return false;
    });
    
    // Get employee name and extract first name
    const employeeName = audit.employeeName || audit.employee_name || 'Employee';
    const firstName = employeeName.split(' ')[0] || employeeName;
    const commentColumnHeader = `${firstName}'s Comment`;
    
    // Show comments column if comments exist OR if audited employee (always show for audited employees)
    // Use a global variable to track if comment column should be shown
    if (typeof window.showCommentsColumn === 'undefined') {
        // For audited employees, always show the comment column by default
        window.showCommentsColumn = isAuditedEmployee || hasAnyComments;
    }
    const showCommentsColumn = window.showCommentsColumn;
    
    // Cache dark mode values once (outside the loop for performance)
    // Use try-catch to prevent errors from breaking error row rendering
    let isDarkMode = false;
    let dividerColor = '#f3f4f6';
    let dividerOpacity = '1';
    
    try {
        isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
        if (isDarkMode) {
            const root = document.documentElement;
            dividerColor = getComputedStyle(root).getPropertyValue('--border-light').trim() || '#f3f4f6';
            dividerOpacity = '0.5';
        }
    } catch (e) {
        console.warn('Error getting dark mode values for dividers, using defaults:', e);
    }
    
    const errorRows = filteredErrorFields.map(field => {
        const rawValue = audit[field.key];
        let displayValue = '';
        let count = 0;
        
        if (field.field_type === 'radio') {
            // For radio buttons, show YES/NO
            const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
            displayValue = isYes ? ' YES' : ' NO';
            count = isYes ? 1 : 0;
        } else {
            // For counters, show the number
            count = rawValue ? parseInt(rawValue) : 0;
            displayValue = count.toString();
        }
        
        // Handle feedback - support both old format (string) and new format (JSON array)
        const feedbackData = audit[field.feedback];
        let feedbackArray = [];
        
        if (feedbackData) {
            if (typeof feedbackData === 'string') {
                // Try to parse as JSON array, fallback to single string
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch (e) {
                    // If not valid JSON, treat as single string (backward compatibility)
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
        }
        
        // Filter out empty feedbacks
        feedbackArray = feedbackArray.filter(f => f && f.trim());
        const hasFeedback = feedbackArray.length > 0;
        const combinedFeedback = feedbackArray.join('\n\n---\n\n'); // Combine with separator
        
        // Different colors for different parameter types
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (field.parameter_type === 'error') {
            // All error severities use red shades - darker red for higher severity
            // Text color is white for all to ensure good contrast against red backgrounds
            if (field.severity === 'Critical Fail') {
                severityColor = '#ffffff'; // White text
                severityBg = '#7f1d1d'; // Darkest red background
            } else if (field.severity === 'Critical') {
                severityColor = '#ffffff'; // White text
                severityBg = '#991b1b'; // Dark red background
            } else if (field.severity === 'Significant') {
                severityColor = '#ffffff'; // White text
                severityBg = '#b91c1c'; // Medium-dark red background
            } else if (field.severity === 'Major') {
                severityColor = '#ffffff'; // White text
                severityBg = '#dc2626'; // Medium red background
            } else if (field.severity === 'Minor') {
                severityColor = '#ffffff'; // White text
                severityBg = '#ef4444'; // Light-medium red background
            } else {
                // Default for any other error severity
                severityColor = '#ffffff'; // White text
                severityBg = '#b91c1c'; // Medium-dark red background
            }
        } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Get existing comments for this parameter (can have multiple comments for multiple feedbacks)
        const existingComments = parameterComments[field.key] || {};
        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
        
        // Generate comment HTML - simple input boxes for each feedback
        let commentHtml = '';
        if (showCommentsColumn) {
            // For auditors (non-audited employees), always show comments as read-only text
            // For audited employees, show input boxes (or read-only if reversal submitted or audit acknowledged)
            if (hasFeedback) {
                // Create input boxes/display for each feedback
                commentHtml = feedbackArray.map((feedbackText, index) => {
                    const existingComment = commentsArray[index] || '';
                    const commentInputId = `comment_${field.key}_${index}`;
                    return `
                        <div style="margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">
                            ${feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                            ${!isAuditedEmployee || hasReversalSubmitted || isAcknowledged ? 
                                // For auditors, after reversal submitted, or after acknowledgment, show as read-only text
                                (existingComment ? 
                                    `<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(existingComment)}</div>` :
                                    '<span style="color: #000000; font-style: italic; font-size: 0.5659rem;">-</span>'
                                ) :
                                // For audited employees (before reversal and before acknowledgment), show input box
                                `<input type="text" id="${commentInputId}" data-param-key="${field.key}" data-feedback-index="${index}" value="${escapeHtml(existingComment)}" placeholder="Enter your comment..." style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif;" onchange="saveParameterComment('${field.key}', ${index}, this.value)" onblur="saveParameterComment('${field.key}', ${index}, this.value)">`
                            }
                </div>
            `;
                }).join('');
            } else {
                // No feedback for this parameter - check if there are comments anyway
                // (in case comments were added but feedback was removed, or for backward compatibility)
                if (commentsArray.length > 0 && commentsArray.some(c => c && c.trim())) {
                    // Show comments even without feedback
                    commentHtml = commentsArray.map((comment, index) => {
                        if (!comment || !comment.trim()) return '';
                        return `
                            <div style="margin-bottom: ${index < commentsArray.length - 1 ? '0.6469rem' : '0'};">
                                ${commentsArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                                <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(comment)}</div>
                            </div>
                        `;
                    }).filter(html => html).join('');
                } else {
                    // No comments and no feedback - show dash
                    commentHtml = '<span style="color: #000000; font-style: italic;">-</span>';
                }
            }
        }
        
        // Generate feedback HTML - display all feedbacks in light colored container boxes
        // URLs in feedback are converted to clickable links
        // If count is 0, use light yellow (improvement area), otherwise use light red
        let feedbackHtml = '-';
        if (hasFeedback) {
            // Determine container colors based on count
            const isImprovementArea = count === 0;
            const containerBg = isImprovementArea ? '#fefce8' : '#fef2f2'; // Light yellow if count is 0, light red otherwise
            const containerBorder = isImprovementArea ? '#fde047' : '#fecaca'; // Yellow border if count is 0, red border otherwise
            
            // Display each feedback in a light colored container box
            feedbackHtml = feedbackArray.map((feedbackText, index) => {
                const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.3234rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                
                // Check if feedback is HTML (contains tags) or plain text
                let renderedFeedback = '';
                if (feedbackText.trim().startsWith('<') && feedbackText.includes('>')) {
                    // It's HTML - sanitize and render, preserving color styles
                    if (typeof DOMPurify !== 'undefined') {
                        // Sanitize with style attribute allowed - DOMPurify should preserve color CSS properties
                        const sanitized = DOMPurify.sanitize(feedbackText, {
                            ALLOWED_TAGS: ['p', 'br', 'strong', 'b', 'em', 'i', 'u', 'ul', 'ol', 'li', 'a', 'span'],
                            ALLOWED_ATTR: ['href', 'target', 'rel', 'style'],
                            ALLOW_DATA_ATTR: false
                        });
                        renderedFeedback = sanitized;
                    } else {
                        // Fallback: escape HTML if DOMPurify not available
                        renderedFeedback = escapeHtml(feedbackText);
                    }
                } else {
                    // It's plain text - convert URLs to links and preserve line breaks
                    renderedFeedback = convertUrlsToLinks(feedbackText);
                }
                
                return `<div style="background: ${containerBg}; border: 0.0304rem solid ${containerBorder}; border-radius: 0.3234rem; padding: 0.4852rem 0.6469rem; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">
                    ${label}<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; line-height: 1.6; ${feedbackText.trim().startsWith('<') ? '' : 'white-space: pre-wrap;'}">${renderedFeedback}</div>
                </div>`;
            }).join('');
        }
        
        // Build grid columns - must match header columns for proper alignment
        // Feedback column gets maximum width since it contains the most text content
        // For audited employees, always show comment column (persistent)
        const gridColumns = showCommentsColumn 
            ? '1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr' 
            : '1.5fr 0.8fr 0.8fr 0.8fr 4fr';
        
        return `
            <div style="display: grid; grid-template-columns: ${gridColumns}; gap: 0.6469rem; align-items: start; padding: 0.3234rem 0; border-bottom: 0.0405rem solid ${dividerColor}; opacity: ${dividerOpacity}; width: 100%; min-width: 0;">
                <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                    ${field.label}
                </div>
                <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                    ${field.points}
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${(field.parameter_type === 'achievement' || field.parameter_type === 'bonus') && field.field_type !== 'radio' ? 'ACHIEVEMENT' : field.severity}</span>
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>
                </div>
                <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                    ${feedbackHtml}
                </div>
                ${showCommentsColumn ? `
                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                        ${commentHtml || '<span style="color: #000000; font-style: italic;">-</span>'}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    // Determine background color based on error count only (not feedback/comments)
    // Use light colors instead of eye-catchy bright colors
    const totalErrors = parseInt(audit.totalErrorsCount || '0');
    const hasErrors = totalErrors > 0;
    const bgColor = hasErrors ? '#fee2e2' : '#d1fae5'; // Light red if error count > 0, light green if count is 0
    const borderColor = hasErrors ? '#fecaca' : '#a7f3d0'; // Light red border or light green border
    const textColor = hasErrors ? '#991b1b' : '#065f46'; // Dark red text or dark green text for contrast
    
    return `
        <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant, Major, Minor -->
        <div style="background: ${bgColor}; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid ${borderColor};">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.totalErrorsCount || '0'}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalFailTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${significantTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Major</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${majorTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: ${textColor}; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Minor</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${minorTotal}</div>
                </div>
            </div>
        </div>

        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
            <div style="margin-bottom: 0.4852rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    Error Details
                </h3>
            </div>
            
            ${filteredErrorFields.length > 0 ? `
            <div style="background: var(--background-white); border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                    <div style="background-color: var(--background-white); padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid var(--border-light);">
                        <div style="display: grid; grid-template-columns: ${showCommentsColumn ? '1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr' : '1.5fr 0.8fr 0.8fr 0.8fr 4fr'}; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                            <div style="min-width: 0;">Error Type</div>
                            <div style="text-align: center; min-width: 0;">Points</div>
                            <div style="text-align: center; min-width: 0;">Severity</div>
                            <div style="text-align: center; min-width: 0;">${statusColumnHeader}</div>
                            <div style="min-width: 0;">Feedback</div>
                            ${showCommentsColumn ? 
                                `<div style="min-width: 0;">${escapeHtml(commentColumnHeader)}</div>` : 
                                ''
                            }
                        </div>
                    </div>
                    <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                        ${errorRows}
                    </div>
                </div>
            ` : `
            <div style="background: var(--background-white); border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; padding: 2rem; text-align: center;">
                <div style="display: flex; flex-direction: column; align-items: center; gap: 0.6469rem;">
                    <svg style="width: 3rem; height: 3rem;" viewBox="0 0 24 24" fill="#1A733E">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                    </svg>
                    <p style="font-size: 0.7278rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif;">No Errors Detected</p>
                    <p style="font-size: 0.5659rem; color: #6b7280; margin: 0; font-family: 'Poppins', sans-serif;">Great job! No errors were found in this audit.</p>
                </div>
            </div>
            `}
            </div>
            
        <!-- Avg Score & Passing Status -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                    <div style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.averageScore || '0'}%</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                    <div style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.passingStatus || 'N/A'}</div>
                </div>
            </div>
        </div>
    `;
}

// Render audit HTML
async function renderAudit(audit, auditScorecard, errorFields) {
    // Helper functions are now in audit-template.js
    // Use them from the global scope (formatDate, getCountryFlag, escapeHtml)

    // Check for passing status (handle both "Passing" and "Passed", but exclude "Not Passing")
    const passingStatus = audit.passingStatus ? audit.passingStatus.toLowerCase() : '';
    const isPassing = passingStatus && passingStatus.includes('pass') && !passingStatus.includes('not');

    const errorDetailsHtml = errorFields.length > 0 ? generateErrorDetails(audit, errorFields) : '';

    // Determine header gradient based on passing status (handle both old and new values)
    const normalizedPassingStatus = passingStatus && passingStatus.includes('not') ? 'Not Passed' : 'Passed';
    const headerGradient = normalizedPassingStatus === 'Not Passed' 
        ? 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)' 
        : 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    
    // Use formatDate and getCountryFlag from audit-template.js
    const formatDate = window.formatDate || function(dateString, includeTime) {
        if (!dateString) return 'N/A';
        const date = new Date(dateString);
        const day = date.getDate();
        const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const month = months[date.getMonth()];
        const year = date.getFullYear();
        if (includeTime) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            return `${day} ${month} ${year}, ${hours}:${minutes} ${ampm}`;
        }
        return `${day} ${month} ${year}`;
    };
    const getCountryFlag = window.getCountryFlag || function(countryName) {
        if (!countryName) return '';
        const country = countryName.toLowerCase();
        const flagMap = {
            'bangladesh': '', 'india': '', 'pakistan': '', 'philippines': '',
            'indonesia': '', 'sri lanka': '', 'nepal': '', 'thailand': '',
            'vietnam': '', 'malaysia': '', 'singapore': '', 'usa': '',
            'united states': '', 'uk': '', 'united kingdom': '', 'canada': '',
            'australia': '', 'new zealand': '', 'south africa': '', 'egypt': '',
            'kenya': '', 'nigeria': '', 'ghana': ''
        };
        return flagMap[country] || '';
    };
    const escapeHtml = window.escapeHtml || function(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    };

    // Build interaction ID HTML (clickable link if available)
    // Get Intercom app ID from config (generated from environment variables)
    const INTERCOM_APP_ID = window.intercomConfig?.appId || '';
    let interactionIdHtml;
    if (audit.interactionId) {
        const interactionId = audit.interactionId;
        const intercomUrl = `https://app.intercom.com/a/inbox/aphmhtyj/inbox/conversation/${interactionId}?view`;
        interactionIdHtml = '<a href="' + escapeHtml(intercomUrl) + '" target="_blank" rel="noopener noreferrer" style="font-size: 0.4852rem; color: #1A733E; font-family: \'Poppins\', sans-serif; font-weight: 600; text-decoration: underline; cursor: pointer; transition: color 0.2s ease;" onmouseover="this.style.color=\'#2d9a5a\'" onmouseout="this.style.color=\'#1A733E\'">' + escapeHtml(interactionId) + '</a>';
    } else {
        interactionIdHtml = '<span style="font-size: 0.4852rem; color: #1f2937; font-family: \'Poppins\', sans-serif; font-weight: 600;">N/A</span>';
    }

    // Generate recommendations HTML
    // Render as HTML if it contains HTML tags, otherwise render as plain text
    const recommendationsHtml = audit.recommendations 
        ? (() => {
            const recommendations = audit.recommendations;
            // Check if it's HTML (contains tags) or plain text
            const isHtml = recommendations.trim().startsWith('<');
            // Sanitize HTML for safe rendering
            const sanitizedHtml = isHtml 
                ? DOMPurify.sanitize(recommendations, {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'b', 'em', 'i', 'u', 'ul', 'ol', 'li', 'a'],
                    ALLOWED_ATTR: ['href', 'target', 'rel'],
                    ALLOW_DATA_ATTR: false
                })
                : recommendations.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
            
            return `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><div style="background: white; padding: 0.5659rem; border-radius: 0.2425rem; border: 0.0304rem solid #e5e7eb; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif;">${sanitizedHtml}</div></div>`;
        })()
        : '';

    // Set ratingHtml to empty string so it doesn't appear in the right column
    const ratingHtml = '';

    // Check if current user is the audited employee (for showing acknowledge button)
    const showAcknowledgeButton = isCurrentUserAuditedEmployee();
    
    // Check if edit button should be shown (only for Quality Analysts when reversal is pending)
    const showEditButton = shouldShowEditButton();
    
    // Check if reversal button should be shown (hide after REVERSAL_WINDOW_HOURS hours from audit submission if window is enabled)
    const auditSubmissionTime = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
    const timeWindowAllowsReversal = checkIfReversalButtonShouldShow(auditSubmissionTime);
    
    // Get reversal and acknowledgement status for footer styling
    // Check workflow state first, then fall back to old logic
    const workflowState = getReversalWorkflowState(audit);
    const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
    const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
    const reversalApproved = audit.reversal_approved || audit.reversalApproved;
    
    // Determine status: Check workflow state first, but only if reversal was actually submitted
    let reversalStatus = null;
    
    // Only set reversal status if a reversal was actually requested
    if (reversalRequestedAt) {
        if (workflowState === 'team_lead_rejected') {
            reversalStatus = 'Rejected'; // Team Lead rejected - show as rejected
        } else if (workflowState === 'approved' || workflowState === 'reversal_approved') {
            reversalStatus = 'Approved';
        } else if (workflowState === 'rejected' || workflowState === 'reversal_rejected') {
            reversalStatus = 'Rejected';
        } else if (workflowState === 'team_lead_review' || workflowState === 'qa_review' || workflowState === 'pending') {
            reversalStatus = 'Pending';
        } else {
            // Fallback to old logic
            if (!reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
        }
    }
    // If no reversalRequestedAt, reversalStatus remains null (no reversal submitted)
    
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';
    const isAcknowledged = acknowledgementStatus === 'Acknowledged' || 
                          acknowledgementStatus.toLowerCase() === 'acknowledged - after reversal approved' ||
                          acknowledgementStatus.toLowerCase() === 'acknowledged - after reversal rejected';
    
    // Check if there are errors or feedback from auditors
    const hasErrorsOrFeedbackFromAuditor = hasErrorsOrFeedback(audit, errorFields);
    
    // Reversal button should only show if:
    // 1. Time window allows it (if enabled)
    // 2. There are errors or feedback from auditors
    // 3. Audit is NOT acknowledged
    const showReversalButton = timeWindowAllowsReversal && hasErrorsOrFeedbackFromAuditor && !isAcknowledged;

    // Generate action buttons HTML
    // Only show acknowledge/reversal buttons if current user is the audited employee
    let employeeButtonsHtml = '';
    if (showAcknowledgeButton) {
        // Check if reversal is pending (disables acknowledge button and reversal button)
        const isReversalPending = reversalStatus === 'Pending';
        
        // Generate reversal button HTML (always show if window is disabled, or if within REVERSAL_WINDOW_HOURS hours when enabled, regardless of acknowledgement status)
        // But disable if reversal is already pending
        let reversalButtonHtml = '';
        if (showReversalButton) {
            const reversalDisabled = isReversalPending;
            reversalButtonHtml = `
                <button id="reversalBtn" onclick="toggleReversalForm()" ${reversalDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: ${acknowledgementStatus === 'Acknowledged' ? '0.2425rem' : '0 0.2425rem 0.2425rem 0'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${reversalDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${reversalDisabled ? '0.5' : '1'}; ${acknowledgementStatus !== 'Acknowledged' ? 'border-left: 0.0304rem solid rgba(255,255,255,0.3);' : ''}">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        Request Reversal
                    </button>
            `;
        }
        
        // If not acknowledged, show acknowledge button + reversal button
        if (acknowledgementStatus !== 'Acknowledged') {
            // Disable acknowledge button if reversal is pending
            const acknowledgeDisabled = isReversalPending;
            employeeButtonsHtml = `
                <!-- Split button for Acknowledge/Reversal -->
                <div style="position: relative; display: inline-flex;">
                    <button id="acknowledgeBtn" onclick="acknowledgeAudit()" ${acknowledgeDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: ${reversalButtonHtml ? '0.2425rem 0 0 0.2425rem' : '0.2425rem'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${acknowledgeDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${acknowledgeDisabled ? '0.5' : '1'};">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Acknowledge
                    </button>
                    ${reversalButtonHtml}
                </div>
            `;
        } else {
            // If acknowledged, don't show reversal button (reversal button should not appear if audit is acknowledged)
            // No buttons to show when acknowledged
            employeeButtonsHtml = '';
        }
    }
    
    // Generate edit button HTML (only if pending reversal and user is Quality Analyst)
    let editButtonHtml = '';
    if (showEditButton) {
        editButtonHtml = `
                <button id="editAuditBtn" onclick="editCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #f59e0b; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Edit Audit
                </button>
        `;
    }
    
    // Determine footer background color based on acknowledgement status
    // Green: Acknowledged | Gray: Default (not acknowledged)
    let footerBackgroundColor = '#f9fafb'; // Default gray
    let footerTextColor = '#000000'; // Default black text
    
    // Normalize acknowledgement status (case-insensitive)
    const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
    
    if (acknowledgementStatusLower === 'acknowledged') {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Generate interactive feedback rating HTML for footer
    // Always show stars (outlined if no rating, filled if rating exists)
    // Only show ratings to the audited employee
    let footerRatingHtml = '';
    const totalErrorsCount = audit.totalErrorsCount || audit.total_errors_count || 0;
    const existingRating = audit.audit_rating || 0;
    const hasRating = existingRating > 0;
    
    if (ENABLE_RATING_SYSTEM && isCurrentUserAuditedEmployee()) {
        // Use white text for green footer, dark text for gray footer
        const ratingTextColor = footerTextColor;
        const ratingIconColor = acknowledgementStatusLower === 'acknowledged' ? 'white' : '#1A733E';
        const starColor = hasRating 
            ? (existingRating >= 4 ? '#fbbf24' : existingRating >= 3 ? '#f59e0b' : '#ef4444')
            : (acknowledgementStatusLower === 'acknowledged' ? 'rgba(255,255,255,0.5)' : '#9ca3af');
        
        footerRatingHtml = `
            <div id="footerRatingContainer" style="display: flex; align-items: center; gap: 0.5rem; margin-right: 0.75rem;">
                <span style="font-size: 0.6875rem; font-weight: 500; color: ${ratingTextColor}; font-family: 'Poppins', sans-serif; white-space: nowrap;">How helpful was the feedback?</span>
                <div id="footerRatingStars" class="footer-star-rating" style="display: flex; align-items: center; gap: 0.25rem;" data-rating="${existingRating}" data-has-rating="${hasRating}">
                    ${Array.from({ length: 5 }, (_, i) => {
                        const starId = `footerStar${i + 1}`;
                        const isActive = i < existingRating;
                        const cursorStyle = hasRating ? 'cursor: default;' : 'cursor: pointer;';
                        return `<span id="${starId}" class="footer-star" data-rating="${i + 1}" style="color: ${isActive ? (existingRating >= 4 ? '#fbbf24' : existingRating >= 3 ? '#f59e0b' : '#ef4444') : '#d1d5db'}; transition: all 0.2s ease; user-select: none; ${cursorStyle}"></span>`;
                    }).join('')}
                </div>
                ${hasRating ? `<span style="font-size: 0.6875rem; font-weight: 600; color: ${ratingTextColor}; font-family: 'Poppins', sans-serif;">${existingRating}/5</span>` : ''}
            </div>
        `;
    }
    
    // Generate timer HTML for footer (if reversal button is visible and within REVERSAL_WINDOW_HOURS hours)
    // Don't show timer if reversal is already pending or if reversal window is disabled
    let timerHtml = '';
    if (ENABLE_REVERSAL_WINDOW && showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        if (timeRemaining && timeRemaining > 0) {
            // Check if time is running low (less than 2 hours remaining)
            const isLowTime = timeRemaining < 7200; // 2 hours in seconds
            // Use white for green footer, default gray text for gray footer
            const acknowledgementStatusLower = (acknowledgementStatus || '').toLowerCase();
            const timerTextColor = acknowledgementStatusLower === 'acknowledged' ? 'white' : footerTextColor;
            timerHtml = `
                <div id="reversalTimer" style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; color: ${timerTextColor}; ${isLowTime ? 'animation: pulse-attention 2s ease-in-out infinite;' : ''}">
                    <svg id="reversalTimerIcon" style="width: 0.75rem; height: 0.75rem; opacity: 0.6; ${isLowTime ? 'animation: spin-slow 2s linear infinite;' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span id="reversalTimerText">Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${isLowTime ? '#ef4444' : timerTextColor}; ${isLowTime ? 'animation: flash-text 1s ease-in-out infinite;' : ''}">${formatTimeRemaining(timeRemaining)}</span></span>
            </div>
            `;
        }
    }
    
    // Generate acknowledgement status HTML for footer (shown in body of footer)
    let acknowledgementStatusHtml = '';
    if (acknowledgementStatus === 'Acknowledged') {
        // Format acknowledgement timestamp
        let timestampText = '';
        const ackTimestamp = audit.acknowledgementStatusUpdatedAt || audit.acknowledgement_status_updated_at;
        if (ackTimestamp) {
            const ackDate = new Date(ackTimestamp);
            const now = new Date();
            const diffMs = now - ackDate;
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffHours < 1) {
                const diffMins = Math.floor(diffMs / (1000 * 60));
                timestampText = diffMins <= 1 ? 'just now' : `${diffMins} minutes ago`;
            } else if (diffHours < 24) {
                timestampText = diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
            } else if (diffDays === 1) {
                timestampText = '1 day ago';
            } else {
                timestampText = formatDate(ackTimestamp, true);
            }
        }
        
        acknowledgementStatusHtml = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background-color: rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                    <svg style="width: 0.875rem; height: 0.875rem;" viewBox="0 0 24 24" fill="white">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                </div>
                <span style="font-size: 0.75rem; font-weight: 600; color: white; font-family: 'Poppins', sans-serif;">Acknowledged</span>
                <span style="font-size: 0.6562rem; color: rgba(255, 255, 255, 0.9); font-family: 'Poppins', sans-serif;">${timestampText}</span>
            </div>
        `;
    }
    
    const actionButtonsHtml = `
        <div id="footerBar" class="no-print" style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid ${acknowledgementStatus === 'Acknowledged' ? 'rgba(255,255,255,0.2)' : '#e5e7eb'}; background-color: ${footerBackgroundColor}; color: ${footerTextColor};">
            <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1;">
                ${acknowledgementStatusHtml}
            </div>
            <div style="display: flex; align-items: center; justify-content: flex-end; flex: 1;">
                ${footerRatingHtml}
            </div>
            <div style="display: flex; align-items: center; gap: 0.4852rem; flex-shrink: 0;">
                ${timerHtml}
                ${employeeButtonsHtml}
                ${editButtonHtml}
            </div>
        </div>
    `;

    // Generate header actions HTML
    const headerActionsHtml = `
        <button onclick="handleCloseButtonClick()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)"></button>
    `;

    // Check if user is quality analyst or above (should see auditor name)
    const shouldShowAuditorName = isCurrentUserQualityAnalyst();
    
    // Use shared template to generate HTML
    const html = window.generateAuditFormHTML({
        audit: audit,
        mode: 'view',
        headerTitle: 'Audit Details',
        headerGradient: headerGradient,
        headerActions: headerActionsHtml,
        interactionIdHtml: interactionIdHtml,
        errorDetailsHtml: errorDetailsHtml,
        recommendationsHtml: recommendationsHtml,
        ratingHtml: ratingHtml,
        actionButtonsHtml: actionButtonsHtml,
        showAuditorName: shouldShowAuditorName
    });

    const auditContentDiv = document.getElementById('auditContent');

    // Preserve reversal form container state before re-rendering
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    const wasFormVisible = reversalFormContainer && reversalFormContainer.style.display !== 'none';
    
    // Temporarily remove form container from DOM to preserve it during innerHTML replacement
    let formContainerParent = null;
    let formContainerNextSibling = null;
    if (reversalFormContainer && reversalFormContainer.parentElement) {
        formContainerParent = reversalFormContainer.parentElement;
        formContainerNextSibling = reversalFormContainer.nextSibling;
        reversalFormContainer.remove();
    }
    
    auditContentDiv.innerHTML = html;

    // Show background score in header
    const backgroundScoreContainer = document.getElementById('headerBackgroundScore');
    const headerScoreValue = document.getElementById('headerScoreValue');
    if (backgroundScoreContainer && headerScoreValue && auditScorecard) {
        // Get average score from audit
        const averageScore = audit.averageScore || audit.average_score || 0;
        
        // Determine score text color based on passing status
        const passingStatusLower = passingStatus.toLowerCase();
        const isPassingForScore = passingStatusLower.includes('pass') && !passingStatusLower.includes('not');
        const scoreTextColor = isPassingForScore 
            ? 'rgba(10, 50, 30, 0.4)' // Darker green for passing
            : 'rgba(100, 10, 10, 0.4)'; // Darker red for not passing
        
        // Set the score value
        headerScoreValue.textContent = Math.round(averageScore);
        
        // Update background score color
        const scoreSpan = backgroundScoreContainer.querySelector('span');
        if (scoreSpan) {
            scoreSpan.style.color = scoreTextColor;
        }
        
        // Display the background score
        backgroundScoreContainer.style.display = 'flex';
    }

    // Re-insert reversal form container after rendering
    if (reversalFormContainer && auditContentDiv) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection && buttonsSection.parentElement) {
            buttonsSection.parentElement.insertBefore(reversalFormContainer, buttonsSection);
        } else {
            auditContentDiv.appendChild(reversalFormContainer);
        }
        
        // Restore visibility state
        if (wasFormVisible) {
            reversalFormContainer.style.display = 'block';
        } else {
            reversalFormContainer.style.display = 'none';
        }
    }

    // Handle reversal status UI updates
    handleReversalStatusUI(audit);
    
    // Display reversal approval interface if reversal is pending
    // The "Review & Process Reversal" section now contains all information
    // Show it to everyone (agents see read-only, team leads/auditors/admins see editable)
    // Note: workflowState is already declared above (line 2483)
    
    if (reversalStatus === 'Pending' || workflowState === 'team_lead_review' || workflowState === 'qa_review' || workflowState === 'approved' || workflowState === 'rejected' || workflowState === 'team_lead_rejected') {
        // Check if there's a reversal request first
        if (reversalRequestedAt) {
            // Load workflow state from reversal_requests table before displaying
            await loadReversalWorkflowState(audit);
            const updatedWorkflowState = getReversalWorkflowState(audit);
            
            // Show interface for everyone:
            // - Agents: read-only view of their submitted reversal
            // - Team leads/auditors/admins: editable interface for processing
            const isAgent = isCurrentUserAuditedEmployee();
            const isTeamLead = isCurrentUserTeamLead();
            const shouldShowReversal = shouldShowReversalApprovalInterface();
            // Show for team leads when workflow is in team lead review states (pending, team_lead_review, or team_lead_rejected)
            const isTeamLeadWorkflowState = updatedWorkflowState === 'team_lead_review' || updatedWorkflowState === 'pending' || updatedWorkflowState === 'team_lead_rejected';
            const shouldShow = isAgent || isTeamLeadWorkflowState || shouldShowReversal;
            
            if (shouldShow) {
                setTimeout(async () => {
                    // For agents, show read-only reversal form with journey map
                    if (isAgent) {
                        await displaySubmittedReversalForm(audit);
                    } else {
                        // For team leads/auditors/admins, show approval interface
                        await displayReversalApprovalInterface(audit);
                    }
                }, 200);
            }
        }
    }
    
    // Start timer countdown if reversal button is visible and reversal is not pending
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        startReversalTimer(auditSubmissionTime);
    }
    
    // Setup footer rating star hover effects (only if rating system is enabled)
    if (ENABLE_RATING_SYSTEM) {
        setupFooterRatingHover();
    }

    // Make splitter draggable
    initializeSplitter();
    
    // Auto-fetch conversation from Intercom if interaction ID exists
    // Chat view is always shown by default (will show loading, then Intercom messages or fallback to text)
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    
    if (transcriptChatView && transcriptTextView) {
        transcriptChatView.style.display = 'flex';
        transcriptTextView.style.display = 'none';
        isChatViewActive = true;
    }
    
    if (audit.interactionId || audit.interaction_id) {
        const interactionId = audit.interactionId || audit.interaction_id;
        // Show loading state immediately
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        if (chatMessagesContainer) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #000000;">
                    <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                </div>
            `;
        }
        // Delay slightly to ensure DOM is ready, then fetch
        setTimeout(() => {
            loadConversationFromIntercom(interactionId);
        }, 100);
    } else {
        // No interaction ID - try to parse database transcript and show in chat view
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - show empty state in chat view instead of falling back to text view
            const chatMessagesContainer = document.getElementById('chatMessagesContainer');
            if (chatMessagesContainer) {
                chatMessagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 1.2937rem; color: var(--text-muted); font-size: 0.5659rem;">
                        <p>No transcript available</p>
                    </div>
                `;
            }
            // Ensure chat view is active and text view is hidden
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
        }
        
        // Double-check that chat view is visible and text view is hidden (in case template defaults are wrong)
        setTimeout(() => {
            const transcriptChatView = document.getElementById('transcriptChatView');
            const transcriptTextView = document.getElementById('transcriptTextView');
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
            }
        }, 50);
    }
}

// Handle reversal status UI updates
function handleReversalStatusUI(audit) {
    if (!audit) {
        console.warn('handleReversalStatusUI called with null/undefined audit');
        return;
    }
    
    const acknowledgeBtn = document.getElementById('acknowledgeBtn');
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    
    // Check if acknowledge button should be visible (only for audited employee)
    if (acknowledgeBtn && !isCurrentUserAuditedEmployee()) {
        // Hide acknowledge button if user is not the audited employee
        acknowledgeBtn.style.display = 'none';
        // Also hide the reversal button if both buttons are in a split button container
        const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
        if (reversalBtn) {
            reversalBtn.style.display = 'none';
        }
    }
    
    // Get the reversal status from audit data
    // Check workflow state first, then fall back to old logic
    const workflowState = getReversalWorkflowState(currentAudit);
    const reversalRequestedAt = currentAudit?.reversal_requested_at || currentAudit?.reversalRequestedAt;
    const reversalRespondedAt = currentAudit?.reversal_responded_at || currentAudit?.reversalRespondedAt;
    const reversalApproved = currentAudit?.reversal_approved || currentAudit?.reversalApproved;
    const teamLeadApproved = currentAudit?.teamLeadApproved !== undefined ? currentAudit.teamLeadApproved : currentAudit?.team_lead_approved;
    const teamLeadRejectionReason = currentAudit?.teamLeadRejectionReason || currentAudit?.team_lead_rejection_reason || '';
    
    let reversalStatus = null;
    
    // Only set reversal status if a reversal was actually requested
    if (!reversalRequestedAt) {
        // No reversal requested, so no reversal status to show
        reversalStatus = null;
    } else if (workflowState === null || workflowState === undefined) {
        // No workflow state (shouldn't happen if reversalRequestedAt exists, but be safe)
        reversalStatus = null;
    } else {
        // Check workflow state first
        if (workflowState === 'team_lead_rejected') {
            reversalStatus = 'Rejected'; // Team Lead rejected - show as rejected
        } else if (workflowState === 'approved' || workflowState === 'reversal_approved') {
            reversalStatus = 'Approved';
        } else if (workflowState === 'rejected' || workflowState === 'reversal_rejected') {
            reversalStatus = 'Rejected';
        } else if (workflowState === 'team_lead_review' || workflowState === 'qa_review' || workflowState === 'pending') {
            reversalStatus = 'Pending';
        } else {
            // Fallback to old logic
            if (!reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
            }
        }
    }
    
    // Get the acknowledgement status from audit data
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status;
    
    // Ensure button is enabled by default (will be disabled if needed below)
    if (acknowledgeBtn) {
        acknowledgeBtn.disabled = false;
        acknowledgeBtn.style.opacity = '1';
        acknowledgeBtn.style.cursor = 'pointer';
    }
    
    // If audit is already acknowledged, disable the acknowledge button
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    // If reversal is pending (and not rejected by Team Lead), disable acknowledge button
    if (reversalStatus === 'Pending' && workflowState !== 'team_lead_rejected' && acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    // If Team Lead rejected, allow acknowledgment (it's final)
    if (workflowState === 'team_lead_rejected' && acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
        acknowledgeBtn.disabled = false;
        acknowledgeBtn.style.opacity = '1';
        acknowledgeBtn.style.cursor = 'pointer';
    }
    
    if (reversalStatus) {
        // Create status banner
        const statusBanner = document.createElement('div');
        statusBanner.style.cssText = `
            padding: 0.5625rem 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.2812rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.6562rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        `;
        
        if (reversalStatus === 'Pending') {
            // Don't show banner for pending reversals - the "Review & Process Reversal" section has more specific information
            // Just disable the reversal button (user can't submit another reversal while one is pending)
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = true;
                reversalBtn.style.opacity = '0.5';
                reversalBtn.style.cursor = 'not-allowed';
            }
            // Don't create/show the status banner for pending status - return early
            return;
        } else if (reversalStatus === 'Approved') {
            statusBanner.style.background = '#d1fae5';
            statusBanner.style.color = '#065f46';
            statusBanner.style.border = '0.0352rem solid #10b981';
            
            // Get auditor's response if available
            const auditorResponse = currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '';
            const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee() || isCurrentUserAuditor()) && auditorResponse && auditorResponse.trim();
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <div style="flex: 1;">
                    <div> Reversal request has been approved. Score updated to ${currentAudit?.score_after_appeal || 'N/A'}%. Please review the updated audit and acknowledge or submit a new reversal if needed.</div>
                    ${shouldShowResponse ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #10b981;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">Response From QC:</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(auditorResponse)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            // After reversal is processed, enable both buttons again (new review cycle)
            // Don't hide buttons - allow user to acknowledge or submit new reversal
            if (acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Rejected') {
            statusBanner.style.background = '#fee2e2';
            statusBanner.style.color = '#991b1b';
            statusBanner.style.border = '0.0352rem solid #ef4444';
            
            // Check if rejected by Team Lead or QA
            // IMPORTANT: Only show team lead rejection if workflow state is actually 'team_lead_rejected'
            // NOT 'team_lead_review' (which means pending review, not rejected)
            const isTeamLeadRejection = workflowState === 'team_lead_rejected';
            // Only get team lead reviewed by if it's actually a rejection (not pending review)
            const teamLeadReviewedBy = isTeamLeadRejection ? (currentAudit?.teamLeadReviewedBy || currentAudit?.team_lead_reviewed_by) : null;
            const rejectionMessage = isTeamLeadRejection 
                ? `Reversal request has been rejected by your Team Lead${teamLeadReviewedBy ? ` (<span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>)` : ''}. Please review the audit and acknowledge or submit a new reversal if needed.`
                : 'Reversal request has been rejected. Please review the audit and acknowledge or submit a new reversal if needed.';
            
            // Get rejection reason (Team Lead rejection reason or auditor response)
            const rejectionReason = isTeamLeadRejection 
                ? (teamLeadRejectionReason || '')
                : (currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '');
            
            const shouldShowRejectionReason = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee() || isCurrentUserAuditor()) && rejectionReason && rejectionReason.trim();
            const rejectionLabel = isTeamLeadRejection ? 'Rejection Reason from Team Lead:' : 'Response From QC:';
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <div style="flex: 1;">
                    <div>${rejectionMessage}</div>
                    ${shouldShowRejectionReason ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #ef4444;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">${rejectionLabel}</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(rejectionReason)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Re-setup hover listeners after updating innerHTML
            setupUserProfileHovers();
            
            // After reversal is processed, enable both buttons again (new review cycle)
            // Don't hide buttons - allow user to acknowledge or submit new reversal
            if (acknowledgeBtn && acknowledgementStatus !== 'Acknowledged') {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Acknowledged') {
            statusBanner.style.background = '#dbeafe';
            statusBanner.style.color = '#1e40af';
            statusBanner.style.border = '0.0352rem solid #3b82f6';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <span>Audit has been acknowledged by the employee.</span>
            `;
            // Hide the button container (parent div with border-top style)
            const buttonsContainer = acknowledgeBtn?.closest('.no-print[style*="border-top"]');
            if (buttonsContainer) {
                buttonsContainer.style.display = 'none';
            }
        }
        
        // Insert reversal status banner into the DOM
        // NOTE: This banner is redundant - the information is already shown in the "Review & Process Reversal" section at the top
        // Skip creating/inserting the banner to avoid duplication
        // if (statusBanner) {
        // const auditContentDiv = document.getElementById('auditContent');
        // if (auditContentDiv) {
        //     const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        //     if (buttonsSection && buttonsSection.parentElement) {
        //         buttonsSection.parentElement.insertBefore(statusBanner, buttonsSection);
        //     } else {
        //         auditContentDiv.appendChild(statusBanner);
        //     }
        // }
    }
    
    // Handle acknowledgement status separately
    // Note: Acknowledgement status is now shown in the footer, not as a separate banner
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
}

// Check if current user is team supervisor (for reversal review)
async function isCurrentUserTeamSupervisor() {
    if (!currentAudit || !currentUserEmail) {
        return false;
    }
    
    try {
        // Get employee email from audit
        const employeeEmail = (currentAudit.employeeEmail || currentAudit.employee_email || '').toLowerCase().trim();
        if (!employeeEmail) {
            return false;
        }
        
        // Get employee's team supervisor from users table
        const { data: employeeData, error } = await window.supabaseClient
            .from('users')
            .select('team_supervisor')
            .eq('email', employeeEmail)
            .maybeSingle();
        
        if (error || !employeeData || !employeeData.team_supervisor) {
            return false;
        }
        
        // Check if current user's email matches the team supervisor
        const teamSupervisorEmail = (employeeData.team_supervisor || '').toLowerCase().trim();
        const currentEmail = currentUserEmail.toLowerCase().trim();
        
        return teamSupervisorEmail === currentEmail;
    } catch (error) {
        console.error('Error checking team supervisor:', error);
        return false;
    }
}

async function isCurrentUserAuthorizedForQAReview() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo || !userInfo.email) {
        return false;
    }
    
    // Check role first (must be Super Admin)
    const role = (userInfo.role || '').toLowerCase();
    if (role !== 'super admin') {
        return false;
    }
    
    // Fetch team from database (team might not be in localStorage)
    try {
        const { data: userData, error } = await window.supabaseClient
            .from('users')
            .select('team')
            .eq('email', userInfo.email)
            .maybeSingle();
        
        if (error || !userData) {
            console.warn('Error fetching user team for QA review check:', error);
            return false;
        }
        
        // Check if team is "QC" (case-insensitive)
        const team = (userData.team || '').trim();
        return team.toLowerCase() === 'qc';
    } catch (error) {
        console.error('Error checking QA review authorization:', error);
        return false;
    }
}

// Capture original audit state for change tracking
let originalAuditState = null;

async function captureOriginalAuditState() {
    if (!currentAudit || !shouldShowReversalApprovalInterface()) {
        return;
    }
    
    // PRIORITY 1: Try to retrieve from reversal_requests table (new structure)
    let reversalRequestState = null;
    try {
        const { data: reversalRequest, error: rrError } = await window.supabaseClient
            .from('reversal_requests')
            .select('original_parameters, original_feedback, original_score, original_passing_status')
            .eq('audit_id', currentAudit.id)
            .eq('scorecard_table_name', currentTableName)
            .order('requested_at', { ascending: false })
            .limit(1)
            .maybeSingle();
        
        if (!rrError && reversalRequest && reversalRequest.original_parameters) {
            // Check if original_parameters has actual parameter values (not parameter_comments structure)
            const firstKey = Object.keys(reversalRequest.original_parameters)[0];
            const firstValue = reversalRequest.original_parameters[firstKey];
            const isParameterValues = typeof firstValue === 'number' || 
                                     (typeof firstValue === 'object' && firstValue !== null && !firstValue.comments);
            
            if (isParameterValues) {
                reversalRequestState = {
                    parameters: reversalRequest.original_parameters || {},
                    feedback: reversalRequest.original_feedback || {},
                    score: reversalRequest.original_score || 0,
                    passingStatus: reversalRequest.original_passing_status || ''
                };
                console.log(' Retrieved original state from reversal_requests table:', reversalRequestState);
            }
        } else if (rrError) {
            console.warn(' Could not retrieve from reversal_requests:', rrError);
        }
    } catch (rrErr) {
        console.warn(' Error retrieving from reversal_requests:', rrErr);
    }
    
    // PRIORITY 2: Fallback to activity log (when reversal was requested)
    let loggedOriginalState = null;
    if (!reversalRequestState) {
        try {
            const { data: reversalRequestLog, error: logFetchError } = await window.supabaseClient
                .from('audit_activity_log')
                .select('*')
                .eq('audit_id', currentAudit.id)
                .eq('activity_type', 'reversal_requested')
                .order('activity_timestamp', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!logFetchError && reversalRequestLog) {
                loggedOriginalState = {
                    parameters: reversalRequestLog.parameters_snapshot || {},
                    feedback: reversalRequestLog.feedback_snapshot || {},
                    score: reversalRequestLog.score_snapshot || 0,
                    passingStatus: reversalRequestLog.passing_status_snapshot || ''
                };
                console.log(' Retrieved original state from activity log for change tracking:', loggedOriginalState);
            } else if (logFetchError) {
                console.warn(' Could not retrieve original state from activity log:', logFetchError);
            }
        } catch (logErr) {
            console.warn(' Error retrieving original state from activity log:', logErr);
        }
    }
    
    // Use the best available source
    if (reversalRequestState) {
        originalAuditState = reversalRequestState;
    } else if (loggedOriginalState) {
        originalAuditState = loggedOriginalState;
    } else {
        // Fallback: Use current audit state (for backwards compatibility)
        // Note: This may not be accurate if audit has been modified since reversal request
        console.warn(' Using current audit state as baseline (no snapshot found). This may show incorrect changes if audit was modified.');
        originalAuditState = {
            parameters: {},
            feedback: {},
            score: currentAudit.averageScore || currentAudit.average_score || 0,
            passingStatus: currentAudit.passingStatus || currentAudit.passing_status || ''
        };
        
        // Capture all parameter values from current audit
        currentErrorFields.forEach(field => {
            const value = currentAudit[field.key] || 0;
            originalAuditState.parameters[field.key] = value;
            
            // Capture feedback
            const feedbackKey = `feedback_${field.key}`;
            const feedbackValue = currentAudit[feedbackKey] || null;
            originalAuditState.feedback[field.key] = feedbackValue;
        });
    }
}

// Calculate new score based on current parameter values
// Uses the same logic as create-audit.html to support deductive, additive, and hybrid scoring
function calculateNewScore() {
    if (!currentErrorFields || currentErrorFields.length === 0 || !currentAuditScorecard) {
        return currentAudit?.averageScore || currentAudit?.average_score || 0;
    }
    
    const scorecard = currentAuditScorecard;
    const scoringType = scorecard.scoring_type || 'deductive';
    
    let score = 0;
    
    switch(scoringType) {
        case 'deductive':
            score = calculateDeductiveScoreForEdit();
            break;
        case 'additive':
            score = calculateAdditiveScoreForEdit();
            break;
        case 'hybrid':
            score = calculateHybridScoreForEdit();
            break;
        default:
            score = calculateDeductiveScoreForEdit();
    }
    
    return Math.round(score * 100) / 100; // Round to 2 decimal places
}

// Deductive scoring: Start at 100, subtract for errors
function calculateDeductiveScoreForEdit() {
    let totalDeduction = 0;
    
    currentErrorFields.forEach(field => {
        // Default to 'error' if parameter_type is null/undefined/empty
        // Skip only if it's explicitly an achievement or bonus type
        const paramType = field.parameter_type || 'error';
        if (paramType === 'achievement' || paramType === 'bonus') {
            return;
        }
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const penalty = parseFloat(field.points) || 0;
        totalDeduction += value * penalty;
    });
    
    return Math.max(0, 100 - totalDeduction);
}

// Additive scoring: Start at 0, add for achievements
function calculateAdditiveScoreForEdit() {
    let totalPoints = 0;
    
    currentErrorFields.forEach(field => {
        if (field.parameter_type !== 'achievement' && field.parameter_type !== 'bonus') return;
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        totalPoints += value * points;
    });
    
    return Math.min(100, totalPoints);
}

// Hybrid scoring: Deduct for errors, add for achievements
function calculateHybridScoreForEdit() {
    let baseScore = 100;
    let bonusPoints = 0;
    
    currentErrorFields.forEach(field => {
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        
        // Default to 'error' if parameter_type is null/undefined/empty
        const paramType = field.parameter_type || 'error';
        
        if (paramType === 'error') {
            // Subtract from base score
            baseScore -= value * points;
        } else if (paramType === 'achievement' || paramType === 'bonus') {
            // Add to bonus
            bonusPoints += value * points;
        }
        // If parameter doesn't match any condition, it's skipped (no deduction or bonus)
    });
    
    // Apply max bonus cap if set
    const maxBonus = parseFloat(currentAuditScorecard.max_bonus_points) || 0;
    if (maxBonus > 0) {
        bonusPoints = Math.min(bonusPoints, maxBonus);
    }
    
    // Calculate final score
    let finalScore = baseScore + bonusPoints;
    
    // Apply over 100% cap if not allowed
    const allowOver100 = currentAuditScorecard.allow_over_100 || false;
    if (!allowOver100) {
        finalScore = Math.min(100, finalScore);
    }
    
    // Ensure minimum of 0
    finalScore = Math.max(0, finalScore);
    
    return finalScore;
}

// Update calculated score display
function updateCalculatedScore() {
    const newScore = calculateNewScore();
    const scoreDisplay = document.getElementById('calculatedNewScore');
    const passingStatusDisplay = document.getElementById('calculatedPassingStatus');
    
    if (scoreDisplay) {
        scoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    if (passingStatusDisplay) {
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        passingStatusDisplay.textContent = isPassing ? 'Passing' : 'Not Passing';
        passingStatusDisplay.className = isPassing 
            ? 'text-green-600 font-semibold' 
            : 'text-red-600 font-semibold';
    }
}

// Check if parameters have been changed from original state
function hasParameterChanges() {
    if (!originalAuditState || !currentErrorFields) {
        return false;
    }
    
    for (const field of currentErrorFields) {
        const fieldKey = field.key;
        let currentValue = 0;
        
        // Get current value from form
        if (field.field_type === 'radio') {
            const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
            if (radioInput) {
                currentValue = parseInt(radioInput.value) || 0;
            }
        } else {
            const numberInput = document.getElementById(fieldKey);
            if (numberInput) {
                currentValue = parseInt(numberInput.value) || 0;
            }
        }
        
        const originalValue = originalAuditState.parameters[fieldKey] || 0;
        
        if (currentValue !== originalValue) {
            return true;
        }
        
        // Also check feedback changes
        const feedbackKey = `feedback_${fieldKey}`;
        const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
        const currentFeedbacks = Array.from(feedbackTextareas)
            .map(ta => ta.value.trim())
            .filter(v => v);
        
        const originalFeedback = originalAuditState.feedback[fieldKey];
        let originalFeedbacks = [];
        if (originalFeedback) {
            if (Array.isArray(originalFeedback)) {
                originalFeedbacks = originalFeedback.filter(f => f && f.trim());
            } else if (typeof originalFeedback === 'string') {
                try {
                    const parsed = JSON.parse(originalFeedback);
                    originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                } catch {
                    originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                }
            }
        }
        
        if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
            return true;
        }
    }
    
    return false;
}

async function displayReversalApprovalInterface(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) {
        return;
    }
    
    // Get current user info
    const userInfo = getCurrentUserInfo();
    const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
    const currentUserEmailFromInfo = userInfo?.email || getCurrentUserEmail() || '';
    
    // Check workflow state and user role
    const workflowState = getReversalWorkflowState(currentAudit);
    const isTeamLead = isCurrentUserTeamLead();
    const isCQC = isCurrentUserCQC();
    const isAuditor = isCurrentUserAuditor();
    
    // Check if user is team supervisor (async)
    const isTeamSupervisor = await isCurrentUserTeamSupervisor();
    const isAgent = isCurrentUserAuditedEmployee();
    const isTeamLeadReview = (workflowState === 'team_lead_review' || workflowState === 'pending' || workflowState === 'team_lead_rejected') && (isTeamLead || isTeamSupervisor) && !isAgent;
    
    // Check if user is original auditor or admin
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    
    // Check if auditor is waiting for team lead review (all auditors except admins should be disabled during team_lead_review)
    // Original auditors can also review, but only after team lead approval (qa_review stage)
    const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                        (isAuditor || isOriginalAuditor) && 
                                        !isAdmin && 
                                        !isTeamLead && 
                                        !isTeamSupervisor;
    
    // If this is a team lead review stage, show interface for:
    // 1. Team supervisors/leads (can review)
    // 2. Original auditor (can review, but will see disabled view)
    // 3. Admins (can review)
    // 4. Other auditors (will see disabled view with explanation)
    // Also show for team_lead_rejected state so team leads can see what happened
    if ((workflowState === 'team_lead_review' || workflowState === 'pending' || workflowState === 'team_lead_rejected')) {
        if (!isTeamSupervisor && !isTeamLead && !isOriginalAuditor && !isAdmin && !isAuditor) {
            console.log('User is not authorized to review this reversal. Hiding review interface.', {
                workflowState,
                isTeamSupervisor,
                isTeamLead,
                isOriginalAuditor,
                isAdmin,
                isAuditor
            });
            return;
        } else {
            console.log('Team lead review interface will be shown.', {
                workflowState,
                isTeamSupervisor,
                isTeamLead,
                isOriginalAuditor,
                isAdmin,
                isAuditor,
                isAuditorWaitingForTeamLead,
                isTeamLeadReview
            });
        }
    }
    
    // Check if user is authorized for QA review (team "QC" AND role "Super Admin")
    const isAuthorizedForQA = await isCurrentUserAuthorizedForQAReview();
    
    // For qa_review stage, show interface to everyone (read-only for unauthorized users, editable for authorized)
    // No need to return early - we'll show read-only view for unauthorized users
    
    // Debug logging
    console.log('Display reversal approval interface:', {
        workflowState,
        isTeamLead,
        isTeamSupervisor,
        isTeamLeadReview,
        isAuditor,
        isCQC
    });
    
    // Get scorecard for passing threshold
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = scorecard.passing_threshold || 85;
    
        // Store passing threshold for use in team lead interface
        window.currentPassingThreshold = passingThreshold;
    
    // Calculate initial score (only for auditors/CQC, not team leads)
    const newScore = isTeamLeadReview ? (currentAudit?.averageScore || currentAudit?.average_score || 0) : calculateNewScore();
    const isPassing = newScore >= passingThreshold;
    
    // Calculate SLA hours
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    let slaHours = 0;
    if (reversalRequestedAt) {
        const requestedAt = new Date(reversalRequestedAt);
        const now = new Date();
        slaHours = ((now - requestedAt) / (1000 * 60 * 60));
    }
    
    // Get reversal justification from agent and parse it
    const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || 'No justification provided.';
    
    // Parse reversal justification to extract reason and details
    // Format is typically: "Reason: Parameter1: comment1\n\nParameter2: comment2"
    let reversalReason = '';
    let detailedJustification = reversalJustification;
    if (reversalJustification && reversalJustification.includes(':')) {
        const parts = reversalJustification.split(':');
        if (parts.length >= 2) {
            reversalReason = parts[0].trim();
            detailedJustification = parts.slice(1).join(':').trim();
        }
    }
    
    // Rejection reason options for team leads
    const rejectionReasons = [
        'Insufficient justification',
        'Request does not meet criteria',
        'Incorrect information provided',
        'Missing required documentation',
        'Other (specify in comments)'
    ];
    
    // Build interface HTML based on user role
    let decisionSectionHtml = '';
    let titleText = 'Review & Process Reversal';
    let titleIcon = `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`;
    
    if (isTeamLeadReview) {
        // Team Lead/Supervisor Review Interface
        titleText = 'Team Lead Review - Reversal Request';
        titleIcon = `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`;
        
        // Calculate error counts
        let totalErrorsCount = 0;
        let criticalFailCount = 0;
        let criticalCount = 0;
        let significantCount = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    totalErrorsCount += count;
                }
                if (count > 0) {
                    if (field.severity === 'Critical Fail') {
                        criticalFailCount += count;
                    } else if (field.severity === 'Critical') {
                        criticalCount += count;
                    } else if (field.severity === 'Significant') {
                        significantCount += count;
                    }
                }
            });
        }
        
        // Get audit information
        const currentScore = audit.averageScore || audit.average_score || 0;
        const passingStatus = audit.passingStatus || audit.passing_status || '';
        const employeeName = audit.employeeName || audit.employee_name || 'N/A';
        const auditorName = audit.auditorName || audit.auditor_name || 'N/A';
        const auditDate = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
        const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
        const scoreBeforeAppeal = audit.scoreBeforeAppeal || audit.score_before_appeal || currentScore;
        
        // Format audit date
        let formattedDate = 'N/A';
        if (auditDate) {
            try {
                const date = new Date(auditDate);
                formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedDate = auditDate;
            }
        }
        
        // Get parameter comments for team leader to review/edit
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        // Get team lead review data (for displaying rejection status if already rejected)
        const teamLeadApproved = audit.team_lead_approved === true || audit.team_lead_approved === 'true' || 
                                 audit.team_lead_approved === 1 || audit.team_lead_approved === '1';
        const teamLeadReviewedBy = audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '';
        const teamLeadReviewedAt = audit.team_lead_reviewed_at || audit.teamLeadReviewedAt;
        const teamLeadResponse = audit.response_from_team_lead || audit.responseFromTeamLead || '';
        const teamLeadRejectionReason = audit.team_lead_rejection_reason || audit.teamLeadRejectionReason || '';
        
        // Format team lead review date
        let formattedReviewDate = '';
        if (teamLeadReviewedAt) {
            try {
                const date = new Date(teamLeadReviewedAt);
                formattedReviewDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedReviewDate = teamLeadReviewedAt;
            }
        }
        
        decisionSectionHtml = `
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            ${!teamLeadApproved && teamLeadReviewedBy && (teamLeadRejectionReason || teamLeadResponse) ? `
            <!-- Team Lead Rejection Status (shown when team lead has already rejected) -->
            <div style="background: #fef2f2; border: 0.0625rem solid #fecaca; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #dc2626; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #dc2626;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    Rejected by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadRejectionReason && teamLeadRejectionReason.trim() ? `
                <p style="font-size: 0.6562rem; font-weight: 600; color: #991b1b; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Rejection Reason:</p>
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadRejectionReason)}</p>
                ` : ''}
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; font-weight: 600; color: #991b1b; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Response From Team Lead:</p>
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
            </div>
            ` : ''}
            
            ${teamLeadApproved && teamLeadReviewedBy ? `
            <!-- Team Lead Approval Status (shown when team lead has already approved) -->
            <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #16a34a; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #16a34a;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Approved by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #166534; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #166534; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bbf7d0; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
            </div>
            ` : ''}
            
            <!-- Decision Section for Team Lead -->
            <div style="border-top: 0.0625rem solid #e5e7eb; padding-top: 0.75rem;">
                <!-- Response from Team Lead -->
                <div style="margin-bottom: 0.75rem;">
                    <div>
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Response From Team Lead <span style="color: #ef4444;">*</span>
                        </label>
                        <textarea id="teamLeadResponse" required rows="3" placeholder="Please provide your response or comments..." style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box; background: white; cursor: text;"></textarea>
                    </div>
                </div>
                
                <!-- Action Buttons (shown first) -->
                <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; margin-bottom: 0.75rem;">
                    <button onclick="teamLeadRejectReversal()" id="teamLeadRejectBtn" style="padding: 0.375rem 0.75rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Reject Reversal Request
                    </button>
                    <button onclick="teamLeadApproveReversal()" id="teamLeadApproveBtn" style="padding: 0.375rem 0.75rem; background: #16a34a; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Approve Reversal Request
                    </button>
                </div>
                
                <!-- Rejection Reason Section (hidden by default, shown when reject is clicked) -->
                <div id="teamLeadRejectionSection" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 0.0625rem solid #e5e7eb;">
                    <div style="margin-bottom: 0.5625rem;">
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Rejection Reason <span style="color: #ef4444;">*</span>
                        </label>
                        <select id="teamLeadRejectionReason" required style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; background: white;">
                            <option value="">Select reason...</option>
                            ${rejectionReasons.map(reason => `<option value="${escapeHtml(reason)}">${escapeHtml(reason)}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: 0.5625rem; justify-content: flex-end;">
                        <button onclick="teamLeadCancelRejection()" style="padding: 0.375rem 0.75rem; background: #f3f4f6; color: #374151; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                            Cancel
                        </button>
                        <button onclick="teamLeadConfirmRejectReversal()" style="padding: 0.375rem 0.75rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                            Confirm Rejection
                        </button>
                    </div>
                </div>
            </div>
        `;
    } else if (isAgent || (workflowState === 'qa_review' || workflowState === 'cqc_review') && !isAuthorizedForQA) {
        // Agent Read-Only View OR Unauthorized User Read-Only View at QA Review Stage
        // Show same information as team leads/auditors but read-only
        // Calculate error counts (same as team lead view)
        let totalErrorsCount = 0;
        let criticalFailCount = 0;
        let criticalCount = 0;
        let significantCount = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    totalErrorsCount += count;
                }
                if (count > 0) {
                    if (field.severity === 'Critical Fail') {
                        criticalFailCount += count;
                    } else if (field.severity === 'Critical') {
                        criticalCount += count;
                    } else if (field.severity === 'Significant') {
                        significantCount += count;
                    }
                }
            });
        }
        
        // Get audit information (same as team lead view)
        const currentScore = audit.averageScore || audit.average_score || 0;
        const passingStatus = audit.passingStatus || audit.passing_status || '';
        const employeeName = audit.employeeName || audit.employee_name || 'N/A';
        const auditorName = audit.auditorName || audit.auditor_name || 'N/A';
        const auditDate = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
        const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
        const scoreBeforeAppeal = audit.scoreBeforeAppeal || audit.score_before_appeal || currentScore;
        
        // Format audit date
        let formattedDate = 'N/A';
        if (auditDate) {
            try {
                const date = new Date(auditDate);
                formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedDate = auditDate;
            }
        }
        
        // Get parameter comments for agent to view
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Get reversal reason (same parsing as team lead view)
        const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
        let reversalReason = '';
        if (reversalJustification && reversalJustification.includes(':')) {
            const parts = reversalJustification.split(':');
            if (parts.length >= 2) {
                reversalReason = parts[0].trim();
            }
        }
        
        // Check if Team Lead has approved
        const teamLeadApproved = audit.team_lead_approved;
        const teamLeadReviewedBy = audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '';
        const teamLeadReviewedAt = audit.team_lead_reviewed_at || audit.teamLeadReviewedAt;
        const teamLeadResponse = audit.response_from_team_lead || audit.responseFromTeamLead || '';
        const teamLeadRejectionReason = audit.team_lead_rejection_reason || '';
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        // Format team lead review date
        let formattedReviewDate = '';
        if (teamLeadReviewedAt) {
            try {
                const date = new Date(teamLeadReviewedAt);
                formattedReviewDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedReviewDate = teamLeadReviewedAt;
            }
        }
        
        // Get auditor response if available
        const auditorResponse = audit.response_from_auditor || audit.reasonForReversalResponseDelay || '';
        const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
        
        decisionSectionHtml = `
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            <!-- Reversal Request Details -->
            <div style="background: #f9fafb; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5625rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif;">
                    ${reversalRequestedAt ? (() => {
                        const date = new Date(reversalRequestedAt);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);
                        
                        let requestedDateText = '';
                        if (diffMins < 1) {
                            requestedDateText = 'just now';
                        } else if (diffMins < 60) {
                            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                        } else if (diffHours < 24) {
                            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
                        } else if (diffDays === 1) {
                            requestedDateText = '1 day ago';
                        } else {
                            requestedDateText = date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Submitted:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem;">${escapeHtml(requestedDateText)}</span>
                            </div>
                        `;
                    })() : ''}
                    ${(() => {
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Within Auditor Scope:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem; display: inline-flex; align-items: center; gap: 0.1875rem;">
                                    ${withinAuditorScope === 'true' || withinAuditorScope === true ? `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #10b981;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                                        </svg>
                                        <span>Yes</span>
                                    ` : `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #6b7280;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                        </svg>
                                        <span>No</span>
                                    `}
                                </span>
                            </div>
                        `;
                    })()}
                </div>
            </div>
            
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            ${teamLeadApproved && teamLeadReviewedBy ? `
            <!-- Team Lead Approval Status -->
            <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #16a34a; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #16a34a;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Approved by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #166534; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #166534; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bbf7d0; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
                </div>
            ` : ''}
            
            ${!teamLeadApproved && teamLeadReviewedBy && (teamLeadRejectionReason || teamLeadResponse) ? `
            <!-- Team Lead Rejection Status -->
            <div style="background: #fef2f2; border: 0.0625rem solid #fecaca; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #dc2626; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #dc2626;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    Rejected by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadRejectionReason && teamLeadRejectionReason.trim() ? `
                <p style="font-size: 0.6562rem; font-weight: 600; color: #991b1b; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Rejection Reason:</p>
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadRejectionReason)}</p>
                ` : ''}
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
            </div>
            ` : ''}
            
            ${auditorResponse && reversalRespondedAt ? `
            <!-- Auditor Response (Read-only) -->
            <div style="background: #f0f9ff; border: 0.0625rem solid #bae6fd; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Response From QC</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(auditorResponse)}</p>
            </div>
            ` : ''}
        `;
    } else {
        // Auditor/CQC Review Interface
        // Get parameter comments for auditor to review
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Get reversal reason (same parsing as team lead view)
        const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
        let reversalReason = '';
        if (reversalJustification && reversalJustification.includes(':')) {
            const parts = reversalJustification.split(':');
            if (parts.length >= 2) {
                reversalReason = parts[0].trim();
            }
        }
        
        // Check if Team Lead has approved
        const teamLeadApproved = audit.team_lead_approved;
        const teamLeadReviewedBy = audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '';
        const teamLeadReviewedAt = audit.team_lead_reviewed_at || audit.teamLeadReviewedAt;
        const teamLeadResponse = audit.response_from_team_lead || audit.responseFromTeamLead || '';
        const teamLeadRejectionReason = audit.team_lead_rejection_reason || '';
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        // Format team lead review date
        let formattedReviewDate = '';
        if (teamLeadReviewedAt) {
            try {
                const date = new Date(teamLeadReviewedAt);
                formattedReviewDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedReviewDate = teamLeadReviewedAt;
            }
        }
        
        // Get auditor response if available
        const auditorResponse = audit.response_from_auditor || audit.reasonForReversalResponseDelay || '';
        const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
        
        decisionSectionHtml = `
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            <!-- Reversal Request Details -->
            <div style="background: #f9fafb; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5625rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif;">
                    ${reversalRequestedAt ? (() => {
                        const date = new Date(reversalRequestedAt);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);
                        
                        let requestedDateText = '';
                        if (diffMins < 1) {
                            requestedDateText = 'just now';
                        } else if (diffMins < 60) {
                            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                        } else if (diffHours < 24) {
                            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
                        } else if (diffDays === 1) {
                            requestedDateText = '1 day ago';
                        } else {
                            requestedDateText = date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Submitted:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem;">${escapeHtml(requestedDateText)}</span>
                            </div>
                        `;
                    })() : ''}
                    ${(() => {
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Within Auditor Scope:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem; display: inline-flex; align-items: center; gap: 0.1875rem;">
                                    ${withinAuditorScope === 'true' || withinAuditorScope === true ? `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #10b981;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                                        </svg>
                                        <span>Yes</span>
                                    ` : `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #6b7280;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                        </svg>
                                        <span>No</span>
                                    `}
                                </span>
                            </div>
                        `;
                    })()}
                </div>
            </div>
            
            ${teamLeadApproved && teamLeadReviewedBy ? `
            <!-- Team Lead Approval Status -->
            <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #16a34a; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #16a34a;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Approved by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #166534; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #166534; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bbf7d0; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
                </div>
            ` : ''}
            
            ${!teamLeadApproved && teamLeadReviewedBy && (teamLeadRejectionReason || teamLeadResponse) ? `
            <!-- Team Lead Rejection Status -->
            <div style="background: #fef2f2; border: 0.0625rem solid #fecaca; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #dc2626; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #dc2626;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    Rejected by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadRejectionReason && teamLeadRejectionReason.trim() ? `
                <p style="font-size: 0.6562rem; font-weight: 600; color: #991b1b; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Rejection Reason:</p>
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadRejectionReason)}</p>
                ` : ''}
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
            </div>
            ` : ''}
            
            ${auditorResponse && reversalRespondedAt ? `
            <!-- Auditor Response (Read-only) -->
            <div style="background: #f0f9ff; border: 0.0625rem solid #bae6fd; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Response From QC</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(auditorResponse)}</p>
            </div>
            ` : ''}
            
            ${!isAgent && !isAuditorWaitingForTeamLead && isAuthorizedForQA ? `
            <!-- Decision Section (only for authorized QA reviewers with team "QC" and role "Super Admin", not agents, and only when not waiting for team lead) -->
            <div style="border-top: 0.0625rem solid #e5e7eb; padding-top: 0.75rem;">
                <div style="margin-bottom: 0.5625rem;">
                    <div>
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Response From QC <span style="color: #ef4444;">*</span>
                        </label>
                        <textarea id="reversalDelayReason" required rows="3" placeholder="Please provide your response or comments..." style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box; background: white; cursor: text;"></textarea>
                    </div>
                </div>
                
                <!-- Hidden Approved By field (still used for data storage) -->
                <input type="hidden" id="reversalApprovedBy" value="${escapeHtml(currentUserName)}">
                
                <!-- Within Auditor Scope (for auditor to select) -->
                <div style="margin-bottom: 0.5625rem;">
                    <label style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.6562rem; font-weight: 600; color: #374151; font-family: 'Poppins', sans-serif; cursor: pointer;">
                        <input type="checkbox" id="withinAuditorScope" ${(audit.withinAuditorScope === 'true' || audit.withinAuditorScope === true || audit.within_auditor_scope === 'true' || audit.within_auditor_scope === true) ? 'checked' : ''} style="width: 0.75rem; height: 0.75rem; cursor: pointer;">
                        <span>Within Auditor Scope</span>
                    </label>
                    <p style="font-size: 0.5625rem; color: #6b7280; margin: 0.2812rem 0 0 1.125rem; font-family: 'Poppins', sans-serif;">Check if this reversal can be resolved by the original auditor</p>
                </div>
                
                <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; padding-top: 0.5625rem; border-top: 0.0625rem solid #e5e7eb;">
                    <button onclick="rejectReversal()" style="padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Reject Reversal
                    </button>
                    <button onclick="approveReversal()" style="padding: 0.5rem 1rem; background: #16a34a; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Approve Reversal
                    </button>
                </div>
            </div>
            ` : ''}
        `;
    }
    
    // Check if Team Lead has approved (for journey map)
    const teamLeadApproved = audit.team_lead_approved === true || audit.team_lead_approved === 'true' || 
                             audit.team_lead_approved === 1 || audit.team_lead_approved === '1';
    const teamLeadReviewedBy = !isTeamLeadReview ? (audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '') : '';
    
    // Build journey map/roadmap indicator
    const journeyMapHtml = await buildReversalJourneyMap(workflowState, teamLeadApproved, audit);
    
    // Debug logging for isAuditorWaitingForTeamLead
    console.log('displayReversalApprovalInterface - isAuditorWaitingForTeamLead check:', {
        workflowState,
        isAuditor,
        isOriginalAuditor,
        isAdmin,
        isTeamLead,
        isTeamSupervisor,
        isAuditorWaitingForTeamLead
    });
    
    // Determine if we should show the "Awaiting Team Lead Review" banner
    // Show for: agents, auditors (waiting), team leads/admins (when in team_lead_review state)
    const shouldShowBanner = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                              (isAgent || isAuditorWaitingForTeamLead || isTeamLeadReview || (isAdmin && (workflowState === 'team_lead_review' || workflowState === 'pending')));
    
    // Determine heading text based on user role
    let headingText = '';
    if (isAgent) {
        headingText = 'Reversal Request Info';
    } else if (isTeamLeadReview) {
        headingText = 'Team Lead Review - Reversal Request';
    } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
        if (isAuthorizedForQA) {
            headingText = 'QC Review - Reversal Request';
        } else {
            headingText = 'Reversal Request Info (Read-Only)';
        }
    } else {
        headingText = 'Review & Process Reversal';
    }
    
    const approvalInterfaceHtml = `
        <div id="reversalApprovalInterface" class="no-print" style="background: white; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(0,0,0,0.1); margin-top: 0.5625rem;">
            <!-- Heading -->
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; padding-bottom: 0.5625rem; border-bottom: 0.0625rem solid #e5e7eb;">
                <svg style="width: 1rem; height: 1rem; color: #1A733E;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <h3 style="font-size: 0.75rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(headingText)}
                </h3>
            </div>
            
            ${shouldShowBanner ? `
            <!-- Waiting for Team Lead Review Banner (at top of interface) -->
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 0.1875rem solid #f59e0b; border-radius: 0.2812rem; padding: 0.5625rem 0.75rem; margin-bottom: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(245, 158, 11, 0.1);">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="display: flex; align-items: center; justify-content: center; width: 1.5rem; height: 1.5rem; background: #f59e0b; border-radius: 50%; flex-shrink: 0;">
                        <svg style="width: 0.875rem; height: 0.875rem; color: white;" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <p style="font-size: 0.6875rem; font-weight: 700; color: #92400e; margin: 0 0 0.1875rem 0; font-family: 'Poppins', sans-serif; letter-spacing: 0.01em;">
                            Awaiting Team Lead Review
                        </p>
                        <p style="font-size: 0.625rem; color: #78350f; margin: 0; line-height: 1.4; font-family: 'Poppins', sans-serif;">
                            This reversal is pending Team Lead approval. Review will be available after approval.
                        </p>
                    </div>
                </div>
            </div>
            ` : ''}
            
            <!-- Reversal Journey Map / Roadmap - Compact Checkout Style (No Container) -->
            ${journeyMapHtml}
            
            ${decisionSectionHtml}
        </div>
    `;
    
    // Insert the approval interface right after the header section (before chat/error details)
    // Remove existing interface if it exists
    const existingApprovalInterface = document.getElementById('reversalApprovalInterface');
    if (existingApprovalInterface) {
        existingApprovalInterface.remove();
    }
    
    // Find the header section and insert right after it
    const auditFormHeader = document.getElementById('auditFormHeader');
    if (auditFormHeader && auditFormHeader.nextSibling) {
        // Insert after header, before the main content
        auditFormHeader.insertAdjacentHTML('afterend', approvalInterfaceHtml);
    } else if (auditFormHeader) {
        // If header exists but no next sibling, append after it
        auditFormHeader.insertAdjacentHTML('afterend', approvalInterfaceHtml);
    } else {
        // Fallback: try to find auditMainContent and insert before it
        const auditMainContent = document.getElementById('auditMainContent');
        if (auditMainContent) {
            auditMainContent.insertAdjacentHTML('beforebegin', approvalInterfaceHtml);
        } else {
            // Last fallback: append to end of audit content
            auditContentDiv.insertAdjacentHTML('beforeend', approvalInterfaceHtml);
        }
    }
    
    // Capture original state (only for auditors/CQC who can edit)
    if (!isTeamLeadReview) {
        // Capture original state from activity log (async)
        // This gets the true original state from when reversal was requested, not current state
        captureOriginalAuditState().then(() => {
        // Update score calculation on any parameter change (only for auditors/CQC)
        updateCalculatedScore();
        
            // Update parameter highlighting after a short delay to ensure DOM is ready
            setTimeout(() => {
                updateParameterChangeHighlighting();
            }, 200);
    }).catch(err => {
        console.error('Error capturing original audit state:', err);
        // Still try to update even if capture fails
        updateCalculatedScore();
        setTimeout(() => {
            updateParameterChangeHighlighting();
        }, 200);
    });
    }
    
    // Setup user profile hovers for team lead name
    setupUserProfileHovers();
}

// Function to fetch user by name
async function getUserByName(userName) {
    if (!userName || !window.supabaseClient) return null;
    
    try {
        const { data, error } = await window.supabaseClient
            .from('users')
            .select('*')
            .ilike('name', userName)
            .limit(1)
            .single();
        
        if (error) {
            // Try case-insensitive search if exact match fails
            const { data: allUsers } = await window.supabaseClient
                .from('users')
                .select('*')
                .limit(1000);
            
            const foundUser = allUsers?.find(u => 
                u.name && u.name.toLowerCase().trim() === userName.toLowerCase().trim()
            );
            return foundUser || null;
        }
    
        return data;
    } catch (error) {
        console.error('Error fetching user by name:', error);
        return null;
    }
}

// Function to show user profile modal
function showUserProfileModal(userData, element) {
    // Remove existing modal if any
    const existingModal = document.getElementById('userProfileModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    if (!userData) {
        return; // No user data to show
    }
    
    // Get element position
    const rect = element.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'userProfileModal';
    modal.style.cssText = `
        position: absolute;
        top: ${rect.bottom + scrollTop + 5}px;
        left: ${rect.left + scrollLeft}px;
        background: white;
        border-radius: 0.375rem;
        box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.15);
        padding: 0.75rem;
        min-width: 12.5rem;
        max-width: 18.75rem;
        z-index: 10000;
        border: 0.0625rem solid #e5e7eb;
        font-family: 'Poppins', sans-serif;
    `;
    
    // Get user avatar or initials
    const avatarUrl = userData.avatar_url || userData.avatar;
    const initials = userData.name ? userData.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2) : '?';
    
    // Build modal content
    modal.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 0.5625rem;">
            <div style="display: flex; align-items: center; gap: 0.5625rem; padding-bottom: 0.5625rem; border-bottom: 0.0625rem solid #e5e7eb;">
                ${avatarUrl ? `
                    <img src="${escapeHtml(avatarUrl)}" style="width: 2.5rem; height: 2.5rem; border-radius: 50%; object-fit: cover;" alt="${escapeHtml(userData.name || '')}">
                ` : `
                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 50%; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.875rem;">
                        ${initials}
                    </div>
                `}
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; font-size: 0.75rem; color: #1f2937; margin-bottom: 0.125rem;">${escapeHtml(userData.name || 'Unknown')}</div>
                    <div style="font-size: 0.5625rem; color: #6b7280;">${escapeHtml(userData.email || '')}</div>
                </div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 0.375rem; font-size: 0.6094rem;">
                ${userData.role ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Role:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.role)}</span>
                    </div>
                ` : ''}
                ${userData.department ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Department:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.department)}</span>
                    </div>
                ` : ''}
                ${userData.team ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Team:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.team)}</span>
                    </div>
                ` : ''}
                ${userData.channel ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Channel:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.channel)}</span>
                    </div>
                ` : ''}
                ${userData.designation ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Designation:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.designation)}</span>
                    </div>
                ` : ''}
                ${userData.employee_id ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Employee ID:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.employee_id)}</span>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Position modal to stay within viewport
    const modalRect = modal.getBoundingClientRect();
    if (modalRect.right > window.innerWidth) {
        modal.style.left = `${window.innerWidth - modalRect.width - 10}px`;
    }
    if (modalRect.bottom > window.innerHeight) {
        modal.style.top = `${rect.top + scrollTop - modalRect.height - 5}px`;
    }
    
    // Close modal when clicking outside or when mouse leaves
    const closeModal = (e) => {
        if (!modal.contains(e.target) && !element.contains(e.target)) {
            modal.remove();
            document.removeEventListener('click', closeModal);
        }
    };
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', closeModal);
    }, 100);
    
    // Close when mouse leaves the element and modal
    element.addEventListener('mouseleave', (e) => {
        const relatedTarget = e.relatedTarget;
        if (!modal.contains(relatedTarget)) {
            setTimeout(() => {
                if (!element.matches(':hover') && !modal.matches(':hover')) {
                    modal.remove();
                }
            }, 200);
        }
    });
    
    modal.addEventListener('mouseleave', () => {
        setTimeout(() => {
            if (!element.matches(':hover') && !modal.matches(':hover')) {
                modal.remove();
            }
        }, 200);
    });
}

// Setup hover event listeners for user profile
function setupUserProfileHovers() {
    // Use event delegation for dynamically created elements
    document.addEventListener('mouseenter', async function(e) {
        if (!e.target || typeof e.target.closest !== 'function') return;
        const hoverElement = e.target.closest('.user-profile-hover');
        if (!hoverElement) return;
        
        const userName = hoverElement.getAttribute('data-user-name');
        if (!userName || userName === 'Team Lead') return;
        
        // Fetch user data
        const userData = await getUserByName(userName);
        if (userData) {
            showUserProfileModal(userData, hoverElement);
        }
    }, true);
}

// Update parameter change highlighting dynamically
// Update parameter change highlighting dynamically - DISABLED
// Removed to avoid confusion - only show database values, not unsaved form changes
function updateParameterChangeHighlighting() {
    // Function disabled - no longer tracking unsaved changes
    // Only database values are displayed, not form input changes
    return;
}


// Team Lead: Approve reversal request
async function teamLeadApproveReversal() {
    // Validate that response from Team Lead is provided
    const responseFromTeamLead = document.getElementById('teamLeadResponse')?.value?.trim() || '';
    if (!responseFromTeamLead) {
        alert('Error: Response From Team Lead is required. Please provide your response before approving.');
        const responseField = document.getElementById('teamLeadResponse');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    await processReversalDecision('approved');
}

// Team Lead: Show rejection reason section
function teamLeadRejectReversal() {
    const rejectionSection = document.getElementById('teamLeadRejectionSection');
    if (rejectionSection) {
        rejectionSection.style.display = 'block';
        // Scroll to rejection section
        rejectionSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        // Focus on rejection reason dropdown
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        if (reasonSelect) {
            setTimeout(() => reasonSelect.focus(), 100);
        }
    }
}

// Team Lead: Cancel rejection (hide rejection section)
function teamLeadCancelRejection() {
    const rejectionSection = document.getElementById('teamLeadRejectionSection');
    if (rejectionSection) {
        rejectionSection.style.display = 'none';
        // Clear rejection fields
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        if (reasonSelect) reasonSelect.value = '';
    }
}

// Team Lead: Confirm rejection (validate and process)
async function teamLeadConfirmRejectReversal() {
    // Validate that response from Team Lead is provided
    const responseFromTeamLead = document.getElementById('teamLeadResponse')?.value?.trim() || '';
    if (!responseFromTeamLead) {
        alert('Error: Response From Team Lead is required. Please provide your response before rejecting.');
        const responseField = document.getElementById('teamLeadResponse');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    const rejectionReason = document.getElementById('teamLeadRejectionReason')?.value || '';
    
    if (!rejectionReason || rejectionReason.trim() === '') {
        alert('Please select a rejection reason.');
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        if (reasonSelect) {
            reasonSelect.focus();
            reasonSelect.style.borderColor = '#dc2626';
            setTimeout(() => {
                reasonSelect.style.borderColor = '#d1d5db';
            }, 2000);
        }
        return;
    }
    
    // Store rejection reason for processReversalDecision
    // The response from team lead is already stored in teamLeadResponse field
    window.teamLeadRejectionData = {
        reason: rejectionReason
    };
    
    await processReversalDecision('rejected');
}

// Approve reversal (for auditors/CQC)
async function approveReversal() {
    // Check if auditor is waiting for team lead review
    if (currentAudit) {
        const workflowState = getReversalWorkflowState(currentAudit);
        const isAuditor = isCurrentUserAuditor();
        const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
        const isAdmin = isCurrentUserAdmin();
        const isTeamLead = isCurrentUserTeamLead();
        
        const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                            (isAuditor || isOriginalAuditor) && 
                                            !isAdmin && 
                                            !isTeamLead;
        
        if (isAuditorWaitingForTeamLead) {
            alert('This reversal is currently under Team Lead review. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    }
    
    // Check if changes were made
    if (!hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    // Validate that response from QC is provided
    const responseFromAuditor = document.getElementById('reversalDelayReason')?.value?.trim() || '';
    if (!responseFromAuditor) {
        alert('Error: Response From QC is required. Please provide your response before approving.');
        const responseField = document.getElementById('reversalDelayReason');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    await processReversalDecision('approved');
}

// Reject reversal (for auditors/CQC)
async function rejectReversal() {
    // Check if auditor is waiting for team lead review
    if (currentAudit) {
        const workflowState = getReversalWorkflowState(currentAudit);
        const isAuditor = isCurrentUserAuditor();
        const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
        const isAdmin = isCurrentUserAdmin();
        const isTeamLead = isCurrentUserTeamLead();
        
        const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                            (isAuditor || isOriginalAuditor) && 
                                            !isAdmin && 
                                            !isTeamLead;
        
        if (isAuditorWaitingForTeamLead) {
            alert('This reversal is currently under Team Lead review. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    }
    
    // Validate that response from QC is provided
    const responseFromAuditor = document.getElementById('reversalDelayReason')?.value?.trim() || '';
    if (!responseFromAuditor) {
        alert('Error: Response From QC is required. Please provide your response before rejecting.');
        const responseField = document.getElementById('reversalDelayReason');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    await processReversalDecision('rejected');
}

// Process reversal decision
async function processReversalDecision(decision) {
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not available');
        return;
    }
    
    // Get current workflow state
    const workflowState = getReversalWorkflowState(currentAudit);
    const userInfo = getCurrentUserInfo();
    const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
    const currentUserEmailFromInfo = userInfo?.email || getCurrentUserEmail() || '';
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    
    // Check if user is team supervisor (async check)
    const isTeamSupervisor = await isCurrentUserTeamSupervisor();
    const canReviewAsTeamLead = (isTeamLead || isTeamSupervisor) && (workflowState === 'team_lead_review' || workflowState === 'pending' || workflowState === 'team_lead_rejected');
    
    // Check if user is authorized for QA review (team "QC" AND role "Super Admin")
    const isAuthorizedForQA = await isCurrentUserAuthorizedForQAReview();
    
    // Check permissions based on workflow state
    if (workflowState === 'team_lead_review' || workflowState === 'pending' || workflowState === 'team_lead_rejected') {
        // Team lead review stage - only team leads or admins can process
        if (!canReviewAsTeamLead && !isAdmin) {
            alert('Error: Only Team Leads, Team Supervisors, or Admins can process reversals at this stage.');
            return;
        }
    } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
        // QA Review stage - only users with team "QC" AND role "Super Admin" can process
        if (!isAuthorizedForQA) {
            alert('Error: Only users with team "QC" and role "Super Admin" can review and process reversals at this stage.');
            return;
        }
    } else {
        // Other stages - original auditor, admins, or team leads can process
        if (!isOriginalAuditor && !isAdmin && !canReviewAsTeamLead) {
            alert('Error: Only the original auditor of this audit, Admins, or Team Leads can process reversals.');
            return;
        }
    }
    
    // Determine what action this is based on workflow state and user role
    let actionType = 'final'; // default: final decision by auditor/admin
    let nextWorkflowState = '';
    let adminBypass = false; // Track if admin bypassed team leader approval
    
    if (workflowState === 'team_lead_review' || workflowState === 'pending' || workflowState === 'team_lead_rejected') {
        // Team lead review stage (including rejected state - team leads can still review/process)
        if (canReviewAsTeamLead) {
            // Normal team lead review
            actionType = 'team_lead_review';
            if (decision === 'approved') {
                nextWorkflowState = 'pending - qa_review'; // Goes to QA/Auditor for review
            } else {
                nextWorkflowState = 'pending - team_lead_rejected'; // Final rejection, stops here
            }
        } else if (isAdmin) {
            // Admin bypass: Admin can process even if team leader hasn't approved
            actionType = 'admin_bypass';
            adminBypass = true;
            if (decision === 'approved') {
                nextWorkflowState = 'pending - qa_review'; // Goes to QA/Auditor for review
            } else {
                nextWorkflowState = 'pending - team_lead_rejected'; // Final rejection, stops here
            }
        } else {
            // This should not happen if UI is properly disabled, but show a helpful message
            alert('This reversal is currently under Team Lead review. Only Team Leads, Team Supervisors, or Admins can review reversals at this stage. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
        // QA Review stage - only authorized users (team "QC" AND role "Super Admin") can process
        // isAuthorizedForQA already checked above
        actionType = 'qa_review';
        // Can edit audit parameters and then approve/reject
        if (decision === 'approved') {
            nextWorkflowState = 'pending - reversal_approved'; // Agent needs to acknowledge
        } else {
            nextWorkflowState = 'pending - reversal_rejected'; // Agent needs to acknowledge
        }
    } else if (workflowState === 'cqc_sent_back' || workflowState === 'agent_re_review') {
        // Agent needs to resubmit - this should trigger a new reversal request
        alert('This reversal was sent back by CQC. Please review and resubmit if needed.');
        return;
    } else if (workflowState === 'approved' || workflowState === 'rejected') {
        // Already processed - this shouldn't happen, but handle gracefully
        alert('This reversal has already been processed.');
        return;
    } else {
        // Final decision by original auditor or admin
        actionType = 'final';
        if (decision === 'approved') {
            nextWorkflowState = 'pending - reversal_approved';
        } else {
            nextWorkflowState = 'pending - reversal_rejected';
        }
    }
    
    // For QA approval (by auditor), require changes to audit parameters
    if (actionType === 'qa_review' && decision === 'approved' && !hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    // CRITICAL: Validate that Response From QC is provided for ALL users (including admins)
    // This validation cannot be bypassed and applies to everyone
    if (actionType === 'qa_review' || actionType === 'final' || actionType === 'admin_bypass') {
        // For QA/Auditor review, admin bypass, or final decision - require Response From QC
        const responseFromAuditor = document.getElementById('reversalDelayReason')?.value?.trim() || '';
        if (!responseFromAuditor) {
            alert('Error: Response From QC is required. Please provide your response before processing this reversal. This field is mandatory for all users including admins.');
            const responseField = document.getElementById('reversalDelayReason');
            if (responseField) {
                responseField.focus();
                responseField.style.borderColor = '#dc2626';
                setTimeout(() => {
                    responseField.style.borderColor = '#d1d5db';
                }, 3000);
            }
            return;
        }
    } else if (actionType === 'team_lead_review') {
        // For Team Lead review - require Team Lead Response
        const responseFromTeamLead = document.getElementById('teamLeadResponse')?.value?.trim() || '';
        if (!responseFromTeamLead) {
            alert('Error: Response From Team Lead is required. Please provide your response before processing this reversal.');
            const responseField = document.getElementById('teamLeadResponse');
            if (responseField) {
                responseField.focus();
                responseField.style.borderColor = '#dc2626';
                setTimeout(() => {
                    responseField.style.borderColor = '#d1d5db';
                }, 3000);
            }
            return;
        }
    }
    
    try {
        // FIRST: Retrieve the original state from activity log (when reversal was requested)
        // This ensures we have the true original state, not the current state
        let loggedOriginalState = null;
        try {
            const { data: reversalRequestLog, error: logFetchError } = await window.supabaseClient
                .from('audit_activity_log')
                .select('*')
                .eq('audit_id', currentAudit.id)
                .eq('activity_type', 'reversal_requested')
                .order('activity_timestamp', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!logFetchError && reversalRequestLog) {
                loggedOriginalState = {
                    parameters: reversalRequestLog.parameters_snapshot || {},
                    feedback: reversalRequestLog.feedback_snapshot || {},
                    score: reversalRequestLog.score_snapshot || 0,
                    passingStatus: reversalRequestLog.passing_status_snapshot || ''
                };
                console.log('Retrieved original state from activity log:', loggedOriginalState);
            } else if (logFetchError) {
                console.warn('Could not retrieve original state from activity log:', logFetchError);
            }
        } catch (logErr) {
            console.warn('Error retrieving original state from activity log:', logErr);
        }
        
        // Use logged original state if available, otherwise fall back to originalAuditState
        const trueOriginalState = loggedOriginalState || originalAuditState;
        
        // First, save all parameter changes
        const auditData = {};
        
        // Collect parameter values
        const errorInputs = document.querySelectorAll('input[type="number"][id]:not([id^="feedback_"]):not([id^="comment_"]), input[type="radio"]:checked');
        errorInputs.forEach(input => {
            if (input.type === 'radio') {
                auditData[input.name] = parseInt(input.value) || 0;
            } else {
                const fieldId = input.id;
                if (fieldId && !fieldId.startsWith('feedback_') && !fieldId.startsWith('comment_')) {
                    auditData[fieldId] = parseInt(input.value) || 0;
                }
            }
        });
        
        // Collect feedback values
        const feedbackTextareas = document.querySelectorAll('textarea[id^="feedback_"]');
        const feedbackByField = {};
        feedbackTextareas.forEach(textarea => {
            const fieldId = textarea.id.replace(/^feedback_/, '').replace(/_\d+$/, '');
            if (!feedbackByField[fieldId]) {
                feedbackByField[fieldId] = [];
            }
            if (textarea.value && textarea.value.trim()) {
                feedbackByField[fieldId].push(textarea.value.trim());
            }
        });
        
        Object.keys(feedbackByField).forEach(fieldId => {
            const feedbacks = feedbackByField[fieldId];
            auditData[`feedback_${fieldId}`] = feedbacks.length > 0 ? feedbacks : null;
        });
        
        // Note: Feedback should never be cleared, even if error count is 0
        // This ensures feedback/comments remain visible regardless of error count changes
        
        // Calculate new score
        const newScore = calculateNewScore();
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        // Get user info
        const userInfo = getCurrentUserInfo();
        const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
        const logUserEmail = userInfo?.email || '';
        
        // Get reversal decision details
        const approvedBy = document.getElementById('reversalApprovedBy')?.value || currentUserName;
        // Note: delayReason is validated above in processReversalDecision before reaching here
        // This is just to get the value for saving - validation ensures it exists
        const delayReason = document.getElementById('reversalDelayReason')?.value?.trim() || '';
        const withinAuditorScope = document.getElementById('withinAuditorScope')?.checked ? 'true' : 'false';
        
        // Calculate SLA
        const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
        const respondedAt = new Date();
        let slaHours = 0;
        if (reversalRequestedAt) {
            const requestedAt = new Date(reversalRequestedAt);
            slaHours = ((respondedAt - requestedAt) / (1000 * 60 * 60));
        }
        
        // Count changed parameters and feedback (without storing detailed change data)
        let parametersChangedCount = 0;
        let feedbackChangedCount = 0;
        
        if (trueOriginalState) {
            currentErrorFields.forEach(field => {
                const fieldKey = field.key;
                let currentValue = 0;
                
                if (field.field_type === 'radio') {
                    const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
                    if (radioInput) {
                        currentValue = parseInt(radioInput.value) || 0;
                    }
                } else {
                    const numberInput = document.getElementById(fieldKey);
                    if (numberInput) {
                        currentValue = parseInt(numberInput.value) || 0;
                    }
                }
                
                const originalValue = trueOriginalState.parameters[fieldKey] || 0;
                if (currentValue !== originalValue) {
                    parametersChangedCount++;
                }
                
                // Check feedback changes
                const feedbackKey = `feedback_${fieldKey}`;
                const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
                const currentFeedbacks = Array.from(feedbackTextareas)
                    .map(ta => ta.value.trim())
                    .filter(v => v);
                
                const originalFeedback = trueOriginalState.feedback[fieldKey];
                let originalFeedbacks = [];
                if (originalFeedback) {
                    if (Array.isArray(originalFeedback)) {
                        originalFeedbacks = originalFeedback.filter(f => f && f.trim());
                    } else if (typeof originalFeedback === 'string') {
                        try {
                            const parsed = JSON.parse(originalFeedback);
                            originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                        } catch {
                            originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                        }
                    }
                }
                
                if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
                    feedbackChangedCount++;
                }
            });
        }
        
        // Prepare audit update data
        const originalScore = trueOriginalState?.score || currentAudit.averageScore || currentAudit.average_score || 0;
        const originalPassingStatus = trueOriginalState?.passingStatus || currentAudit.passingStatus || currentAudit.passing_status || '';
        
        // Set acknowledgement status based on workflow state and action type
        const updateData = {
            ...auditData,
            acknowledgement_status: nextWorkflowState,
            acknowledgement_status_updated_at: respondedAt.toISOString()
        };
        
        // Handle different action types
        if (actionType === 'team_lead_review') {
            // Team Lead review - data is stored in reversal_workflow_states, not audit table
            // Keep these fields for backward compatibility with old audits, but don't write them for new reversals
            // The actual data will be in reversal_workflow_states table
            
            // Note: Team lead response is saved to reversal_requests table, not audit table
            // (removed updateData.response_from_team_lead to avoid schema errors)
            
            // Don't write team_lead_* fields to audit table anymore - stored in reversal_workflow_states
            // Keeping this section empty but leaving comment for clarity
            
            // Don't set reversal_approved yet - that's for QA's final decision
        } else if (actionType === 'admin_bypass') {
            // Admin bypass - Admin processed without team leader approval
            // Data is stored in reversal_workflow_states, not audit table
            // Don't write team_lead_* fields to audit table anymore
            // admin_bypass is now stored in reversal_requests table, not audit table
            // reversal_processed_by/email are now tracked in reversal_workflow_states.entered_by_name/email
            
            // Get response from QC - REQUIRED (validation already done above)
            const delayReasonValue = delayReason?.trim() || '';
            if (!delayReasonValue) {
                throw new Error('Response From QC is required but was not provided. This should not happen as validation should have caught this.');
            }
            updateData.response_from_auditor = delayReasonValue;
            updateData.sla_in_hours = parseFloat(slaHours.toFixed(2));
        } else if (actionType === 'qa_review') {
            // QA/Auditor review - can edit audit parameters and make final decision
            updateData.reversal_approved = decision === 'approved';
            updateData.reversal_responded_at = respondedAt.toISOString();
            updateData.reversal_approved_by = currentUserName;
            // reversal_resolved_by is deprecated - now stored in reversal_requests.final_decision_by_name
            // Keep for backward compatibility but don't write to it anymore
            // Set within_auditor_scope based on auditor's selection
            updateData.within_auditor_scope = withinAuditorScope;
            
            // reversal_processed_by/email are now tracked in reversal_workflow_states.entered_by_name/email
            // admin_bypass is now stored in reversal_requests table
            
            // Get response from QC - REQUIRED (validation already done above, but ensure it's saved)
            const delayReason = document.getElementById('reversalDelayReason')?.value?.trim() || '';
            if (!delayReason) {
                throw new Error('Response From QC is required but was not provided. This should not happen as validation should have caught this.');
            }
            updateData.response_from_auditor = delayReason;
            updateData.sla_in_hours = parseFloat(slaHours.toFixed(2));
            
            // If approved, update score and passing status
            if (decision === 'approved') {
                updateData.average_score = newScore;
                updateData.passing_status = isPassing ? 'Passing' : 'Not Passing';
                updateData.score_after_appeal = newScore;
                updateData.did_result_in_pass = isPassing;
            }
        } else {
            // Legacy/old flow: Final decision by auditor (for backward compatibility)
            updateData.reversal_approved = decision === 'approved';
            updateData.reversal_responded_at = respondedAt.toISOString();
            updateData.reversal_approved_by = approvedBy;
            // reversal_resolved_by is deprecated - now stored in reversal_requests.final_decision_by_name
            // Keep for backward compatibility but don't write to it anymore
            // Get response from QC - REQUIRED (validation already done above, but ensure it's not null/empty)
            const delayReasonValue = delayReason?.trim() || '';
            if (!delayReasonValue) {
                throw new Error('Response From QC is required but was not provided. This should not happen as validation should have caught this.');
            }
            updateData.response_from_auditor = delayReasonValue;
            updateData.sla_in_hours = parseFloat(slaHours.toFixed(2));
        
        // If approved, update score and passing status
        if (decision === 'approved') {
            updateData.average_score = newScore;
            updateData.passing_status = isPassing ? 'Passing' : 'Not Passing';
            updateData.score_after_appeal = newScore;
            // Note: passed_after_appeal column doesn't exist in schema, using did_result_in_pass instead
            updateData.did_result_in_pass = isPassing;
            }
        }
        
        // Update audit in database
        const { data: updatedAudit, error: updateError } = await window.supabaseClient
            .from(currentTableName)
            .update(updateData)
            .eq('id', currentAudit.id)
            .select();
        
        if (updateError) throw updateError;
        
        // Update reversal_requests and reversal_workflow_states (if reversal exists)
        try {
            // Find the reversal_request for this audit
            const { data: reversalRequest, error: rrFetchError } = await window.supabaseClient
                .from('reversal_requests')
                .select('id, current_state_id')
                .eq('audit_id', currentAudit.id)
                .eq('scorecard_table_name', currentTableName)
                .order('requested_at', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!rrFetchError && reversalRequest) {
                // Prepare reversal_requests update data
                const reversalUpdateData = {
                    updated_at: new Date().toISOString()
                };
                
                // Add admin_bypass if this is an admin bypass action
                if (actionType === 'admin_bypass') {
                    reversalUpdateData.admin_bypass = true;
                } else if (actionType === 'qa_review' && isAdmin) {
                    // Admin processed at QA stage (not a bypass, but admin processed)
                    reversalUpdateData.admin_bypass = false;
                }
                
                // Add team lead response if this is team lead review
                if (actionType === 'team_lead_review') {
                    const teamLeadResponse = document.getElementById('teamLeadResponse')?.value || '';
                    if (teamLeadResponse) {
                        reversalUpdateData.team_lead_response = teamLeadResponse;
                    }
                }
                
                // Add final decision info if this is QA review or final decision
                if (actionType === 'qa_review' || actionType === 'final') {
                    reversalUpdateData.final_decision = decision;
                    reversalUpdateData.final_decision_at = respondedAt.toISOString();
                    reversalUpdateData.final_decision_by_name = currentUserName;
                    reversalUpdateData.final_decision_by_email = logUserEmail;
                    reversalUpdateData.new_score = decision === 'approved' ? newScore : null;
                    reversalUpdateData.new_passing_status = decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : null;
                    reversalUpdateData.sla_hours = parseFloat(slaHours.toFixed(2));
                    reversalUpdateData.within_auditor_scope = withinAuditorScope;
                }
                
                // Update reversal_requests with error handling for missing columns
                try {
                    const { error: rrUpdateError } = await window.supabaseClient
                        .from('reversal_requests')
                        .update(reversalUpdateData)
                        .eq('id', reversalRequest.id);
                    
                    if (rrUpdateError) {
                        // Check if error is about missing column (schema cache issue)
                        const errorMessage = rrUpdateError.message || String(rrUpdateError);
                        if (errorMessage.includes('Could not find') && errorMessage.includes('column')) {
                            console.warn('Schema cache error - column may not exist in reversal_requests table:', errorMessage);
                            // Check if it's specifically about team_lead_response
                            if (errorMessage.includes('team_lead_response')) {
                                // Remove team_lead_response and retry
                                const { team_lead_response, ...updateDataWithoutTeamLeadResponse } = reversalUpdateData;
                                const { error: retryError } = await window.supabaseClient
                                    .from('reversal_requests')
                                    .update(updateDataWithoutTeamLeadResponse)
                                    .eq('id', reversalRequest.id);
                                if (retryError) {
                                    console.warn('Error updating reversal_requests table (retry without team_lead_response failed):', retryError);
                                } else {
                                    console.warn('Updated reversal_requests without team_lead_response (column does not exist)');
                                }
                            } else {
                                // Some other column issue - log and continue
                                console.warn('Error updating reversal_requests table (unknown column issue):', rrUpdateError);
                            }
                        } else {
                            console.warn('Error updating reversal_requests table:', rrUpdateError);
                        }
                        // Don't throw - audit update succeeded, this is secondary
                    }
                } catch (updateErr) {
                    console.warn('Exception updating reversal_requests table:', updateErr);
                    // Don't throw - audit update succeeded, this is secondary
                }
                
                // Create/update workflow state for this action
                // First, mark previous state as not current
                if (reversalRequest.current_state_id) {
                    await window.supabaseClient
                        .from('reversal_workflow_states')
                        .update({ is_current: false })
                        .eq('id', reversalRequest.current_state_id);
                }
                
                // Determine new workflow state based on action type
                let newWorkflowState = '';
                if (actionType === 'team_lead_review') {
                    newWorkflowState = decision === 'approved' ? 'team_lead_approved' : 'team_lead_rejected';
                } else if (actionType === 'admin_bypass') {
                    newWorkflowState = decision === 'approved' ? 'team_lead_approved' : 'team_lead_rejected';
                } else if (actionType === 'qa_review') {
                    newWorkflowState = decision === 'approved' ? 'approved' : 'rejected';
                } else {
                    newWorkflowState = decision === 'approved' ? 'approved' : 'rejected';
                }
                
                // Prepare rejection reason for team lead rejection
                let rejectionReason = null;
                if (actionType === 'team_lead_review' && decision === 'rejected') {
                    const rejectionData = window.teamLeadRejectionData || {};
                    const reason = rejectionData.reason || '';
                    
                    // Use the rejection reason (response from team lead is stored separately)
                    if (reason) {
                        rejectionReason = reason;
                    }
                    
                    // Clear the stored rejection data
                    delete window.teamLeadRejectionData;
                }
                
                // Create new workflow state
                const { data: newWorkflowStateData, error: wsError } = await window.supabaseClient
                    .from('reversal_workflow_states')
                    .insert({
                        reversal_request_id: reversalRequest.id,
                        state: newWorkflowState,
                        entered_at: respondedAt.toISOString(),
                        entered_by_email: logUserEmail,
                        entered_by_name: currentUserName,
                        previous_state_id: reversalRequest.current_state_id || null,
                        is_current: true,
                        rejection_reason: rejectionReason,
                        notes: actionType === 'admin_bypass' 
                            ? `Admin bypassed team lead approval - ${decision === 'approved' ? 'approved' : 'rejected'}`
                            : actionType === 'team_lead_review'
                            ? `Team Lead ${decision === 'approved' ? 'approved' : 'rejected'} reversal`
                            : `QA review - ${decision === 'approved' ? 'approved' : 'rejected'} reversal`
                    })
                    .select()
                    .single();
                
                if (!wsError && newWorkflowStateData) {
                    // Update reversal_requests with new current_state_id
                    await window.supabaseClient
                        .from('reversal_requests')
                        .update({ current_state_id: newWorkflowStateData.id })
                        .eq('id', reversalRequest.id);
                } else if (wsError) {
                    console.warn('Error creating workflow state:', wsError);
                    // Don't throw - audit update succeeded
                }
            }
        } catch (rrErr) {
            console.warn('Error updating reversal_requests/workflow_states:', rrErr);
            // Don't throw - audit update succeeded
        }
        
        // Log approval/rejection to activity log
        try {
            // Capture new state after update
            const newAuditState = {
                parameters: auditData,
                feedback: feedbackByField,
                score: decision === 'approved' ? newScore : originalScore,
                passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                acknowledgement_status: nextWorkflowState
            };
            
            // Determine activity type based on action type
            let activityType = 'reversal_processed';
            if (actionType === 'team_lead_review') {
                activityType = decision === 'approved' ? 'reversal_team_lead_approved' : 'reversal_team_lead_rejected';
            } else if (actionType === 'qa_review') {
                activityType = decision === 'approved' ? 'reversal_approved' : 'reversal_rejected';
            } else {
                activityType = decision === 'approved' ? 'reversal_approved' : 'reversal_rejected';
            }
            
            const activityLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                activity_type: activityType,
                activity_timestamp: respondedAt.toISOString(),
                performed_by_email: logUserEmail,
                performed_by_name: currentUserName,
                audit_state_snapshot: newAuditState,
                parameters_snapshot: auditData,
                feedback_snapshot: feedbackByField,
                score_snapshot: newAuditState.score,
                passing_status_snapshot: newAuditState.passing_status,
                changes_made: {
                    score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                    passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed'))
                },
                change_reason: decision === 'approved' ? 'Reversal approved by quality analyst' : 'Reversal rejected by quality analyst',
                metadata: {
                    approved_by: approvedBy,
                    delay_reason: delayReason,
                    sla_hours: parseFloat(slaHours.toFixed(2)),
                    parameters_changed_count: parametersChangedCount,
                    feedback_changed_count: feedbackChangedCount
                }
            };
            
            const { error: activityLogError } = await window.supabaseClient
                .from('audit_activity_log')
                .insert(activityLogData);
            
            if (activityLogError) {
                console.error('Error logging reversal decision to activity log:', activityLogError);
                // Don't throw - audit update succeeded, logging is secondary
            } else {
                console.log('Successfully logged reversal decision to activity log');
            }
        } catch (activityLogErr) {
            console.error('Error creating activity log entry for reversal decision:', activityLogErr);
            // Don't throw - audit update succeeded
        }
        
        // Save to reversal_change_log table
        try {
            const changeLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                reversal_requested_at: reversalRequestedAt,
                original_score: originalScore,
                original_passing_status: originalPassingStatus,
                original_parameters: trueOriginalState?.parameters || {},
                original_feedback: trueOriginalState?.feedback || {},
                new_score: decision === 'approved' ? newScore : originalScore,
                new_passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                parameters_changed_count: parametersChangedCount,
                feedback_changed_count: feedbackChangedCount,
                score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed')),
                reversal_decision: decision,
                reversal_approved: decision === 'approved',
                reversal_responded_at: respondedAt.toISOString(),
                processed_by_email: logUserEmail,
                processed_by_name: currentUserName,
                approved_by_email: logUserEmail,
                approved_by_name: approvedBy,
                sla_hours: parseFloat(slaHours.toFixed(2)),
                delay_reason: delayReason
            };
            
            const { error: logError } = await window.supabaseClient
                .from('reversal_change_log')
                .insert(changeLogData);
            
            if (logError) {
                console.error('Error saving to reversal_change_log:', logError);
                // Don't throw - audit update succeeded, logging is secondary
            }
        } catch (logErr) {
            console.error('Error creating change log:', logErr);
            // Don't throw - audit update succeeded
        }
        
        // Show success message
        let successMessage = '';
        if (actionType === 'team_lead_review') {
            if (decision === 'approved') {
                successMessage = ' Reversal request has been sent to QC. The request is now under QC review.';
            } else {
                successMessage = ' Reversal request has been rejected. The agent will be notified.';
            }
        } else if (actionType === 'admin_bypass') {
            if (decision === 'approved') {
                successMessage = ' Reversal request has been processed by Admin (Team Leader approval bypassed). The request is now under QC review.';
            } else {
                successMessage = ' Reversal request has been rejected by Admin (Team Leader approval bypassed). The agent will be notified.';
            }
        } else if (actionType === 'qa_review') {
            successMessage = ` Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`;
        } else {
            // Legacy flow
            successMessage = ` Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`;
        }
        
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: successMessage,
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert(successMessage);
        }
        
        // Reload page to show updated state
        location.reload();
        
    } catch (error) {
        console.error('Error processing reversal:', error);
        alert('Failed to process reversal: ' + (error.message || 'Unknown error'));
    }
}



// Update parameter change highlighting dynamically - DISABLED
// Removed to avoid confusion - only show database values, not unsaved form changes
function updateParameterChangeHighlighting() {
    // Function disabled - no longer tracking unsaved changes
    // Only database values are displayed, not form input changes
    return;
}

// Display submitted reversal form details (read-only) - 100% same as edit-audit.html agent view
async function displaySubmittedReversalForm(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) return;
    
    // Get reversal data from audit
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    
    // Only show if a reversal was actually submitted
    if (!reversalRequestedAt) {
        return; // No reversal submitted, don't show form
    }
    
    // Load workflow state from reversal_requests table if not already cached
    await loadReversalWorkflowState(audit);
    
    // Get workflow state for journey map
    const workflowState = getReversalWorkflowState(audit);
    // Check if Team Lead has approved (for journey map) - use mapped fields
    const teamLeadApproved = audit.teamLeadApproved === true || audit.teamLeadApproved === 'true' || audit.teamLeadApproved === 1 || audit.teamLeadApproved === '1' ||
                             (audit.team_lead_approved === true || audit.team_lead_approved === 'true' || audit.team_lead_approved === 1 || audit.team_lead_approved === '1');
    
    // Check if auditor is waiting for team lead review (same logic as edit-audit.html)
    const isAuditor = isCurrentUserAuditor();
    const isOriginalAuditor = isCurrentUserOriginalAuditor(audit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    // Check if user is team supervisor (async function if it exists, otherwise default to false)
    let isTeamSupervisor = false;
    if (typeof isCurrentUserTeamSupervisor === 'function') {
        try {
            isTeamSupervisor = await isCurrentUserTeamSupervisor();
        } catch (e) {
            // Function doesn't exist or error occurred, default to false
            isTeamSupervisor = false;
        }
    }
    
    const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                        (isAuditor || isOriginalAuditor) && 
                                        !isAdmin && 
                                        !isTeamLead && 
                                        !isTeamSupervisor;
    
    // Check if user is an agent (audited employee)
    const isAgent = isCurrentUserAuditedEmployee();
    
    // Show banner for agents when reversal is under team lead review, or for auditors waiting for team lead
    const shouldShowBanner = (isAgent && (workflowState === 'team_lead_review' || workflowState === 'pending')) || isAuditorWaitingForTeamLead;
    
    // Get scorecard for passing threshold (same as edit-audit.html)
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = scorecard.passing_threshold || 85;
    
    // Calculate error counts (same as edit-audit.html agent view)
    let totalErrorsCount = 0;
    let criticalFailCount = 0;
    let criticalCount = 0;
    let significantCount = 0;
    
    if (currentErrorFields && currentErrorFields.length > 0) {
        currentErrorFields.forEach(field => {
            const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
            if (field.parameter_type === 'error' || !field.parameter_type) {
                totalErrorsCount += count;
            }
            if (count > 0) {
                if (field.severity === 'Critical Fail') {
                    criticalFailCount += count;
                } else if (field.severity === 'Critical') {
                    criticalCount += count;
                } else if (field.severity === 'Significant') {
                    significantCount += count;
                }
            }
        });
    }
    
    // Get audit information (same as edit-audit.html agent view)
    const currentScore = audit.averageScore || audit.average_score || 0;
    const passingStatus = audit.passingStatus || audit.passing_status || '';
    const employeeName = audit.employeeName || audit.employee_name || 'N/A';
    const auditorName = audit.auditorName || audit.auditor_name || 'N/A';
    const auditDate = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
    const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
    const scoreBeforeAppeal = audit.scoreBeforeAppeal || audit.score_before_appeal || currentScore;
    
    // Format audit date
    let formattedDate = 'N/A';
    if (auditDate) {
        try {
            const date = new Date(auditDate);
            formattedDate = date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (e) {
            formattedDate = auditDate;
        }
    }
    
    // Get parameter comments for agent to view
    const parameterComments = audit.parameterComments || audit.parameter_comments || {};
    const parametersWithComments = currentErrorFields.filter(field => {
        const fieldComment = parameterComments[field.key];
        if (!fieldComment) return false;
        const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
        return commentText && commentText.trim();
    });
    
    // Get reversal reason (same parsing as edit-audit.html)
    const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
    let reversalReason = '';
    if (reversalJustification && reversalJustification.includes(':')) {
        const parts = reversalJustification.split(':');
        if (parts.length >= 2) {
            reversalReason = parts[0].trim();
        }
    }
    
    // Check if Team Lead has approved - use mapped fields (from reversal tables with fallback to audit table)
    const teamLeadReviewedBy = audit.teamLeadReviewedBy || audit.team_lead_reviewed_by || '';
    const teamLeadReviewedAt = audit.teamLeadReviewedAt || audit.team_lead_reviewed_at;
    const teamLeadResponse = audit.responseFromTeamLead || audit.response_from_team_lead || '';
    const teamLeadRejectionReason = audit.teamLeadRejectionReason || audit.team_lead_rejection_reason || '';
    
    // Get reversal request details
    const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
    
    // Format team lead review date
    let formattedReviewDate = '';
    if (teamLeadReviewedAt) {
        try {
            const date = new Date(teamLeadReviewedAt);
            formattedReviewDate = date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (e) {
            formattedReviewDate = teamLeadReviewedAt;
        }
    }
    
    // Get auditor response if available
    const auditorResponse = audit.response_from_auditor || audit.reasonForReversalResponseDelay || '';
    const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
    
    // Build journey map/roadmap indicator
    const journeyMapHtml = await buildReversalJourneyMap(workflowState, teamLeadApproved, audit);
    
    // Format reversal requested date
    let requestedDateText = '';
    if (reversalRequestedAt) {
        const date = new Date(reversalRequestedAt);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) {
            requestedDateText = 'just now';
        } else if (diffMins < 60) {
            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        } else if (diffHours < 24) {
            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        } else if (diffDays === 1) {
            requestedDateText = '1 day ago';
        } else {
            requestedDateText = date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    // Create read-only reversal form display (100% matching edit-audit.html agent view)
    const submittedFormHtml = `
        <div id="submittedReversalForm" class="no-print" style="background: white; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(0,0,0,0.1); margin-top: 0.5625rem;">
            <div style="display: flex; align-items: center; gap: 0.375rem; margin-bottom: 0.5625rem; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.9375rem; height: 0.9375rem; color: #1A733E;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    <h3 style="font-size: 0.8438rem; font-weight: 700; color: #111827; margin: 0; font-family: 'Poppins', sans-serif;">Review & Process Reversal</h3>
                </div>
            </div>
            
            ${shouldShowBanner ? `
            <!-- Waiting for Team Lead Review Banner (at top of interface) -->
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 0.1875rem solid #f59e0b; border-radius: 0.2812rem; padding: 0.5625rem 0.75rem; margin-bottom: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(245, 158, 11, 0.1);">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="display: flex; align-items: center; justify-content: center; width: 1.5rem; height: 1.5rem; background: #f59e0b; border-radius: 50%; flex-shrink: 0;">
                        <svg style="width: 0.875rem; height: 0.875rem; color: white;" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <p style="font-size: 0.6875rem; font-weight: 700; color: #92400e; margin: 0 0 0.1875rem 0; font-family: 'Poppins', sans-serif; letter-spacing: 0.01em;">
                            Awaiting Team Lead Review
                        </p>
                        <p style="font-size: 0.625rem; color: #78350f; margin: 0; line-height: 1.4; font-family: 'Poppins', sans-serif;">
                            This reversal is pending Team Lead approval. Review will be available after approval.
                        </p>
                    </div>
                </div>
            </div>
            ` : ''}
            
            <!-- Reversal Journey Map / Roadmap - Compact Checkout Style (No Container) -->
            ${journeyMapHtml}
            
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            ${teamLeadApproved && teamLeadReviewedBy ? `
            <!-- Team Lead Approval Status -->
            <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #16a34a; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #16a34a;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                            </svg>
                    Approved by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #166534; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #166534; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bbf7d0; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
                    </div>
            ` : ''}
            
            ${!teamLeadApproved && teamLeadReviewedBy && (teamLeadRejectionReason || teamLeadResponse) ? `
            <!-- Team Lead Rejection Status -->
            <div style="background: #fef2f2; border: 0.0625rem solid #fecaca; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #dc2626; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #dc2626;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    Rejected by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                </p>
                ${teamLeadRejectionReason && teamLeadRejectionReason.trim() ? `
                <p style="font-size: 0.6562rem; font-weight: 600; color: #991b1b; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Rejection Reason:</p>
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadRejectionReason)}</p>
                ` : ''}
                ${teamLeadResponse && teamLeadResponse.trim() ? `
                <p style="font-size: 0.6562rem; color: #991b1b; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #fecaca; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(teamLeadResponse)}</p>
                ` : ''}
            </div>
            ` : ''}
            
            ${auditorResponse && reversalRespondedAt ? `
            <!-- Auditor Response (Read-only) -->
            <div style="background: #f0f9ff; border: 0.0625rem solid #bae6fd; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Response From QC</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(auditorResponse)}</p>
                            </div>
            ` : ''}
        </div>
    `;
    
    // Insert the reversal form right after the header section (before chat/error details) - matching edit-audit.html
    // Remove existing form if it exists
        const existingForm = document.getElementById('submittedReversalForm');
        if (existingForm) {
            existingForm.remove();
        }
        
    // Find the header section and insert right after it (matching edit-audit.html positioning)
    const auditFormHeader = document.getElementById('auditFormHeader');
    if (auditFormHeader && auditFormHeader.nextSibling) {
        // Insert after header, before the main content
        auditFormHeader.insertAdjacentHTML('afterend', submittedFormHtml);
    } else if (auditFormHeader) {
        // If header exists but no next sibling, append after it
        auditFormHeader.insertAdjacentHTML('afterend', submittedFormHtml);
    } else {
        // Fallback: try to find auditMainContent and insert before it
        const auditMainContent = document.getElementById('auditMainContent');
        if (auditMainContent) {
            auditMainContent.insertAdjacentHTML('beforebegin', submittedFormHtml);
        } else {
            // Last fallback: append to end of audit content
        auditContentDiv.insertAdjacentHTML('beforeend', submittedFormHtml);
        }
    }
        
        // Setup user profile hover modals
        setupUserProfileHovers();
}

// Start reversal timer countdown
function startReversalTimer(auditSubmissionTime) {
    const timerElement = document.getElementById('reversalTimer');
    const timerTextElement = document.getElementById('reversalTimerText');
    const timerValueElement = document.getElementById('reversalTimerValue');
    const timerIconElement = document.getElementById('reversalTimerIcon');
    
    if (!timerElement || !timerTextElement) {
        return;
    }
    
    // Update timer every second
    const updateTimer = () => {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        
        if (timeRemaining <= 0) {
            // Timer expired - hide reversal button
            timerElement.style.display = 'none';
            const reversalBtn = document.getElementById('reversalBtn');
            if (reversalBtn) {
                reversalBtn.style.display = 'none';
                // Adjust acknowledge button border radius if reversal button is hidden
                const acknowledgeBtn = document.getElementById('acknowledgeBtn');
                if (acknowledgeBtn) {
                    acknowledgeBtn.style.borderRadius = '0.2425rem';
                }
            }
            return;
        }
        
        // Check if time is running low (less than 2 hours)
        const isLowTime = timeRemaining < 7200; // 2 hours in seconds
        const isVeryLowTime = timeRemaining < 3600; // 1 hour in seconds
        const isCriticalTime = timeRemaining < 600; // 10 minutes in seconds
        
        // Determine color and animation based on time remaining
        let timerColor = '#374151';
        let timerAnimation = 'none';
        let elementAnimation = 'none';
        let elementColor = '#000000';
        let elementFontWeight = '500';
        let iconColor = '';
        let iconAnimation = 'none';
        let iconOpacity = '0.6';
        
        if (isCriticalTime) {
            // Critical: Red color, flash animation, shake effect
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 0.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1s ease-in-out infinite, shake 0.5s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '700';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isVeryLowTime) {
            // Very low: Orange color, pulse animation
            timerColor = '#f59e0b';
            timerAnimation = 'flash-text 1s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1.5s ease-in-out infinite';
            elementColor = '#f59e0b';
            elementFontWeight = '600';
            iconColor = '#f59e0b';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isLowTime) {
            // Low: Red color, subtle pulse
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 1.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 2s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '600';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        }
        
        // Get current footer to determine text color
        const footerBar = document.getElementById('footerBar');
        let defaultTimerColor = '#374151';
        let defaultTextColor = '#000000';
        
        if (footerBar) {
            const bgColor = footerBar.style.backgroundColor || window.getComputedStyle(footerBar).backgroundColor;
            const isFooterGreen = bgColor.includes('rgb(6, 95, 70)') || bgColor.includes('#065f46');
            
            if (isFooterGreen) {
                defaultTimerColor = 'white';
                defaultTextColor = 'white';
            }
        }
        
        // For critical time, use red; otherwise use the footer-appropriate color (white for green, gray for default)
        const finalTimerColor = isCriticalTime ? '#ef4444' : defaultTimerColor;
        
        timerTextElement.innerHTML = `Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${finalTimerColor}; animation: ${timerAnimation};">${formatTimeRemaining(timeRemaining)}</span>`;
        
        // Apply styles to timer element
        timerElement.style.animation = elementAnimation;
        timerElement.style.color = defaultTextColor;
        timerElement.style.fontWeight = elementFontWeight;
        
        // Update icon animation
        const currentIconElement = document.getElementById('reversalTimerIcon');
        if (currentIconElement) {
            currentIconElement.style.color = iconColor;
            currentIconElement.style.animation = iconAnimation;
            currentIconElement.style.opacity = iconOpacity;
        }
        
        // Continue updating
        setTimeout(updateTimer, 1000);
    };
    
    // Start the timer
    updateTimer();
}

// Toggle function removed - chat view is always shown, with auto-fallback to text view only on failure

// Intercom API Integration
let currentConversationData = null;
let isChatViewActive = false;

// Get Intercom and Supabase config (use existing globals from config files if available)
const INTERCOM_CONFIG = window.intercomConfig || {
    baseUrl: 'https://app.intercom.com',
    appId: ''
};

// Get Supabase config from window.SupabaseConfig (set by supabase-config.js)
// Use local variables with different names to avoid conflicts
const supabaseUrl = window.SupabaseConfig?.url || '';
const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';

// Fetch conversation from Intercom API
async function loadConversationFromIntercom(conversationId) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    
    if (!chatMessagesContainer || !transcriptChatView) return;
    
    // Show loading state
    chatMessagesContainer.innerHTML = `
        <div style="text-align: center; padding: 1.2937rem; color: #000000;">
            <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
        </div>
    `;

    try {
        // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
        // Add display_as parameter to get full conversation data including email_message_metadata
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}&display_as=plaintext`;
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const conversation = await response.json();
        currentConversationData = conversation;

        // DEBUG: Log raw API response
        console.log('=== RAW API RESPONSE ===');
        console.log('Full conversation object:', conversation);
        console.log('Total conversation parts:', conversation.conversation_parts?.conversation_parts?.length || 0);
        
        // Check specific email parts to see if email_message_metadata is present
        if (conversation.conversation_parts?.conversation_parts) {
            const part32842906801 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842906801');
            const part32842914590 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842914590');
            
            if (part32842906801) {
                console.log('=== PART 32842906801 (should be email) ===');
                console.log('Full part:', JSON.stringify(part32842906801, null, 2));
                console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842906801);
                console.log('email_message_metadata value:', part32842906801.email_message_metadata);
                console.log('All keys:', Object.keys(part32842906801));
            }
            
            if (part32842914590) {
                console.log('=== PART 32842914590 (should be email) ===');
                console.log('Full part:', JSON.stringify(part32842914590, null, 2));
                console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842914590);
                console.log('email_message_metadata value:', part32842914590.email_message_metadata);
                console.log('All keys:', Object.keys(part32842914590));
            }
        }
        console.log('========================');

        // Parse and display conversation messages
        displayConversationMessages(conversation);

        // Extract and display all conversation attributes
        displayConversationAttributes(conversation);

        // Ensure chat view is active (it should already be)
        if (!isChatViewActive) {
            isChatViewActive = true;
            transcriptChatView.style.display = 'flex';
            if (transcriptTextView) transcriptTextView.style.display = 'none';
        }

    } catch (error) {
        console.error('Error loading conversation from Intercom:', error);
        
        // Try to parse database transcript as fallback
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - show error in chat view instead of falling back to text view
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                isChatViewActive = true;
            }
            
            // Show error message in chat container
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                    <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                    <p style="font-size: 0.4852rem; color: var(--text-secondary);">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: var(--text-muted); margin-top: 0.3234rem;">No database transcript available.</p>
                </div>
            `;
        }
    }
}

// Debug flag for showing part types (default: false - hidden from users)
function shouldShowPartTypes() {
    const debugFlag = localStorage.getItem('debug_show_part_types');
    return debugFlag === 'true';
}

// Get human-readable action label for part type
function getActionLabel(partType) {
    if (!partType) return '';
    const actionLabels = {
        'comment': 'Comment',
        'assignment': 'Assignment',
        'open': 'Opened',
        'close': 'Closed',
        'note': 'Note',
        'conversation_summary': 'Summary',
        'conversation_rating_changed': 'Rating Changed',
        'conversation_rating_remark_added': 'Rating Remark',
        'user_became_idle': 'User Idle',
        'fin_guidance_applied': 'Guidance Applied',
        'conversation_attribute_updated_by_admin': 'Attribute Updated',
        'attribute_collected': 'Attribute Collected'
    };
    return actionLabels[partType] || partType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Display conversation messages in chat interface
function displayConversationMessages(conversation) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    if (!chatMessagesContainer) {
        console.error('chatMessagesContainer not found');
        return;
    }
    
    // Ensure chat view is visible and text view is hidden
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    if (transcriptChatView && transcriptTextView) {
        transcriptChatView.style.display = 'flex';
        transcriptTextView.style.display = 'none';
    }
    
    // Helper function to generate avatar with initials
    function generateAvatar(name, type) {
        // Extract initials from name
        const getInitials = (name) => {
            if (!name || name === 'Unknown') return '?';
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        };
        
        const initials = getInitials(name);
        
        // Determine colors and gradients based on type
        let bgGradient, textColor, label, borderColor;
        if (type === 'user' || type === 'contact') {
            // Blue gradient for client
            bgGradient = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            textColor = '#ffffff';
            label = 'Client'; // Use "Client" label under avatar
            borderColor = '#2563eb';
        } else if (type === 'ai' || type === 'bot') {
            // Darker green gradient for AI
            bgGradient = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
            textColor = '#ffffff';
            label = 'AI';
            borderColor = '#166534';
        } else {
            // Green gradient for agent
            bgGradient = 'linear-gradient(135deg, #1A733E 0%, #14532d 100%)';
            textColor = '#ffffff';
            label = 'Agent';
            borderColor = '#14532d';
        }
        
        return {
            initials,
            bgGradient,
            textColor,
            label,
            borderColor
        };
    }

    const parts = conversation.conversation_parts?.conversation_parts || [];
    
    console.log('displayConversationMessages called with', parts.length, 'parts');
    
    // Update conversation heading with client name
    const transcriptHeading = document.querySelector('h3');
    if (transcriptHeading) {
        // Extract client name from conversation
        let clientName = 'Transcript';
        // Try to get client name from source.author
        if (conversation.source?.author?.name) {
            clientName = conversation.source.author.name;
        }
        // Try contacts
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.name) {
                clientName = contact.name;
            }
        }
        // Try to find first user/contact in conversation parts
        else if (parts.length > 0) {
            for (const part of parts) {
                if (part.author && (part.author.type === 'user' || part.author.type === 'contact')) {
                    if (part.author.name) {
                        clientName = part.author.name;
                        break;
                    }
                }
            }
        }
        
        // Update heading text (keep the icon)
        const icon = transcriptHeading.querySelector('svg');
        if (icon) {
            // Keep the SVG icon and replace "Transcript" with client name
            transcriptHeading.innerHTML = icon.outerHTML + ' ' + escapeHtml(clientName);
        } else {
            transcriptHeading.textContent = clientName;
        }
    }
    
    // Log all part types to see what we're getting
    const partTypes = parts.map(p => ({ id: p.id, type: p.part_type, hasEmailMeta: !!p.email_message_metadata, hasAttachments: (p.attachments || []).length > 0 }));
    console.log('Part types:', partTypes);
    
    if (parts.length === 0) {
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: var(--text-muted); font-size: 0.5659rem;">
                <p>No messages found in this conversation.</p>
            </div>
        `;
        return;
    }

    // Sort parts by created_at timestamp
    const sortedParts = [...parts].sort((a, b) => {
        const timeA = typeof a.created_at === 'number' ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at) : new Date(a.created_at).getTime();
        const timeB = typeof b.created_at === 'number' ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at) : new Date(b.created_at).getTime();
        return timeA - timeB;
    });

    // Clear container and remove empty state message
    chatMessagesContainer.innerHTML = '';
    chatMessagesContainer.style.gap = '0.3234rem';
    
    // Reset images array
    allConversationImages = [];

    // Track if we've already rendered rating cards to avoid duplicates
    let ratingCardsRendered = false;

    // Cache dark mode values once (outside the loop for performance)
    // Use try-catch to prevent errors from breaking message rendering
    let isDarkMode = false;
    let cachedTextSecondary = '#000000';
    let cachedGray100 = '#f3f4f6';
    let cachedBgWhite = '#ffffff';
    let cachedTextColor = '#374151';
    let cachedBorderLight = '#e5e7eb';
    
    try {
        isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
        const root = document.documentElement;
        if (isDarkMode) {
            cachedTextSecondary = getComputedStyle(root).getPropertyValue('--text-secondary').trim() || '#000000';
            cachedGray100 = getComputedStyle(root).getPropertyValue('--gray-100').trim() || '#f3f4f6';
            cachedBgWhite = getComputedStyle(root).getPropertyValue('--background-white').trim() || '#ffffff';
            cachedTextColor = getComputedStyle(root).getPropertyValue('--text-color').trim() || '#374151';
            cachedBorderLight = getComputedStyle(root).getPropertyValue('--border-light').trim() || '#e5e7eb';
        }
    } catch (e) {
        console.warn('Error getting dark mode values, using defaults:', e);
    }

    sortedParts.forEach(part => {
        const message = part.body || '';
        const author = part.author || {};
        const authorName = author.name || author.email || 'Unknown';
        const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
        const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
        
        // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
        let timestamp;
        if (typeof part.created_at === 'number') {
            // Unix timestamp in seconds - convert to milliseconds
            timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
        } else {
            timestamp = new Date(part.created_at);
        }
        
        // Format timestamp for display
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        // Calculate time ago for rating request
        const now = Math.floor(Date.now() / 1000);
        const partTimestamp = typeof part.created_at === 'number' ? part.created_at : timestamp.getTime() / 1000;
        const diff = now - partTimestamp;
        const days = Math.floor(diff / 86400);
        let timeAgo = 'Today';
        if (days === 1) {
            timeAgo = '1d';
        } else if (days > 1) {
            timeAgo = `${days}d`;
        }
        
        // Check if this is a conversation summary (should be displayed as chat bubble with note color)
        const isConversationSummary = partType === 'conversation_summary';
        
        if (isConversationSummary) {
            // Format the message body
            let messageData;
            try {
                messageData = formatMessageBody(message);
            } catch (e) {
                console.error('Error formatting message body for conversation summary:', e);
                messageData = { text: '', html: null, images: [] };
            }
            const formattedHtml = messageData?.html || message;
            
            // Render as right-aligned chat bubble with note-like color
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: flex-end;
                align-items: flex-end;
                margin: 0.4043rem 0;
                padding: 0 0.8086rem;
            `;
            
            // Light brown-yellow note color (like Intercom) but as chat bubble
            const noteBg = '#fef3c7'; // Light yellow/amber
            const noteText = '#78350f'; // Dark brown text
            const noteHeaderText = '#92400e'; // Slightly lighter brown for header
            const secondaryText = '#a16207'; // Amber for timestamp
            
            // Generate avatar for AI
            const avatar = generateAvatar(authorName, 'ai');
            
            messageDiv.innerHTML = `
                <div style="
                    background: ${noteBg};
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    padding: 0.4852rem 0.6469rem;
                    max-width: 70%;
                    position: relative;
                    margin-right: 0.3234rem;
                ">
                    <div style="
                        display: flex;
                        align-items: center;
                        gap: 0.3234rem;
                        margin-bottom: 0.2426rem;
                    ">
                        <span style="
                            color: ${noteHeaderText};
                            font-size: 0.4852rem;
                            font-weight: 600;
                        ">AI Summary</span>
                    </div>
                    <div style="
                        color: ${noteText};
                        font-size: 0.4447rem;
                        line-height: 1.6;
                        margin-bottom: 0.1617rem;
                    ">
                        ${formattedHtml || escapeHtml(message)}
                    </div>
                    <div style="
                        color: ${secondaryText};
                        font-size: 0.3639rem;
                        text-align: right;
                        margin-top: 0.1617rem;
                    ">${timeStr}  ${dateStr}</div>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; margin-bottom: 0.2426rem; margin-left: 0.3234rem; flex-shrink: 0; order: 3;">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: #1d1d1d;
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            `;
            
            chatMessagesContainer.appendChild(messageDiv);
            return; // Skip normal rendering
        }
        
        // Check if this is a rating request system message
        const isRatingRequest = part.body && 
            (part.body.includes('[Conversation Rating Request]') || 
             part.body.includes('Conversation Rating Request'));
        
        if (isRatingRequest && authorType === 'bot') {
            // Get customer name
            let customerName = 'Customer';
            if (conversation.source?.author?.name) {
                customerName = conversation.source.author.name;
            } else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
                const contact = conversation.contacts.contacts[0];
                if (contact.name) {
                    customerName = contact.name;
                }
            }
            
            // Render as system message bubble (like Intercom) - right-aligned like AI messages
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: flex-end;
                align-items: flex-end;
                margin: 0.4043rem 0;
                padding: 0 0.8086rem;
            `;
            
            const cardBg = '#2C3E50'; // Dark blue-grey like Intercom
            const textColor = '#ffffff';
            const secondaryText = isDarkMode ? '#9ca3af' : '#d1d5db';
            
            // Generate avatar for AI
            const avatar = generateAvatar(authorName, 'ai');
            
            messageDiv.innerHTML = `
                <div style="
                    background: ${cardBg};
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    padding: 0.4852rem 0.6469rem;
                    max-width: 70%;
                    position: relative;
                    margin-right: 0.3234rem;
                ">
                    <div style="
                        color: ${textColor};
                        font-size: 0.4852rem;
                        line-height: 1.4;
                        margin-bottom: 0.1617rem;
                    ">${escapeHtml(authorName)} asked ${escapeHtml(customerName)} to rate this conversation</div>
                    
                    <div style="
                        color: ${secondaryText};
                        font-size: 0.3639rem;
                        text-align: right;
                        margin-top: 0.1617rem;
                    ">${timeAgo}</div>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; margin-bottom: 0.2426rem; margin-left: 0.3234rem; flex-shrink: 0; order: 3;">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: ${isDarkMode ? '#6b46c1' : '#1d1d1d'};
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            `;
            
            chatMessagesContainer.appendChild(messageDiv);
            return; // Skip normal rendering
        }
        
        // Check if this is a rating-related part type (should be displayed as rating cards)
        const isRatingPart = partType === 'conversation_rating_changed' || 
                            partType === 'conversation_rating_remark_added';
        
        // Render rating cards if this is a rating part and we haven't rendered them yet
        // Only show ratings to the audited employee
        if (isRatingPart && !ratingCardsRendered && isCurrentUserAuditedEmployee()) {
            ratingCardsRendered = true; // Mark as rendered to avoid duplicates
            
            const rating = conversation.conversation_rating;
                if (rating) {
                    const ratingCardsHtml = renderRatingCards(rating, conversation, timestamp, isDarkMode);
                    if (ratingCardsHtml) {
                    const ratingDiv = document.createElement('div');
                    ratingDiv.style.cssText = `
                        width: 100%;
                        display: flex;
                        flex-direction: column;
                        align-items: flex-end;
                        margin: 0.4043rem 0;
                        padding: 0 0.8086rem;
                    `;
                        ratingDiv.innerHTML = ratingCardsHtml;
                        chatMessagesContainer.appendChild(ratingDiv);
                    }
                }
            return; // Skip normal rendering for rating parts
        }
        
        // Skip if we've already rendered rating cards and this is another rating part
        // Also skip rating parts if the current user is not the audited employee
        if (isRatingPart && (ratingCardsRendered || !isCurrentUserAuditedEmployee())) {
            return;
        }
        
        // Check if this is a system comment part type (should be displayed outside chat bubbles)
        const systemCommentTypes = [
            'user_became_idle',
            'close',
            'fin_guidance_applied',
            'conversation_attribute_updated_by_admin',
            'attribute_collected'
        ];
        const isSystemComment = systemCommentTypes.includes(partType);
        
        // If this is a system comment, render it differently (outside chat bubbles)
        if (isSystemComment) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0.4043rem 0;
                padding: 0 0.8086rem;
            `;
            
            // Format the message body
            let messageData;
            try {
                messageData = formatMessageBody(message);
            } catch (e) {
                console.error('Error formatting message body for system comment:', e);
                messageData = { text: '', html: null, images: [] };
            }
            const formattedText = messageData?.text || '';
            const formattedHtml = messageData?.html || null;
            
            // Create human-readable label for the part type
            const partTypeLabels = {
                'user_became_idle': 'User became idle',
                'close': 'Conversation closed',
                'fin_guidance_applied': 'Guidance applied',
                'conversation_attribute_updated_by_admin': 'Attribute updated by admin',
                'attribute_collected': 'Attribute collected'
            };
            const partTypeLabel = partTypeLabels[partType] || partType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Build the system comment content
            let commentContent = '';
            // Use text version for system comments to avoid HTML rendering issues
            if (formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}') {
                commentContent = formattedText;
            } else if (part.body && String(part.body).trim() !== '') {
                // Fallback: strip HTML tags from body and get plain text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = String(part.body);
                commentContent = tempDiv.textContent || tempDiv.innerText || '';
            }
            
            // Escape HTML for safe display
            if (commentContent) {
                const tempEscDiv = document.createElement('div');
                tempEscDiv.textContent = commentContent;
                commentContent = tempEscDiv.innerHTML;
            }
            
            messageDiv.innerHTML = `
                <div style="
                    background: #f3f4f6;
                    border: 0.0304rem solid #e5e7eb;
                    border-radius: 0.2426rem;
                    padding: 0.3234rem 0.4852rem;
                    max-width: 80%;
                    text-align: center;
                    font-size: 0.4447rem;
                    color: #000000;
                    line-height: 1.5;
                ">
                    <div style="
                        font-weight: 600;
                        color: #000000;
                        margin-bottom: 0.1213rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0405rem;
                        font-size: 0.4043rem;
                    ">${partTypeLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}</div>
                    ${commentContent ? `<div style="margin-top: 0.1617rem; color: #000000; font-size: 0.4447rem;">${commentContent}</div>` : ''}
                    <div style="
                        margin-top: 0.1617rem;
                        font-size: 0.3639rem;
                        color: #000000;
                        opacity: 0.8;
                    ">${timeStr}  ${dateStr}</div>
                </div>
            `;
            
            chatMessagesContainer.appendChild(messageDiv);
            return; // Skip normal message rendering for system comments
        }
        
        // Continue with normal message rendering for non-system-comment parts
        const isUser = authorType === 'user' || authorType === 'contact';
        const isAdmin = authorType === 'admin' || authorType === 'team';
        // Detect AI/Bot messages - be strict: only if explicitly bot type or has AI flags
        // Don't check name for "ai" as admins might be labeled as "AI" but are actually agents
        const isAI = authorType === 'bot' || 
                    author.from_ai_agent === true || 
                    author.is_ai_answer === true ||
                    (part.from_ai_agent === true) ||
                    (part.is_ai_answer === true);
        
        // Format the message body to check if it has content
        // This extracts images from HTML img tags and text-based [Image "..."] references
        const messageData = formatMessageBody(message);
        const formattedText = messageData.text;
        const formattedHtml = messageData.html || null; // HTML with inline images
        const images = messageData.images || [];
        
        // Check if this is an email interaction
        // email_message_metadata is either null (not an email) or an object with properties (is an email)
        // Note: typeof null === 'object' in JavaScript, so we must explicitly check for null
        const isEmail = !!(part.email_message_metadata && 
            part.email_message_metadata !== null && 
            typeof part.email_message_metadata === 'object' && 
            Object.keys(part.email_message_metadata).length > 0);
        const emailMetadata = isEmail ? part.email_message_metadata : {};
        
        // Extract attachments from attachments array (separate from body images)
        const attachments = part.attachments || [];
        
        // Extract image attachments - check multiple possible structures
        const attachmentImages = [];
        attachments.forEach(att => {
            // Check if it's an image attachment
            const isImage = (
                (att.type === 'upload' || att.type === 'image' || !att.type) &&
                (
                    (att.content_type && att.content_type.startsWith('image/')) ||
                    (att.url && /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i.test(att.url))
                ) &&
                att.url
            );
            
            if (isImage && att.url) {
                attachmentImages.push(att.url);
            }
        });
        
        // Combine body images and attachment images
        // Body images come first (they appear inline in text), then attachments
        const allImages = [...images, ...attachmentImages];
        
        // Add images to global array with their index for viewer navigation
        const imageStartIndex = allConversationImages.length;
        allImages.forEach((imgSrc, idx) => {
            allConversationImages.push({
                src: imgSrc,
                partIndex: sortedParts.indexOf(part),
                localIndex: idx
            });
        });
        
        // REMOVED: No longer skipping any parts - show ALL parts in the chatbox
        // Always display parts so users can see everything, even if empty
        
        // Check what content this part has (for display purposes)
        const hasBody = !!(part.body && String(part.body).trim() !== '');
        const hasText = !!(formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}');
        const hasHtml = !!formattedHtml;
        const hasImages = allImages.length > 0;
        const hasAttachments = attachments.length > 0;
        
        // Build content info badge to show in UI what this part contains
        // Show part_type only if debug flag is enabled
        let contentInfoBadge = '';
        const contentTypes = [];
        
        // Include part_type first (only if debug mode is enabled)
        if (shouldShowPartTypes() && partType) {
            contentTypes.push(`Type: ${partType}`);
        }
        
        // Then add content types
        if (hasText || hasHtml) contentTypes.push('Text');
        if (hasImages) contentTypes.push(`${allImages.length} Image${allImages.length > 1 ? 's' : ''}`);
        if (hasAttachments) contentTypes.push(`${attachments.length} Attachment${attachments.length > 1 ? 's' : ''}`);
        if (isEmail) contentTypes.push('Email');
        
        // Always show badge if we have part_type or any content
        if (contentTypes.length > 0 || (shouldShowPartTypes() && partType)) {
            contentInfoBadge = `<div style="
                font-size: 0.3639rem;
                color: ${isUser ? cachedTextSecondary : 'rgba(255,255,255,0.7)'};
                margin-bottom: 0.1617rem;
                padding: 0.1213rem 0.2426rem;
                background: ${isUser ? cachedGray100 : 'rgba(255,255,255,0.1)'};
                border-radius: 0.1617rem;
                display: inline-block;
            ">
                ${contentTypes.length > 0 ? contentTypes.join('  ') : (shouldShowPartTypes() && partType ? `Part Type: ${partType}` : 'Empty Part')}
            </div>`;
        }

        // Determine message type for avatar and styling
        // Important: Agents should be green, AI should be dark gray
        const messageType = isUser ? 'user' : (isAI ? 'ai' : 'agent');
        const avatar = generateAvatar(authorName, messageType);
        
        // Create message bubble container (avatar will be added in innerHTML)
        const messageDiv = document.createElement('div');
        
        // Colors: User = white/gray-100 (dark mode), Agent = #1A733E, AI = #1d1d1d (light mode) / #6b46c1 (purple in dark mode)
        const bubbleStyle = isUser 
            ? `
                background: ${isDarkMode ? cachedGray100 : 'white'};
                color: ${isDarkMode ? cachedTextColor : '#374151'};
                border: 0.0304rem solid ${cachedBorderLight};
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 100%;
                width: fit-content;
                margin-right: auto;
                margin-left: 0;
            `
            : isAI
            ? `
                background: ${isDarkMode ? '#6b46c1' : '#1d1d1d'};
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `;

        // Build email header if this is an email
        let emailHeaderHTML = '';
        if (isEmail) {
            const emailHeaders = emailMetadata.email_address_headers || [];
            const fromHeader = emailHeaders.find(h => h.type === 'from') || {};
            const toHeader = emailHeaders.find(h => h.type === 'to') || {};
            const replyToHeader = emailHeaders.find(h => h.type === 'reply_to') || {};
            const subject = emailMetadata.subject || 'No Subject';
            
            // Format email addresses
            const formatEmailAddress = (header) => {
                if (!header) return '';
                const name = header.name || '';
                const email = header.email_address || '';
                if (name && email) {
                    return `${escapeHtml(name)} <${escapeHtml(email)}>`;
                } else if (email) {
                    return escapeHtml(email);
                } else if (name) {
                    return escapeHtml(name);
                }
                return '';
            };
            
            const fromStr = formatEmailAddress(fromHeader);
            const toStr = formatEmailAddress(toHeader);
            const replyToStr = formatEmailAddress(replyToHeader);
            
            // For agent emails, use a more prominent blue background that stands out from green
            // For user emails, use a light blue background (adjust for dark mode)
            // For AI emails, use purplish background in dark mode to match chat bubble
            // Use cached values from outer scope
            const emailBgColor = isUser ? (isDarkMode ? cachedGray100 : '#e0f2fe') : (isAI ? (isDarkMode ? '#6b46c1' : '#2d2d2d') : '#1e40af');
            const emailBorderColor = isUser ? (isDarkMode ? cachedBorderLight : '#0284c7') : (isAI ? '#1d1d1d' : '#3b82f6');
            const emailIconColor = isUser ? (isDarkMode ? cachedTextSecondary : '#0284c7') : (isAI ? '#ffffff' : '#93c5fd');
            const emailTextColor = isUser ? (isDarkMode ? cachedTextColor : '#0369a1') : (isAI ? '#ffffff' : '#bfdbfe');
            const emailLabelColor = isUser ? (isDarkMode ? cachedTextSecondary : '#0369a1') : (isAI ? '#ffffff' : '#bfdbfe');
            const emailSubjectColor = isUser ? (isDarkMode ? cachedTextColor : '#0c4a6e') : (isAI ? '#ffffff' : '#dbeafe');
            const emailFieldColor = isUser ? (isDarkMode ? cachedTextSecondary : '#075985') : (isAI ? '#e5e7eb' : '#bfdbfe');
            const emailBorderBottomColor = isUser ? (isDarkMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(2, 132, 199, 0.2)') : (isAI ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.2)');
            
            emailHeaderHTML = `
                <div style="
                    background: ${emailBgColor};
                    border: 0.0606rem solid ${emailBorderColor};
                    padding: 0.4852rem 0.5659rem;
                    margin-bottom: 0.4043rem;
                    border-radius: 0.3234rem;
                    font-size: 0.4447rem;
                    box-shadow: 0 0.0405rem 0.1213rem rgba(0,0,0,0.1);
                    max-width: 100%;
                    box-sizing: border-box;
                    word-wrap: break-word;
                    overflow-wrap: break-word;
                ">
                    <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.2426rem; padding-bottom: 0.1617rem; border-bottom: 0.0304rem solid ${emailBorderBottomColor};">
                        <svg style="width: 0.6064rem; height: 0.6064rem; color: ${emailIconColor}; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                            <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                        </svg>
                        <span style="font-weight: 700; color: ${emailLabelColor}; text-transform: uppercase; font-size: 0.4043rem; letter-spacing: 0.0405rem;">Email</span>
                    </div>
                    ${subject ? `<div style="color: ${emailSubjectColor}; margin-bottom: 0.2426rem; font-weight: 600; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        <span style="color: ${emailFieldColor}; font-weight: 700;">Subject:</span> ${escapeHtml(subject)}
                    </div>` : ''}
                    <div style="color: ${emailSubjectColor}; font-size: 0.4043rem; line-height: 1.6; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        ${fromStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">From:</span> ${fromStr}</div>` : ''}
                        ${toStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">To:</span> ${toStr}</div>` : ''}
                        ${replyToStr ? `<div style="margin-top: 0.1213rem; font-size: 0.3639rem; opacity: 0.9; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">Reply-To:</span> ${replyToStr}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // Build attachments HTML (non-image attachments)
        let attachmentsHTML = '';
        const nonImageAttachments = attachments.filter(att => 
            att.type === 'upload' && 
            (!att.content_type || !att.content_type.startsWith('image/'))
        );
        if (nonImageAttachments.length > 0) {
            attachmentsHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-direction: column; gap: 0.1617rem;">';
            nonImageAttachments.forEach(att => {
                attachmentsHTML += `
                    <a 
                        href="${escapeHtml(att.url)}" 
                        target="_blank"
                        rel="noopener noreferrer"
                        style="
                            display: flex;
                            align-items: center;
                            gap: 0.2426rem;
                            padding: 0.2426rem 0.3234rem;
                            background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                            border-radius: 0.2426rem;
                            text-decoration: none;
                            color: ${isUser ? '#374151' : 'white'};
                            font-size: 0.4447rem;
                            transition: background 0.2s ease;
                        "
                        onmouseover="this.style.background='${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.15)'}'"
                        onmouseout="this.style.background='${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'}'"
                    >
                        <svg style="width: 0.4852rem; height: 0.4852rem; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"/>
                        </svg>
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(att.name || 'Attachment')}</span>
                        ${att.filesize ? `<span style="color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.7)'}; font-size: 0.3639rem;">${(att.filesize / 1024).toFixed(1)} KB</span>` : ''}
                    </a>
                `;
            });
            attachmentsHTML += '</div>';
        }

        // Build images HTML (for images that aren't inline in text)
        let imagesHTML = '';
        if (allImages.length > 0 && !formattedHtml) {
            imagesHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-wrap: wrap; gap: 0.3234rem;">';
            allImages.forEach((imgSrc, idx) => {
                const globalIndex = imageStartIndex + idx;
                const escapedSrc = escapeHtmlAttribute(imgSrc);
                imagesHTML += `<img src="${escapedSrc}" alt="Attachment ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" style="max-width: 200px; max-height: 200px; border-radius: 0.3234rem; cursor: pointer; object-fit: cover; border: 0.0304rem solid ${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0.1617rem 0.4852rem rgba(0,0,0,0.2)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'" onerror="console.error('Failed to load image:', this.src);" loading="lazy" />`;
            });
            imagesHTML += '</div>';
        }

        // Compact layout: timestamp next to sender name for both user and agent messages
        // For emails, make the border more prominent
        const emailBorderStyle = isEmail ? `border: 0.0808rem solid ${isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6')} !important; box-shadow: 0 0.0606rem 0.1617rem ${isUser ? 'rgba(2, 132, 199, 0.3)' : (isAI ? 'rgba(29, 29, 29, 0.3)' : 'rgba(59, 130, 246, 0.3)')} !important;` : '';
        
        // Avatar alignment: Client on left, Agent/AI on right
        const avatarAlign = isUser ? 'flex-start' : 'flex-end';
        const avatarMargin = isUser ? 'margin-right: 0.3234rem;' : 'margin-left: 0.3234rem;';
        const avatarOrder = isUser ? '1' : '3';
        
        // Avatar HTML - Client left, Agent/AI right
        // For AI, use the image avatar; for others, use gradient with initials
        const avatarHTML = isAI ? `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#000000' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        ` : `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    color: ${avatar.textColor};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.5257rem;
                    font-weight: 700;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1), inset 0 0.0203rem 0 rgba(255,255,255,0.2);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <span style="position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2);">${avatar.initials}</span>
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#000000' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        `;
        
        // Message container: Client avatar left, Agent/AI avatar right
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            margin-bottom: 0;
            width: 100%;
            justify-content: ${isUser ? 'flex-start' : 'flex-end'};
            gap: 0.3234rem;
        `;
        
        messageDiv.innerHTML = `
            ${isUser ? avatarHTML : ''}
            <div style="flex: 1; display: flex; flex-direction: column; align-items: ${isUser ? 'flex-start' : 'flex-end'}; order: ${isUser ? '2' : '1'}; min-width: 0; max-width: calc(100% - 3.5rem);">
                <div style="${bubbleStyle} padding: 0.4043rem 0.5659rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08); ${emailBorderStyle} word-wrap: break-word; overflow-wrap: break-word;">
                ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #000000;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #000000; white-space: nowrap;">${timeStr}  ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr}  ${dateStr}</span></div>`}
                ${emailHeaderHTML}
                ${contentInfoBadge}
                ${formattedHtml ? renderMessageWithInlineImages(formattedHtml, images, imageStartIndex, part.id, isUser) : 
                  (hasText ? 
                    `<div class="message-text-content" data-original-text="${escapeHtml(formattedText.replace(/"/g, '&quot;'))}" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#374151' : 'white'};">${formattedText}</div>` : 
                    (shouldShowPartTypes() && partType && partType.trim() !== '' ? 
                        `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                            <span style="text-transform: uppercase; font-weight: 600; letter-spacing: 0.0405rem; font-size: 0.4447rem; opacity: 0.8;">${escapeHtml(partType)}</span>
                            ${hasBody ? '<span style="margin-left: 0.2426rem; font-size: 0.4043rem; opacity: 0.6;">(body exists but no displayable content)</span>' : ''}
                        </div>` : 
                        (isAI && !hasBody && partType && partType.trim() !== '' ? 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                <span style="font-weight: 500; opacity: 0.9;">${escapeHtml(getActionLabel(partType))}</span>
                            </div>` : 
                            (hasBody || hasImages || hasAttachments || isEmail ? 
                                `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                    <span style="opacity: 0.7;">Part ID: ${part.id}</span>
                                    ${hasBody ? '<span style="margin-left: 0.2426rem;"> Has body (no displayable text)</span>' : ''}
                                </div>` : 
                                `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.5)'}; font-style: italic;">
                                    <span style="opacity: 0.6;">Empty part (ID: ${part.id})</span>
                                </div>`
                            )
                        )
                    )
                )}
                ${!formattedHtml && imagesHTML ? imagesHTML : ''}
                ${attachmentsHTML}
                </div>
            </div>
            ${!isUser ? avatarHTML : ''}
        `;

        chatMessagesContainer.appendChild(messageDiv);
    });

    // Scroll to bottom after a brief delay to ensure DOM is updated
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Language detection function - simple heuristic to detect non-English text
function detectLanguage(text) {
    if (!text || text.trim().length === 0) return 'en';
    
    // Remove HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';
    
    // Simple heuristic: check for common English patterns
    // Count English letters vs non-English characters
    const englishPattern = /[a-zA-Z]/g;
    const nonEnglishPattern = /[^\x00-\x7F]/g;
    
    const englishChars = (plainText.match(englishPattern) || []).length;
    const nonEnglishChars = (plainText.match(nonEnglishPattern) || []).length;
    const totalChars = plainText.replace(/\s/g, '').length;
    
    // If more than 30% non-ASCII characters, likely not English
    if (totalChars > 0 && (nonEnglishChars / totalChars) > 0.3) {
        return 'auto'; // Needs translation
    }
    
    // Check for common non-English language patterns
    const commonNonEnglishPatterns = [
        /[\u0600-\u06FF]/g, // Arabic
        /[\u4E00-\u9FFF]/g, // Chinese
        /[\u3040-\u309F\u30A0-\u30FF]/g, // Japanese
        /[\u0400-\u04FF]/g, // Cyrillic
        /[\u0590-\u05FF]/g, // Hebrew
        /[\u0E00-\u0E7F]/g, // Thai
    ];
    
    for (const pattern of commonNonEnglishPatterns) {
        if (pattern.test(plainText)) {
            return 'auto'; // Needs translation
        }
    }
    
    return 'en'; // Likely English
}

// Translate text using LibreTranslate API with retry logic
async function translateText(text, targetLang = 'en', retryCount = 0) {
    if (!text || text.trim().length === 0) return text;
    
    const maxRetries = 3;
    const baseDelay = 1000; // Start with 1 second delay
    
    try {
        // Use LibreTranslate public API
        const response = await fetch('https://libretranslate.com/translate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                q: text,
                source: 'auto',
                target: targetLang,
                format: 'text'
            })
        });
        
        // Handle rate limiting with exponential backoff
        if (response.status === 429) {
            if (retryCount < maxRetries) {
                const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 1s, 2s, 4s
                console.log(`Rate limited. Retrying in ${delay}ms... (attempt ${retryCount + 1}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return translateText(text, targetLang, retryCount + 1);
            } else {
                throw new Error('Rate limit exceeded. Please try again later.');
            }
        }
        
        // Handle bad requests (400) - skip this message
        if (response.status === 400) {
            console.warn('Bad request for translation, skipping:', text.substring(0, 50));
            return text; // Return original text
        }
        
        if (!response.ok) {
            throw new Error(`Translation API error: ${response.status}`);
        }
        
        const data = await response.json();
        return data.translatedText || text;
    } catch (error) {
        // If it's a rate limit error and we've exhausted retries, try fallback
        if (error.message && error.message.includes('Rate limit') && retryCount >= maxRetries) {
            console.log('Trying fallback translation API...');
            // Fallback: try MyMemory Translation API
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=auto|en`);
                const data = await response.json();
                if (data.responseData && data.responseData.translatedText) {
                    return data.responseData.translatedText;
                }
            } catch (fallbackError) {
                console.error('Fallback translation error:', fallbackError);
            }
        }
        
        // If error doesn't mention rate limit, log it but return original text
        if (!error.message || !error.message.includes('Rate limit')) {
            console.error('Translation error:', error);
        }
        
        return text; // Return original if translation fails
    }
}

// Main translation function
async function translateChatMessages() {
    // Feature is currently disabled
    const translateBtn = document.getElementById('translateChatBtn');
    if (translateBtn && translateBtn.disabled) {
        return;
    }
    
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    
    if (!chatMessagesContainer) {
        showNotification('Chat messages container not found', 'error');
        return;
    }
    
    // Get all message text elements
    const messageTextElements = chatMessagesContainer.querySelectorAll('.message-text-content');
    
    if (messageTextElements.length === 0) {
        showNotification('No messages to translate', 'info');
        return;
    }
    
    let translatedCount = 0;
    let skippedCount = 0;
    
    // Process messages sequentially to avoid rate limiting
    // Use longer delays for public API (500ms between requests)
    const delayBetweenRequests = 500;
    
    for (let i = 0; i < messageTextElements.length; i++) {
        const element = messageTextElements[i];
        const originalText = element.getAttribute('data-original-text');
        if (!originalText) continue;
        
        // Decode HTML entities to get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = originalText;
        const plainText = tempDiv.textContent || tempDiv.innerText || '';
        
        // Skip if text is too short or empty
        if (plainText.trim().length < 3) {
            skippedCount++;
            continue;
        }
        
        // Detect language
        const detectedLang = detectLanguage(plainText);
        
        if (detectedLang === 'en') {
            skippedCount++;
            continue; // Skip English messages
        }
        
        // Translate the text
        try {
            const translatedText = await translateText(plainText, 'en');
            
            // Only update if translation is different from original
            if (translatedText && translatedText.trim() !== plainText.trim() && translatedText !== plainText) {
                // Update the element with translated text (escape HTML for safety)
                element.innerHTML = escapeHtml(translatedText);
                translatedCount++;
            } else {
                skippedCount++;
            }
            
            // Delay between requests to avoid rate limiting (500ms)
            // Skip delay for last message
            if (i < messageTextElements.length - 1) {
                await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
            }
        } catch (error) {
            console.error('Error translating message:', error);
            skippedCount++;
            // If rate limited, add extra delay
            if (error.message && error.message.includes('Rate limit')) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
    
    // Show completion notification
    if (translatedCount > 0) {
        showNotification(`Translated ${translatedCount} message(s) to English`, 'success');
    } else if (skippedCount > 0) {
        showNotification('All messages are already in English', 'info');
    } else {
        showNotification('No messages found to translate', 'info');
    }
}

// Make translation function globally accessible
window.translateChatMessages = translateChatMessages;

// Format message body (handle HTML/plain text and extract images)
function formatMessageBody(body) {
    if (!body) return { text: '', images: [], html: null };
    
    // If body is an object, extract text
    if (typeof body === 'object') {
        // Handle empty objects
        if (Object.keys(body).length === 0) return { text: '', images: [], html: null };
        
        // Check for text content in various possible fields
        if (body.plaintext) {
            const text = String(body.plaintext).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.text) {
            const text = String(body.text).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.body) {
            return parseHtmlBody(String(body.body));
        }
        
        // Check for HTML content
        if (body.html) {
            return parseHtmlBody(String(body.html));
        }
        
        // If object has no text content, return empty
        // Don't stringify as that would just show "{}"
        return { text: '', images: [], html: null };
    }
    
    // Handle string body (which may contain HTML)
    return parseHtmlBody(String(body));
}

// Parse HTML body to extract text and images (preserve inline images)
// Handles both HTML <img> tags and text-based [Image "..."] references
function parseHtmlBody(htmlBody) {
    if (!htmlBody) return { text: '', images: [], html: '' };
    
    const htmlString = String(htmlBody);
    const images = [];
    let processedHtml = htmlString;
    
    // Step 1: Extract images from HTML <img> tags
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;
    
    const imgTags = tempDiv.querySelectorAll('img');
    let imageIndex = 0;
    
    imgTags.forEach((img) => {
        const src = img.getAttribute('src') || '';
        if (src) {
            // Decode HTML entities in URL (but preserve the original URL structure)
            let decodedSrc = src;
            // Only decode if it's clearly an HTML entity, not part of URL encoding
            if (src.includes('&amp;') && !src.includes('?')) {
                decodedSrc = src.replace(/&amp;/g, '&');
            }
            images.push(decodedSrc);
            
            // Replace img tag with a placeholder
            const placeholder = document.createTextNode(`__IMAGE_PLACEHOLDER_${imageIndex}__`);
            if (img.parentNode) {
                img.parentNode.replaceChild(placeholder, img);
            }
            imageIndex++;
        }
    });
    
    // Get HTML with placeholders from img tags
    processedHtml = tempDiv.innerHTML;
    
    // Step 2: Extract images from text-based [Image "..."] references
    // Pattern: [Image "URL"] or [Image 'URL'] or [Image URL]
    // Need to handle URLs with query parameters that might contain quotes
    // More robust pattern: [Image "..."], [Image '...'], or [Image ...]
    const imageReferencePattern = /\[Image\s+(?:"([^"]+)"|'([^']+)'|([^\]]+))\]/gi;
    let match;
    const textImageMatches = [];
    
    // Find all matches and their positions
    while ((match = imageReferencePattern.exec(htmlString)) !== null) {
        // match[1] = double-quoted URL, match[2] = single-quoted URL, match[3] = unquoted URL
        const imageUrl = match[1] || match[2] || match[3];
        const fullMatch = match[0];
        const matchIndex = match.index;
        
        if (imageUrl && imageUrl.trim() && !images.includes(imageUrl.trim())) {
            const trimmedUrl = imageUrl.trim();
            // Only add if not already found in HTML img tags
            textImageMatches.push({
                url: trimmedUrl,
                fullMatch: fullMatch,
                index: matchIndex,
                placeholderIndex: imageIndex
            });
            images.push(trimmedUrl);
            imageIndex++;
        }
    }
    
    // Replace text-based image references with placeholders (in reverse order to preserve indices)
    textImageMatches.reverse().forEach(match => {
        const placeholder = `__IMAGE_PLACEHOLDER_${match.placeholderIndex}__`;
        processedHtml = processedHtml.substring(0, match.index) + 
                      placeholder + 
                      processedHtml.substring(match.index + match.fullMatch.length);
    });
    
    // Step 3: Sanitize HTML using DOMPurify (security + clean HTML)
    if (typeof DOMPurify !== 'undefined') {
        processedHtml = DOMPurify.sanitize(processedHtml, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'b', 'i', 'u', 'a', 'ul', 'ol', 'li', 'code', 'pre', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
            ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
            ALLOW_DATA_ATTR: false,
            KEEP_CONTENT: true,
            RETURN_DOM: false,
            RETURN_DOM_FRAGMENT: false
        });
    }
    
    // Step 4: Extract plain text for fallback (remove placeholders)
    const tempDiv2 = document.createElement('div');
    tempDiv2.innerHTML = processedHtml;
    const plainText = tempDiv2.textContent || tempDiv2.innerText || '';
    const cleanedText = plainText.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '').trim();
    
    // Return HTML with placeholders, plain text, and images array
    return { 
        text: cleanedText, 
        images: images, 
        html: processedHtml // HTML with image placeholders, sanitized and preserving formatting
    };
}

// Escape HTML attribute value (for src attributes, preserve URL structure)
// Important: Only escape characters that would break HTML attributes
// Don't double-encode URL parameters (they're already properly encoded)
function escapeHtmlAttribute(value) {
    if (!value) return '';
    const str = String(value);
    
    // Only escape characters that would break the HTML attribute
    // Preserve URL structure including query parameters
    return str
        .replace(/&/g, '&amp;')  // Must escape & first
        .replace(/"/g, '&quot;')  // Escape quotes
        .replace(/'/g, '&#x27;')  // Escape single quotes
        .replace(/</g, '&lt;')    // Escape <
        .replace(/>/g, '&gt;');   // Escape >
    
    // Note: We don't escape spaces, slashes, or other URL characters
    // as they're already properly encoded in the URL
}

// Render message with inline images (replace placeholders with actual image elements)
function renderMessageWithInlineImages(htmlWithPlaceholders, images, imageStartIndex, messageId, isUser) {
    if (!htmlWithPlaceholders) return '';
    
    let renderedHtml = htmlWithPlaceholders;
    let replacedCount = 0;
    
    // Replace each image placeholder with an actual image element
    images.forEach((imgSrc, idx) => {
        const globalIndex = imageStartIndex + idx;
        const placeholder = `__IMAGE_PLACEHOLDER_${idx}__`;
        
        // Escape the image src for HTML attribute (preserve URL structure)
        // Only escape characters that would break the HTML attribute, preserve URL structure
        const escapedSrc = escapeHtmlAttribute(imgSrc);
        
        // Create image HTML with proper styling and click handler
        // Use proper attribute escaping for src, but don't double-encode URL parameters
        const imageHtml = `<img src="${escapedSrc}" alt="Image ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" onerror="console.error('Failed to load image:', this.src); this.style.display='none';" style="max-width: 100%; max-height: 20rem; border-radius: 0.3234rem; margin: 0.3234rem 0; cursor: pointer; display: block; box-shadow: 0 0.1213rem 0.2426rem rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0.2426rem 0.4852rem rgba(0,0,0,0.15)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0.1213rem 0.2426rem rgba(0,0,0,0.1)';" loading="lazy" />`;
        
        if (renderedHtml.includes(placeholder)) {
            renderedHtml = renderedHtml.replace(placeholder, imageHtml);
            replacedCount++;
        } else {
            console.warn(` Image placeholder ${placeholder} not found in HTML for message ${messageId}`);
        }
    });
    
    // Clean up any remaining placeholders (shouldn't happen, but just in case)
    const remainingPlaceholders = (renderedHtml.match(/__IMAGE_PLACEHOLDER_\d+__/g) || []).length;
    if (remainingPlaceholders > 0) {
        console.warn(` ${remainingPlaceholders} image placeholders not replaced in message ${messageId}`);
        renderedHtml = renderedHtml.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '');
    }
    
    // Add CSS class based on message type for styling
    const messageClass = isUser ? '' : 'agent-message';
    const textColor = isUser ? '#374151' : 'white';
    
    return `<div class="message-text-content ${messageClass}" data-message-id="${messageId}" style="font-size: 0.5257rem; line-height: 1.6; word-wrap: break-word; margin-top: 0; margin-bottom: 0; color: ${textColor};">
        ${renderedHtml}
    </div>`;
}

// Store all images from conversation for image viewer
let allConversationImages = [];
let currentImageIndex = 0;

// Open image viewer modal
window.openImageViewer = function(index) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    currentImageIndex = Math.max(0, Math.min(index, allConversationImages.length - 1));
    const modal = document.getElementById('imageViewerModal');
    const img = document.getElementById('imageViewerImg');
    const prevBtn = document.getElementById('imageViewerPrev');
    const nextBtn = document.getElementById('imageViewerNext');
    const counter = document.getElementById('imageViewerCounter');
    const closeBtn = document.getElementById('imageViewerClose');
    
    if (modal && img) {
        img.src = allConversationImages[currentImageIndex].src;
        img.style.display = 'block';
        
        // Update counter
        if (counter) {
            counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
        }
        
        // Show/hide navigation buttons
        if (prevBtn) {
            prevBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        if (nextBtn) {
            nextBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Focus on modal for keyboard navigation
        modal.focus();
    }
};

// Close image viewer modal
function closeImageViewer() {
    const modal = document.getElementById('imageViewerModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
}

// Navigate to previous image
function navigateImage(direction) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    if (direction === 'prev') {
        currentImageIndex = (currentImageIndex - 1 + allConversationImages.length) % allConversationImages.length;
    } else if (direction === 'next') {
        currentImageIndex = (currentImageIndex + 1) % allConversationImages.length;
    }
    
    const img = document.getElementById('imageViewerImg');
    const counter = document.getElementById('imageViewerCounter');
    
    if (img) {
        img.style.display = 'none';
        setTimeout(() => {
            img.src = allConversationImages[currentImageIndex].src;
            img.style.display = 'block';
        }, 150);
    }
    
    if (counter) {
        counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
    }
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * Render rating cards for conversation rating
 * @param {Object} rating - The conversation_rating object
 * @param {Object} conversation - The full conversation object
 * @param {Date} timestamp - The timestamp for the rating
 * @param {boolean} isDarkMode - Whether dark mode is enabled
 * @returns {string} HTML string for the rating cards
 */
function renderRatingCards(rating, conversation, timestamp, isDarkMode) {
    const ratingValue = rating.rating;
    const remark = rating.remark;
    
    // Get customer name
    let customerName = 'Customer';
    if (conversation.source?.author?.name) {
        customerName = conversation.source.author.name;
    } else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
        const contact = conversation.contacts.contacts[0];
        if (contact.name) {
            customerName = contact.name;
        }
    }
    
    // Calculate time ago
    const now = Math.floor(Date.now() / 1000);
    const ratingTimestamp = typeof rating.updated_at === 'number' ? rating.updated_at : timestamp.getTime() / 1000;
    const diff = now - ratingTimestamp;
    const days = Math.floor(diff / 86400);
    let timeAgo = 'Today';
    if (days === 1) {
        timeAgo = '1d';
    } else if (days > 1) {
        timeAgo = `${days}d`;
    }
    
    // Emoji map for ratings
    const emojiMap = {
        1: { emoji: '', label: 'Very Dissatisfied' },
        2: { emoji: '', label: 'Neutral' },
        3: { emoji: '', label: 'Satisfied' },
        4: { emoji: '', label: 'Very Satisfied' },
        5: { emoji: '', label: 'Excellent' }
    };
    
    let html = '';
    
    // Rating Card (Top) - only show if rating exists
    if (ratingValue) {
        const cardBg = isDarkMode ? '#1f2937' : '#f9fafb';
        const textColor = isDarkMode ? '#e5e7eb' : '#374151';
        const secondaryText = isDarkMode ? '#9ca3af' : '#6b7280';
        
        html += `
            <div class="rating-card" style="
                background: ${cardBg};
                border-radius: 4px;
                padding: 6px 8px;
                margin-bottom: 4px;
                width: 100%;
                max-width: 400px;
                text-align: center;
            ">
                <div style="
                    color: ${textColor};
                    font-size: 10px;
                    font-weight: 500;
                    margin-bottom: 4px;
                    line-height: 1.2;
                    text-align: center;
                ">${escapeHtml(customerName)} rated the conversation</div>
                
                <div class="rating-emojis" style="
                    display: flex;
                    gap: 3px;
                    align-items: center;
                    justify-content: center;
                    margin-bottom: 3px;
                ">
                    ${[1, 2, 3, 4, 5].map(r => {
                        const isSelected = r === parseInt(ratingValue, 10);
                        const emojiData = emojiMap[r] || { emoji: '', label: 'Unknown' };
                        return `
                            <span style="
                                font-size: 16px;
                                padding: 1px;
                                border-radius: 2px;
                                background: ${isSelected ? '#ffd700' : 'transparent'};
                                cursor: default;
                                display: inline-block;
                                line-height: 1;
                                opacity: ${isSelected ? '1' : '0.6'};
                            " title="${emojiData.label}">${emojiData.emoji}</span>
                        `;
                    }).join('')}
                </div>
                
                <div style="
                    color: ${secondaryText};
                    font-size: 9px;
                    line-height: 1;
                    text-align: center;
                ">${timeAgo}</div>
            </div>
        `;
    }
    
    // Feedback Card (Bottom) - only show if remark exists
    if (remark) {
        const cardBg = isDarkMode ? '#1f2937' : '#f9fafb';
        const textColor = isDarkMode ? '#e5e7eb' : '#374151';
        const secondaryText = isDarkMode ? '#9ca3af' : '#6b7280';
        const remarkTextColor = isDarkMode ? '#d1d5db' : '#4b5563';
        
        html += `
            <div class="feedback-card" style="
                background: ${cardBg};
                border-radius: 4px;
                padding: 6px 8px;
                width: 100%;
                max-width: 400px;
                text-align: center;
            ">
                <div style="
                    color: ${textColor};
                    font-size: 10px;
                    font-weight: 500;
                    margin-bottom: 4px;
                    line-height: 1.2;
                    text-align: center;
                ">Feedback -</div>
                
                <div style="
                    color: ${remarkTextColor};
                    font-size: 10px;
                    line-height: 1.4;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                    margin-bottom: 3px;
                    text-align: center;
                ">${escapeHtml(remark)}</div>
                
                <div style="
                    color: ${secondaryText};
                    font-size: 9px;
                    line-height: 1;
                    text-align: center;
                ">${timeAgo}</div>
            </div>
        `;
    }
    
    return html;
}

// Toggle conversation info grid
function toggleConversationInfoGrid() {
    const content = document.getElementById('conversationInfoGridContent');
    const icon = document.getElementById('toggleInfoGridIcon');
    if (!content || !icon) return;
    
    const isHidden = content.style.display === 'none';
    content.style.display = isHidden ? 'grid' : 'none';
    icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
}

// Make toggle function globally accessible
window.toggleConversationInfoGrid = toggleConversationInfoGrid;

// Display all conversation attributes in UI-friendly format
function displayConversationAttributes(conversation) {
    // Hide the old panels
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    if (chatPanel) chatPanel.style.display = 'none';
    if (textPanel) textPanel.style.display = 'none';
    
    // Show and populate the expanded info grid
    const infoGrid = document.getElementById('conversationInfoGrid');
    if (!infoGrid) return;
    
    const attributes = extractConversationAttributes(conversation);
    infoGrid.style.display = 'block';
    
    // Helper function to format value
    const formatValue = (key, value) => {
        if (value === null || value === undefined) return null;
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        
        // Handle URLs (for Web Link)
        if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
            const url = String(value);
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom </a>`;
            }
        }
        
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (value.length === 0) return null;
                return value.map(item => {
                    if (typeof item === 'object') {
                        return Object.values(item).filter(v => v).join(' - ');
                    }
                    return String(item);
                }).join(', ');
            }
            return JSON.stringify(value, null, 2);
        }
        return String(value);
    };
    
    // Helper function to get icon and color for a key
    const getIconAndColor = (key) => {
        const iconMap = {
            'State': { icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z', color: '#1A733E' },
            'Priority': { icon: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z', color: '#f59e0b' },
            'Total Messages': { icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z', color: '#3b82f6' },
            'Time to Admin Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Assignment': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to First Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Last Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Median Time to Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Author Email': { icon: 'M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z', color: '#ec4899' },
            'Assigned To': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#10b981' },
            'Created At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Updated At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Rating': { icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z', color: '#f97316' },
            'Tags': { icon: 'M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z', color: '#06b6d4' },
            'User Messages': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#3b82f6' },
            'Admin Messages': { icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z', color: '#10b981' },
            'Reopens Count': { icon: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15', color: '#f59e0b' },
            'Assignments Count': { icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2', color: '#8b5cf6' }
        };
        
        return iconMap[key] || { icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', color: '#6b7280' };
    };
    
    // Helper function to create copy button
    const createCopyButton = (value, fieldName) => {
        if (!value) return '';
        return `
            <button onclick="event.stopPropagation(); navigator.clipboard.writeText('${escapeHtml(String(value))}').then(() => showNotification('${fieldName} copied!', 'success')).catch(() => showNotification('Failed to copy', 'error')); return false;" 
                style="padding: 0.0808rem; background: rgba(26, 115, 62, 0.1); border: none; border-radius: 0.1617rem; cursor: pointer; transition: all 0.2s; margin-left: 0.1617rem;"
                onmouseover="this.style.background='rgba(26, 115, 62, 0.2)';" onmouseout="this.style.background='rgba(26, 115, 62, 0.1)';"
                title="Copy ${fieldName}">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.3234rem; height: 0.3234rem; color: #1A733E;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
            </button>
        `;
    };
    
    let html = '';
    const gridContainer = document.getElementById('conversationInfoGridContent');
    if (!gridContainer) return;
    
    // Display ALL attributes
    Object.keys(attributes).forEach(key => {
        const value = formatValue(key, attributes[key]);
        if (!value) return;
        
        const label = formatLabelForAttribute(key);
        const { icon, color } = getIconAndColor(key);
        const needsCopyButton = key === 'Author Email' || key === 'Custom: Account Number (MT4/MT5)' || key === 'Conversation ID';
        const copyBtn = needsCopyButton ? createCopyButton(attributes[key], label) : '';
        
        html += `
            <div style="background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; padding: 0.3234rem; box-shadow: 0 0.0203rem 0.0606rem rgba(0,0,0,0.05); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 0.0405rem 0.1213rem rgba(0,0,0,0.1)'; this.style.borderColor='#1A733E';" onmouseout="this.style.boxShadow='0 0.0203rem 0.0606rem rgba(0,0,0,0.05)'; this.style.borderColor='#e5e7eb';">
                <div style="display: flex; align-items: center; gap: 0.2425rem; margin-bottom: 0.1617rem;">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; color: ${color}; flex-shrink: 0;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}"></path>
                    </svg>
                    <span style="font-size: 0.3639rem; font-weight: 600; color: #000000; text-transform: uppercase; letter-spacing: 0.0092rem;">${escapeHtml(label)}</span>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <span style="font-size: 0.4447rem; font-weight: 600; color: #1f2937; word-break: break-word; flex: 1;">${key.toLowerCase().includes('link') ? value : escapeHtml(String(value))}</span>
                    ${copyBtn}
                </div>
            </div>
        `;
    });
    
    gridContainer.innerHTML = html;
}

// Helper function to format label (used in both functions)
function formatLabelForAttribute(label) {
    return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Extract all relevant conversation attributes from Intercom API response
function extractConversationAttributes(conversation) {
    const attributes = {};
    
    // Helper function to convert Unix timestamp to readable date
    const formatTimestamp = (timestamp) => {
        if (!timestamp) return null;
        const date = typeof timestamp === 'number' 
            ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
            : new Date(timestamp);
        if (isNaN(date.getTime())) return null;
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    };
    
    // Basic Information
    if (conversation.id) attributes['Conversation ID'] = conversation.id;
    if (conversation.type) attributes['Type'] = conversation.type;
    if (conversation.state) attributes['State'] = conversation.state;
    if (conversation.read !== undefined) attributes['Read'] = conversation.read;
    if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
    if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
    if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
    
    // Source Information
    if (conversation.source) {
        if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
        if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
        if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
        if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
        
        // Author (who initiated)
        if (conversation.source.author) {
            const author = conversation.source.author;
            if (author.type) attributes['Author Type'] = author.type;
            if (author.id) attributes['Author ID'] = author.id;
            if (author.name) attributes['Author Name'] = author.name;
            if (author.email) attributes['Author Email'] = author.email;
        }
        
        // Owner (assigned to)
        if (conversation.source.owner) {
            const owner = conversation.source.owner;
            if (owner.type) attributes['Owner Type'] = owner.type;
            if (owner.id) attributes['Owner ID'] = owner.id;
            if (owner.name) attributes['Assigned To'] = owner.name;
            if (owner.email) attributes['Owner Email'] = owner.email;
        }
    }
    
    // Statistics
    if (conversation.statistics) {
        const stats = conversation.statistics;
        if (stats.time_to_assignment) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
        if (stats.time_to_admin_reply) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
        if (stats.time_to_first_close) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
        if (stats.time_to_last_close) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
        if (stats.median_time_to_reply) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
        if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
        if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
        if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
        if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
        if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
        if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
    }
    
    // Tags
    if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
        attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
    }
    
    // Teammates (participating admins)
    if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
        attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
            teammate.name || teammate.email || teammate.id
        ).join(', ');
    }
    
    // Contacts (users involved)
    if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
        const contacts = conversation.contacts.contacts.map(contact => {
            const parts = [];
            if (contact.name) parts.push(contact.name);
            if (contact.email) parts.push(contact.email);
            return parts.length > 0 ? parts.join(' - ') : contact.id;
        });
        attributes['Contacts'] = contacts.join(', ');
    }
    
    // Conversation Parts Summary
    if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
        const parts = conversation.conversation_parts.conversation_parts;
        attributes['Total Messages'] = parts.length;
    }
    
    // Custom Attributes (if present)
    if (conversation.source && conversation.source.custom && conversation.source.custom.length > 0) {
        conversation.source.custom.forEach(attr => {
            if (attr.value !== null && attr.value !== undefined && attr.value !== '') {
                attributes[attr.name || 'Custom Attribute'] = attr.value;
            }
        });
    }
    
    return attributes;
}

// Parse plain text transcript and render as chat bubbles (fallback if Intercom fetch fails)
function parseTranscriptToChat(transcriptText, interactionDate) {
    const chatContainer = document.getElementById('chatMessagesContainer');
    if (!chatContainer) return;
    
    if (!transcriptText || !transcriptText.trim()) {
        chatContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: var(--text-muted); font-size: 0.5659rem;">
                <p>No transcript available</p>
            </div>
        `;
        return;
    }
    
    // Clear container
    chatContainer.innerHTML = '';
    
    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Parse transcript - try to detect user/agent messages
    // Common patterns:
    // - "User:" or "Customer:" at start of line
    // - "Agent:" or employee name at start of line
    // - Lines with timestamps
    // - Blank lines as separators
    
    const lines = transcriptText.split('\n').filter(line => line.trim());
    const messages = [];
    let currentMessage = null;
    
    // Use interaction date as base for timestamps
    const baseDate = interactionDate ? new Date(interactionDate) : new Date();
    
    // Build agent pattern with employee name if available
    const employeeName = currentAudit?.employeeName || '';
    const agentPatternStr = employeeName 
        ? `^(?:Agent|Support|Representative|${employeeName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}):\\s*(.*)`
        : '^(?:Agent|Support|Representative):\\s*(.*)';
    const agentPattern = new RegExp(agentPatternStr, 'i');
    
    lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
            // Empty line - end current message if exists
            if (currentMessage) {
                messages.push(currentMessage);
                currentMessage = null;
            }
            return;
        }
        
        // Try to detect message patterns
        const userPattern = /^(?:User|Customer|Client):\s*(.*)/i;
        const timestampPattern = /^(\d{1,2}[:\.]\d{2}(?:\s*[AP]M)?|\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/i;
        
        const userMatch = trimmedLine.match(userPattern);
        const agentMatch = trimmedLine.match(agentPattern);
        const timestampMatch = trimmedLine.match(timestampPattern);
        
        if (userMatch) {
            // Start new user message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: userMatch[1].trim(),
                isUser: true,
                author: 'User',
                timestamp: baseDate
            };
        } else if (agentMatch) {
            // Start new agent message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: agentMatch[1].trim(),
                isUser: false,
                author: currentAudit?.employeeName || 'Agent',
                timestamp: baseDate
            };
        } else if (timestampMatch && currentMessage) {
            // Timestamp found at start of line - could be new message or continuation
            // If timestamp is followed by text, it might be a new message
            const afterTimestamp = trimmedLine.substring(timestampMatch[0].length).trim();
            if (afterTimestamp && afterTimestamp.length > 5) {
                // Has substantial content after timestamp - likely new message
                if (currentMessage) messages.push(currentMessage);
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: afterTimestamp,
                    isUser: lastMessage ? !lastMessage.isUser : true,
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            } else {
                // Just timestamp, continue current message
                currentMessage.text += ' ' + trimmedLine;
            }
        } else {
            // Continue current message or start new one if none exists
            if (currentMessage) {
                // Check if line looks like a new speaker (common patterns)
                const looksLikeNewSpeaker = /^[-]\s/.test(trimmedLine) || 
                                           /^\[/.test(trimmedLine) ||
                                           trimmedLine.length < 20 && /^[A-Z][a-z]+:/.test(trimmedLine);
                
                if (looksLikeNewSpeaker && currentMessage.text.length > 50) {
                    // End current message and start new one
                    messages.push(currentMessage);
                    const lastMessage = messages[messages.length - 1];
                    currentMessage = {
                        text: trimmedLine.replace(/^[-]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                        isUser: lastMessage ? !lastMessage.isUser : true,
                        author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                        timestamp: baseDate
                    };
                } else {
                    currentMessage.text += (currentMessage.text ? '\n' : '') + trimmedLine;
                }
            } else {
                // Try to guess based on context - if previous message was user, this might be agent
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: trimmedLine.replace(/^[-]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                    isUser: lastMessage ? !lastMessage.isUser : true, // Alternate or default to user
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            }
        }
        
        // Set timestamp for new messages
        if (currentMessage && (!currentMessage.timestamp || currentMessage.timestamp.getTime() === baseDate.getTime())) {
            currentMessage.timestamp = new Date(baseDate.getTime() + messages.length * 60000);
        }
    });
    
    // Add last message
    if (currentMessage) {
        messages.push(currentMessage);
    }
    
    // If no structured messages found, treat entire transcript as single message
    if (messages.length === 0) {
        messages.push({
            text: transcriptText,
            isUser: true,
            author: 'User',
            timestamp: baseDate
        });
    }
    
    // Render messages as chat bubbles
    messages.forEach((msg, index) => {
        const timeStr = msg.timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = msg.timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-bottom: 0.3234rem;
            align-items: ${msg.isUser ? 'flex-start' : 'flex-end'};
            width: 100%;
            min-width: 0;
            box-sizing: border-box;
        `;
        
        const bubbleStyle = msg.isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 75%;
                margin-right: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 75%;
                margin-left: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `;
        
        messageDiv.innerHTML = `
            <div style="${bubbleStyle} padding: 0.3234rem 0.4852rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08);">
                ${msg.isUser 
                    ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #000000;">User</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #000000; white-space: nowrap;">${timeStr}  ${dateStr}</span></div>` 
                    : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(msg.author)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr}  ${dateStr}</span></div>`}
                <div style="font-size: 0.5257rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%; box-sizing: border-box;">${escapeHtml(msg.text)}</div>
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
    });
    
    // Scroll to bottom
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Initialize resizable splitter
function initializeSplitter() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditMainContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        let startX = 0;
        let startLeftWidth = 0;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startLeftWidth = leftColumn.offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const containerWidth = containerRect.width;
            
            // Calculate new width based on delta
            let newLeftWidth = startLeftWidth + deltaX;
            
            // Convert to percentage with constraints
            let leftPercentage = (newLeftWidth / containerWidth) * 100;
            leftPercentage = Math.max(25, Math.min(75, leftPercentage));
            
            // Apply width and update right column
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('auditViewSplitterPosition', leftPercentage.toString());
            } catch (err) {
                // Ignore localStorage errors
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Restore saved position from localStorage
        try {
            const savedPosition = localStorage.getItem('auditViewSplitterPosition');
            if (savedPosition) {
                const percentage = parseFloat(savedPosition);
                if (!isNaN(percentage) && percentage >= 25 && percentage <= 75) {
                    leftColumn.style.width = percentage + '%';
                    leftColumn.style.flex = '0 0 ' + percentage + '%';
                }
            }
        } catch (err) {
            // Ignore localStorage errors
        }
    }
}

// Toggle reversal form visibility
function toggleReversalForm() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only submit reversal requests for audits assigned to you.');
        return;
    }
    
    const formContainer = document.getElementById('reversalFormContainer');
    const auditContentDiv = document.getElementById('auditContent');
    
    if (!formContainer) {
        console.error('Reversal form container not found');
        return;
    }
    
    if (!auditContentDiv) {
        console.error('Audit content div not found');
        return;
    }
    
    // Ensure form container is in the DOM (might have been removed during re-render)
    if (!formContainer.parentElement) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection) {
            buttonsSection.parentElement.insertBefore(formContainer, buttonsSection);
        } else {
            auditContentDiv.appendChild(formContainer);
        }
    }
    
    if (formContainer.style.display === 'none' || !formContainer.style.display) {
        formContainer.style.display = 'block';
        
        // Move form container to be before the action buttons if not already in auditContent
        if (auditContentDiv && formContainer.parentElement !== auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection) {
                buttonsSection.parentElement.insertBefore(formContainer, buttonsSection);
            } else {
                auditContentDiv.appendChild(formContainer);
            }
        }
        
        // Comments are automatically collected during form submission
        
        formContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } else {
        formContainer.style.display = 'none';
    }
}

// Make toggleReversalForm globally accessible
window.toggleReversalForm = toggleReversalForm;

// Refresh audit data from database to get latest comments
async function refreshAuditData() {
    if (!currentAudit || !currentTableName) {
        return;
    }
    
    try {
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .select('parameter_comments')
            .eq('id', currentAudit.id)
            .single();
        
        if (error) throw error;
        
        if (data && data.parameter_comments) {
            // Update parameter comments in currentAudit
            currentAudit.parameterComments = data.parameter_comments;
            currentAudit.parameter_comments = data.parameter_comments;
            console.log('Refreshed parameter comments from database:', data.parameter_comments);
        }
    } catch (error) {
        console.error('Error refreshing audit data:', error);
        // Don't throw - just log the error
    }
}

// Populate parameters with comments (compact display)
function populateParametersWithComments() {
    const container = document.getElementById('parametersWithCommentsContainer');
    const noCommentsMsg = document.getElementById('noCommentsMessage');
    
    if (!container) return;
    
    if (currentErrorFields.length === 0) {
        container.innerHTML = '<p style="margin: 0; font-size: 0.5625rem; color: #000000; font-family: \'Poppins\', sans-serif;">No parameters available</p>';
        return;
    }
    
    // Get parameter comments from database
    let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    
    // Also check inline comment inputs in the DOM (real-time fallback)
    const inlineComments = {};
    currentErrorFields.forEach(field => {
        const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
        const comments = [];
        commentInputs.forEach(input => {
            if (input.value && input.value.trim()) {
                comments.push(input.value.trim());
            }
        });
        if (comments.length > 0) {
            inlineComments[field.key] = { comments: comments };
        }
    });
    
    // Merge inline comments (takes precedence)
    parameterComments = { ...parameterComments, ...inlineComments };
    
    // Filter only parameters that have comments (check both formats)
    const parametersWithComments = currentErrorFields.filter(field => {
        const fieldComment = parameterComments[field.key];
        if (!fieldComment) return false;
        
        // Check for single comment format: {comment: "text"}
        if (fieldComment.comment && fieldComment.comment.trim()) {
            return true;
        }
        
        // Check for array format: {comments: ["text1", "text2"]}
        if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            return fieldComment.comments.some(c => c && c.trim());
        }
        
        return false;
    });
    
    if (parametersWithComments.length === 0) {
        container.style.display = 'none';
        if (noCommentsMsg) {
            noCommentsMsg.style.display = 'block';
        }
        return;
    }
    
    if (noCommentsMsg) {
        noCommentsMsg.style.display = 'none';
    }
    container.style.display = 'block';
    
    // Create compact list of parameters with comments
    const commentsHtml = parametersWithComments.map(field => {
        const fieldComment = parameterComments[field.key];
        let commentText = '';
        
        // Get comment text (handle both formats)
        if (fieldComment.comment && fieldComment.comment.trim()) {
            commentText = fieldComment.comment.trim();
        } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            // Join all comments with newlines, filter out empty ones, trim each comment, then trim the result
            commentText = fieldComment.comments
                .filter(c => c && c.trim())
                .map(c => c.trim())
                .join('\n')
                .trim();
        }
        
        // Ensure commentText is trimmed to remove leading/trailing whitespace
        commentText = commentText ? commentText.trim() : '';
        
        return `
                <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                    <div style="font-size: 0.6094rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(field.label)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(commentText)}
                    </div>
                </div>
            `;
    }).join('');
    
    container.innerHTML = commentsHtml;
}

// Handle close button click - check acknowledgement before closing
async function handleCloseButtonClick() {
    const canNavigate = await handleCloseAuditView();
    if (canNavigate) {
        window.location.href = 'audit-reports.html';
    }
}

// Make handleCloseButtonClick globally accessible
window.handleCloseButtonClick = handleCloseButtonClick;

// Show parameter comment modal
function showParameterCommentModal(fieldId, fieldLabel, auditorFeedback) {
    if (!isCurrentUserAuditedEmployee()) {
        alert('Only the audited employee can add comments.');
        return;
    }
    
    // Get existing comment for this parameter
    const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    const existingComment = parameterComments[fieldId] || null;
    const hasComment = existingComment && existingComment.comment && existingComment.comment.trim();
    
    // Create modal overlay
    const modal = document.createElement('div');
    modal.id = 'parameterCommentModal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 1.125rem;';
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 0.375rem; padding: 1.125rem; max-width: 37.5rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.25rem 0.375rem rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <h3 style="font-size: 0.8438rem; font-weight: 700; color: #1f2937; margin: 0; font-family: 'Poppins', sans-serif;">
                    Add Your Comment - ${escapeHtml(fieldLabel)}
                </h3>
                <button onclick="closeParameterCommentModal()" style="background: none; border: none; font-size: 1.5rem; color: #000000; cursor: pointer; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; line-height: 1;"></button>
            </div>
            
            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9fafb; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.5625rem; font-weight: 600; color: #000000; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                    Auditor Feedback
                </div>
                <div style="font-size: 0.6562rem; color: #374151; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(auditorFeedback)}
                </div>
            </div>
            
            ${hasComment ? `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 0.2812rem; border: 0.0352rem solid #bae6fd;">
                    <div style="font-size: 0.5625rem; font-weight: 600; color: #0369a1; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Your Previous Comment
                    </div>
                    <div style="font-size: 0.6562rem; color: #075985; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: 0.375rem;">
                        ${escapeHtml(existingComment.comment)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #0284c7; font-family: 'Poppins', sans-serif;">
                        ${existingComment.commented_at ? new Date(existingComment.commented_at).toLocaleString() : ''}
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 0.75rem;">
                <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    Your Comment / Justification
                </label>
                <textarea 
                    id="modalCommentInput_${fieldId}" 
                    placeholder="Provide your justification or response to the auditor's feedback..." 
                    rows="6"
                    style="width: 100%; padding: 0.75rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; background: white; box-sizing: border-box;"
                >${hasComment ? escapeHtml(existingComment.comment) : ''}</textarea>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem;">
                <button 
                    onclick="closeParameterCommentModal()" 
                    style="padding: 0.5625rem 1.125rem; background: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    Cancel
                </button>
                <button 
                    onclick="saveParameterCommentFromModal('${fieldId}')" 
                    style="padding: 0.5625rem 1.125rem; background: #1A733E; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    ${hasComment ? 'Update' : 'Save'} Comment
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus the textarea
    setTimeout(() => {
        const textarea = document.getElementById(`modalCommentInput_${fieldId}`);
        if (textarea) {
            textarea.focus();
        }
    }, 100);
    
    // Close on overlay click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeParameterCommentModal();
        }
    });
}

// Close parameter comment modal
function closeParameterCommentModal() {
    const modal = document.getElementById('parameterCommentModal');
    if (modal) {
        modal.remove();
    }
}

// Save parameter comment from modal (local only, not to database)
function saveParameterCommentFromModal(fieldId) {
    try {
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        const commentInput = document.getElementById(`modalCommentInput_${fieldId}`);
        if (!commentInput) {
            alert('Error: Comment input not found');
            return;
        }
        
        const commentText = commentInput.value.trim();
        if (!commentText) {
            alert('Please enter a comment before saving.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Update comment for this parameter (local only, not saved to database yet)
        const updatedComments = {
            ...currentComments,
            [fieldId]: {
                comment: commentText,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Update local audit object only (will be saved to database when reversal is submitted)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Close modal
        closeParameterCommentModal();
        
        // Update the inline comment input if it exists (to reflect the change in the table)
        const commentInputs = document.querySelectorAll(`input[data-param-key="${fieldId}"]`);
        if (commentInputs.length > 0) {
            commentInputs[0].value = commentText;
        }
        
        console.log('Comment stored locally (will be saved on reversal submission)');
        
    } catch (error) {
        console.error('Error storing parameter comment locally:', error);
        alert('Failed to store comment locally. Please try again.');
    }
}

// Toggle comments column visibility
function toggleCommentsColumn() {
    if (typeof window.showCommentsColumn === 'undefined') {
        window.showCommentsColumn = false;
    }
    window.showCommentsColumn = !window.showCommentsColumn;
    
    // Update the existing table header and rows without recreating the container
    if (currentAudit && currentErrorFields) {
        // Find the table header row within the Error Details section
        const errorDetailsSection = Array.from(document.querySelectorAll('div')).find(div => {
            const h3 = div.querySelector('h3');
            return h3 && h3.textContent && h3.textContent.includes('Error Details');
        });
        
        if (!errorDetailsSection) return;
        
        // Find header row within the error details section
        const headerRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            const text = div.textContent || '';
            return text.includes('Error Type') && text.includes('Points') && text.includes('Severity');
        });
        
        if (headerRows.length === 0) return;
        
        const header = headerRows[0];
        const showComments = window.showCommentsColumn;
        
        // Get employee first name for column header
        const employeeName = currentAudit.employeeName || currentAudit.employee_name || 'Employee';
        const firstName = employeeName.split(' ')[0] || employeeName;
        const commentColumnHeader = `${firstName}'s Comment`;
        
        // Check if user is audited employee
        const isAuditedEmployee = isCurrentUserAuditedEmployee();
        
        // Update grid columns
        if (showComments) {
            header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
            // Find the "+ Comment" header cell (last child) and replace with actual column header
            const lastHeader = header.lastElementChild;
            if (lastHeader) {
                lastHeader.innerHTML = escapeHtml(commentColumnHeader);
                lastHeader.style.cursor = 'default';
                lastHeader.style.color = '#1f2937';
                lastHeader.style.textDecoration = 'none';
                lastHeader.removeAttribute('onclick');
            } else if (header.children.length === 5) {
                // Add new header cell if it doesn't exist
                const commentHeaderCell = document.createElement('div');
                commentHeaderCell.textContent = commentColumnHeader;
                commentHeaderCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;';
                header.appendChild(commentHeaderCell);
            }
        } else {
            // When hiding comments, keep 6 columns if audited employee (to show + Comment button)
            if (isAuditedEmployee) {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                // Find the comment column header and replace with "+ Comment" button
                const lastHeader = header.lastElementChild;
                if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment"))) {
                    lastHeader.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    lastHeader.style.cursor = 'pointer';
                } else if (header.children.length === 5) {
                    // Add "+ Comment" button if it doesn't exist
                    const commentButtonCell = document.createElement('div');
                    commentButtonCell.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    commentButtonCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1A733E; text-transform: uppercase; letter-spacing: 0.05em;';
                    header.appendChild(commentButtonCell);
                }
            } else {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                // Remove comment column if not audited employee
                if (header.children.length === 6) {
                    const lastHeader = header.lastElementChild;
                    if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment") || lastHeader.textContent.includes("+ Comment"))) {
                        lastHeader.remove();
                    }
                }
            }
        }
        
        // Update all data rows within the error details section
        const dataRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            return div !== header && div.style.display === 'grid' && !div.textContent.includes('Error Type');
        });
        
        dataRows.forEach(row => {
            if (showComments) {
                // Add comment column if not present
                if (row.children.length === 5 || row.children.length === 6) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
                    // Remove existing comment column if present (to refresh it)
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.remove();
                        }
                    }
                    
                    // Get the field key from the row (first child text)
                    const firstCell = row.children[0];
                    const fieldLabel = firstCell.textContent.trim();
                    
                    // Find matching field
                    const field = currentErrorFields.find(f => f.label === fieldLabel);
                    if (field) {
                        // Get feedback data
                        const feedbackData = currentAudit[field.feedback];
                        let feedbackArray = [];
                        
                        if (feedbackData) {
                            if (typeof feedbackData === 'string') {
                                try {
                                    const parsed = JSON.parse(feedbackData);
                                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                } catch (e) {
                                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                }
                            } else if (Array.isArray(feedbackData)) {
                                feedbackArray = feedbackData;
                            }
                        }
                        feedbackArray = feedbackArray.filter(f => f && f.trim());
                        
                        // Get existing comments
                        const parameterComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
                        const existingComments = parameterComments[field.key] || {};
                        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
                        const isAuditedEmployee = isCurrentUserAuditedEmployee();
                        
                        // Check if reversal has been submitted (disable inputs if so)
                        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                        const hasReversalSubmitted = !!reversalRequestedAt;
                        
                        // Create comment column
                        const commentCell = document.createElement('div');
                        commentCell.style.cssText = 'font-size: 0.5659rem; color: #000000; font-family: Poppins, sans-serif; min-width: 0; overflow: hidden;';
                        
                        if (feedbackArray.length > 0) {
                            feedbackArray.forEach((feedbackText, index) => {
                                const existingComment = commentsArray[index] || '';
                                const commentInputId = `comment_${field.key}_${index}`;
                                const commentDiv = document.createElement('div');
                                commentDiv.style.marginBottom = index < feedbackArray.length - 1 ? '0.6469rem' : '0';
                                
                                if (feedbackArray.length > 1) {
                                    const label = document.createElement('div');
                                    label.textContent = `Comment ${index + 1}:`;
                                    label.style.cssText = 'font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: Poppins, sans-serif;';
                                    commentDiv.appendChild(label);
                                }
                                
                                // For auditors (non-audited employees) or after reversal submitted, show as read-only text
                                if (!isAuditedEmployee || hasReversalSubmitted) {
                                    if (existingComment && existingComment.trim()) {
                                        const textDiv = document.createElement('div');
                                        textDiv.textContent = existingComment;
                                        textDiv.style.cssText = 'font-size: 0.5659rem; color: #000000; font-family: Poppins, sans-serif; white-space: pre-wrap; line-height: 1.6;';
                                        commentDiv.appendChild(textDiv);
                                    } else {
                                        const dash = document.createElement('span');
                                        dash.textContent = '-';
                                        dash.style.cssText = 'color: #000000; font-style: italic; font-size: 0.5659rem;';
                                        commentDiv.appendChild(dash);
                                    }
                                } else {
                                    // For audited employees (before reversal), show input box
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.id = commentInputId;
                                    input.setAttribute('data-param-key', field.key);
                                    input.setAttribute('data-feedback-index', index);
                                    input.value = existingComment;
                                    input.placeholder = 'Enter your comment...';
                                    input.style.cssText = 'width: 100%; max-width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: Poppins, sans-serif; box-sizing: border-box;';
                                    // Save on both change and blur for real-time saving
                                    input.addEventListener('change', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    input.addEventListener('blur', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    commentDiv.appendChild(input);
                                }
                                
                                commentCell.appendChild(commentDiv);
                            });
                        } else {
                            const dash = document.createElement('span');
                            dash.textContent = '-';
                            dash.style.cssText = 'color: #000000; font-style: italic;';
                            commentCell.appendChild(dash);
                        }
                        
                        row.appendChild(commentCell);
                    }
                }
            } else {
                // When hiding comments, keep 6 columns if audited employee (to match header with + Comment button)
                // Remove comment inputs but keep empty 6th column for alignment
                if (isAuditedEmployee) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.innerHTML = '';
                        }
                    } else if (row.children.length === 5) {
                        // Add empty column for alignment with header
                        const emptyCell = document.createElement('div');
                        row.appendChild(emptyCell);
                    }
                } else {
                    // Remove comment column if not audited employee
                    if (row.children.length === 6) {
                        row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                        const lastCell = row.lastElementChild;
                        if (lastCell) {
                            lastCell.remove();
                        }
                    }
                }
            }
        });
    }
}

// Save parameter comment from input box (local only, not to database)
function saveParameterComment(paramKey, feedbackIndex, commentText) {
    try {
        // Ensure currentUserEmail is available
        if (!currentUserEmail) {
            currentUserEmail = getCurrentUserEmail();
        }
        
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        if (!currentUserEmail) {
            alert('Error: User email not available. Please refresh the page.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Get existing comments array for this parameter or create new structure
        const paramComments = currentComments[paramKey] || {};
        const commentsArray = paramComments.comments || (paramComments.comment ? [paramComments.comment] : []);
        
        // Ensure array is large enough
        while (commentsArray.length <= feedbackIndex) {
            commentsArray.push('');
        }
        
        // Update the comment at the specific index
        commentsArray[feedbackIndex] = commentText.trim();
        
        // Update comment for this parameter (local only, not saved to database yet)
        const updatedComments = {
            ...currentComments,
            [paramKey]: {
                comments: commentsArray,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Update local audit object only (will be saved to database when reversal is submitted)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        console.log('Comment stored locally (will be saved on reversal submission)');
        
    } catch (error) {
        console.error('Error storing parameter comment locally:', error);
    }
}

// Make functions globally accessible
window.showParameterCommentModal = showParameterCommentModal;
window.closeParameterCommentModal = closeParameterCommentModal;
window.saveParameterCommentFromModal = saveParameterCommentFromModal;
window.toggleCommentsColumn = toggleCommentsColumn;
window.saveParameterComment = saveParameterComment;

// Show Uber-style rating dialog with integrated feedback
async function showRatingDialog(initialRating = 0) {
    return new Promise((resolve) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'rating-overlay';
        
        // Create modal content
        const modal = document.createElement('div');
        modal.className = 'rating-modal';
        modal.style.maxWidth = '600px';
        modal.style.maxHeight = '90vh';
        modal.style.overflowY = 'auto';
        
        let selectedRating = initialRating || 0;
        
        // Define feedback options for different ratings
        const feedbackOptionsByRating = {
            1: [
                'Feedback was too harsh or unfair',
                'Errors identified were not accurate',
                'Lacked constructive suggestions',
                'Did not understand the context',
                'Poor communication of expectations',
                'Scoring criteria unclear'
            ],
            2: [
                'Feedback was too harsh or unfair',
                'Errors identified were not accurate',
                'Lacked constructive suggestions',
                'Did not understand the context',
                'Poor communication of expectations',
                'Scoring criteria unclear'
            ],
            3: [
                'Could provide more specific examples',
                'Feedback could be more constructive',
                'Some points were unclear',
                'Expected more detailed analysis',
                'Missing actionable recommendations',
                'Scoring could be explained better'
            ],
            4: [
                'Minor points could be improved',
                'Could include more examples',
                'Some feedback could be clearer',
                'Would appreciate more details',
                'Good overall, but room for improvement'
            ]
        };
        
        // Define compliment options for 5-star ratings (auditor-focused)
        const complimentOptions = [
            { 
                text: '6-Star', 
                icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z',
                color: '#fbbf24'
            },
            { 
                text: 'Clear Communication', 
                icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z',
                color: '#3b82f6'
            },
            { 
                text: 'Constructive Feedback', 
                icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
                color: '#10b981'
            },
            { 
                text: 'Professional Approach', 
                icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z',
                color: '#8b5cf6'
            },
            { 
                text: 'Thorough Analysis', 
                icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01',
                color: '#6366f1'
            },
            { 
                text: 'Fair Assessment', 
                icon: 'M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4',
                color: '#06b6d4'
            },
            { 
                text: 'Quick Response', 
                icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z',
                color: '#f59e0b'
            },
            { 
                text: 'Helpful Guidance', 
                icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                color: '#ec4899'
            }
        ];
        
        modal.innerHTML = `
            <div class="rating-title">Rate the Feedback</div>
            <div class="rating-subtitle">How helpful was the feedback provided in this audit?</div>
            
            <div class="star-rating" id="starRating">
                <span class="star" data-rating="1"></span>
                <span class="star" data-rating="2"></span>
                <span class="star" data-rating="3"></span>
                <span class="star" data-rating="4"></span>
                <span class="star" data-rating="5"></span>
            </div>
            
            <!-- Feedback Section (Hidden by default) -->
            <div id="feedbackSection" style="display: none; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 2px solid #e5e7eb;">
                <div class="feedback-title">Help us improve the feedback</div>
                <div class="feedback-subtitle">What could we improve about the feedback? Select all that apply (Optional)</div>
                
                <div id="feedbackOptions" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.375rem; margin-bottom: 0.5rem;">
                    <!-- Options will be populated dynamically -->
                </div>
                
                <div>
                    <textarea class="feedback-textarea" id="additionalComments" placeholder="Additional comments (optional)..." style="min-height: 40px; width: 100%;"></textarea>
                </div>
            </div>
            
            <!-- Compliment Section (Hidden by default, shown for 5-star ratings) -->
            <div id="complimentSection" style="display: none; margin-top: 0.375rem; padding-top: 0.375rem; border-top: 2px solid #e5e7eb; flex: 1; min-height: 0;">
                <div class="feedback-title" style="font-size: 0.6875rem; margin-bottom: 0.1875rem;">Give a compliment</div>
                <div class="feedback-subtitle" style="font-size: 0.5625rem; margin-bottom: 0.375rem;">Select all that apply (Optional)</div>
                
                <div id="complimentOptions" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.375rem; margin-bottom: 0;">
                    <!-- Compliments will be populated dynamically -->
                </div>
            </div>
            
            <div class="rating-buttons">
                <button class="rating-btn cancel" id="cancelRating">Cancel</button>
                <button class="rating-btn submit" id="submitRating">Submit Rating</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Use setTimeout to ensure DOM is fully rendered before attaching events
        setTimeout(() => {
            // Star click handlers
            const stars = modal.querySelectorAll('.star');
            const submitBtn = modal.querySelector('#submitRating');
            const feedbackSection = modal.querySelector('#feedbackSection');
            const feedbackOptionsContainer = modal.querySelector('#feedbackOptions');
            
            console.log('Stars found:', stars.length); // Debug log
            
            // Function to update feedback options based on rating
            function updateFeedbackOptions(rating) {
                const complimentSection = modal.querySelector('#complimentSection');
                const complimentOptionsContainer = modal.querySelector('#complimentOptions');
                
                if (rating >= 5) {
                    // Hide feedback section, show compliment section
                    feedbackSection.style.display = 'none';
                    complimentSection.style.display = 'block';
                    
                    // Add compact class to modal for better fit
                    modal.classList.add('compact');
                    
                    // Generate compliment buttons with SVG icons
                    const complimentsHtml = complimentOptions.map((compliment, index) => `
                        <button type="button" class="compliment-option-btn" data-option="${index}" data-value="${compliment.text}" style="padding: 0.5rem 0.25rem; border: 2px solid #e5e7eb; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; background: #f9fafb; color: #374151; font-size: 0.625rem; font-family: 'Poppins', sans-serif; text-align: center; font-weight: 500; display: flex; flex-direction: column; align-items: center; gap: 0.25rem; min-height: 3.25rem; justify-content: center;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: ${compliment.color}; flex-shrink: 0;">
                                <path d="${compliment.icon}"/>
                            </svg>
                            <span style="line-height: 1.2; word-break: break-word; font-size: 0.5625rem;">${compliment.text}</span>
                        </button>
                    `).join('');
                    
                    complimentOptionsContainer.innerHTML = complimentsHtml;
                    
                    // Add click handlers for compliment buttons
                    const complimentButtons = complimentOptionsContainer.querySelectorAll('.compliment-option-btn');
                    
                    complimentButtons.forEach((button) => {
                        button.addEventListener('click', () => {
                            const isSelected = button.classList.contains('selected');
                            
                            if (isSelected) {
                                // Deselect
                                button.classList.remove('selected');
                                button.style.background = '#f9fafb';
                                button.style.color = '#374151';
                                button.style.borderColor = '#e5e7eb';
                            } else {
                                // Select
                                button.classList.add('selected');
                                button.style.background = '#1A733E';
                                button.style.color = 'white';
                                button.style.borderColor = '#1A733E';
                            }
                        });
                        
                        button.addEventListener('mouseenter', () => {
                            if (!button.classList.contains('selected')) {
                                button.style.borderColor = '#1A733E';
                                button.style.background = '#f0fdf4';
                            }
                        });
                        
                        button.addEventListener('mouseleave', () => {
                            if (!button.classList.contains('selected')) {
                                button.style.borderColor = '#e5e7eb';
                                button.style.background = '#f9fafb';
                            }
                        });
                    });
                    
                    return;
                }
                
                // Show feedback section, hide compliment section
                feedbackSection.style.display = 'block';
                complimentSection.style.display = 'none';
                
                // Remove compact class when showing feedback
                modal.classList.remove('compact');
                
                // Get options for this rating
                const options = feedbackOptionsByRating[rating] || feedbackOptionsByRating[4];
                
                // Generate Uber-style button options (no checkboxes)
                const optionsHtml = options.map((option, index) => `
                    <button type="button" class="feedback-option-btn" data-option="${index}" data-value="${option}" style="padding: 0.375rem 0.5rem; border: 2px solid #e5e7eb; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; background: #f9fafb; color: #374151; font-size: 0.6875rem; font-family: 'Poppins', sans-serif; text-align: center; font-weight: 500;">
                        ${option}
                    </button>
                `).join('');
                
                feedbackOptionsContainer.innerHTML = optionsHtml;
                
                // Add click handlers for button-style options
                const optionButtons = feedbackOptionsContainer.querySelectorAll('.feedback-option-btn');
                
                optionButtons.forEach((button) => {
                    button.addEventListener('click', () => {
                        const isSelected = button.classList.contains('selected');
                        
                        if (isSelected) {
                            // Deselect
                            button.classList.remove('selected');
                            button.style.background = '#f9fafb';
                            button.style.color = '#374151';
                            button.style.borderColor = '#e5e7eb';
                        } else {
                            // Select
                            button.classList.add('selected');
                            button.style.background = '#1A733E';
                            button.style.color = 'white';
                            button.style.borderColor = '#1A733E';
                        }
                    });
                    
                    button.addEventListener('mouseenter', () => {
                        if (!button.classList.contains('selected')) {
                            button.style.borderColor = '#1A733E';
                            button.style.background = '#f0fdf4';
                        }
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        if (!button.classList.contains('selected')) {
                            button.style.borderColor = '#e5e7eb';
                            button.style.background = '#f9fafb';
                        }
                    });
                });
            }
            
            // If initial rating is provided, set it up (after updateFeedbackOptions is defined)
            if (initialRating > 0) {
                selectedRating = initialRating;
                stars.forEach((s, index) => {
                    if (index < initialRating) {
                        s.classList.add('active');
                        s.style.color = '#fbbf24';
                    } else {
                        s.classList.remove('active');
                        s.style.color = '#d1d5db';
                    }
                });
                updateFeedbackOptions(initialRating);
                submitBtn.classList.add('enabled');
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
            }
            
            stars.forEach((star, idx) => {
                // Add pointer cursor explicitly
                star.style.cursor = 'pointer';
                
                star.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    selectedRating = parseInt(star.dataset.rating);
                    console.log('Star clicked, rating:', selectedRating); // Debug log
                    
                    // Update star display
                    stars.forEach((s, index) => {
                        if (index < selectedRating) {
                            s.classList.add('active');
                            s.style.color = '#fbbf24';
                        } else {
                            s.classList.remove('active');
                            s.style.color = '#d1d5db';
                        }
                    });
                    
                    // Update feedback section based on rating
                    updateFeedbackOptions(selectedRating);
                    
                    // Enable submit button
                    submitBtn.classList.add('enabled');
                    submitBtn.style.opacity = '1';
                    submitBtn.style.cursor = 'pointer';
                }, true); // Use capture phase
                
                // Hover effect
                star.addEventListener('mouseenter', () => {
                    const rating = parseInt(star.dataset.rating);
                    stars.forEach((s, index) => {
                        if (index < rating) {
                            s.style.color = '#fbbf24';
                        }
                    });
                });
            });
            
            const starRatingContainer = modal.querySelector('#starRating');
            if (starRatingContainer) {
                starRatingContainer.addEventListener('mouseleave', () => {
                    stars.forEach((s, index) => {
                        if (index < selectedRating) {
                            s.style.color = '#fbbf24';
                        } else {
                            s.style.color = '#d1d5db';
                        }
                    });
                });
            }
            
            // Button handlers
            const cancelBtn = modal.querySelector('#cancelRating');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve({ rating: null, feedback: '' });
                });
            }
            
            if (submitBtn) {
                submitBtn.addEventListener('click', () => {
                    if (selectedRating > 0) {
                        let feedback = '';
                        const feedbackParts = [];
                        
                        // Collect feedback if rating < 5
                        if (selectedRating < 5) {
                            const selectedButtons = modal.querySelectorAll('.feedback-option-btn.selected');
                            const selectedOptions = Array.from(selectedButtons)
                                .map(btn => btn.dataset.value);
                            
                            // Add selected options as comma-separated values
                            if (selectedOptions.length > 0) {
                                feedbackParts.push(...selectedOptions);
                            }
                            
                            const additionalComments = modal.querySelector('#additionalComments');
                            const additionalText = additionalComments ? additionalComments.value.trim() : '';
                            
                            // Add additional comments if provided
                            if (additionalText) {
                                feedbackParts.push(additionalText);
                            }
                        } else if (selectedRating >= 5) {
                            // Collect compliments if rating is 5 stars
                            const selectedCompliments = modal.querySelectorAll('.compliment-option-btn.selected');
                            const complimentValues = Array.from(selectedCompliments)
                                .map(btn => btn.dataset.value);
                            
                            // Add compliments as comma-separated values
                            if (complimentValues.length > 0) {
                                feedbackParts.push(...complimentValues);
                            }
                        }
                        
                        // Join all feedback parts with comma and space for data-friendly CSV format
                        feedback = feedbackParts.join(', ');
                        
                        console.log('Submitting - Rating:', selectedRating, 'Feedback:', feedback);
                        document.body.removeChild(overlay);
                        resolve({ rating: selectedRating, feedback: feedback });
                    }
                });
            }
            
            // ESC key to cancel
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', escHandler);
                    resolve({ rating: null, feedback: '' });
                }
            };
            document.addEventListener('keydown', escHandler);
        }, 50); // Small delay to ensure DOM is ready
    });
}

// Acknowledge audit
async function acknowledgeAudit() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only acknowledge audits assigned to you.');
        return;
    }
    
    // Wait for confirmation dialog to be available
    if (!window.confirmationDialog) {
        // Wait a bit for it to initialize
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!window.confirmationDialog) {
            alert('Error: Confirmation dialog not available. Please refresh the page.');
            return;
        }
    }
    
    // Step 1: Initial acknowledgment confirmation
    const confirmResult = await window.confirmationDialog.show({
        title: 'Acknowledge Audit',
        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
        confirmText: 'Acknowledge',
        cancelText: 'Cancel'
    });
    
    if (!confirmResult) return;
    
    // Step 2: Calculate total errors to determine if rating system should be shown
    let totalErrorsCount = 0;
    if (currentAudit && currentErrorFields && currentErrorFields.length > 0) {
        currentErrorFields.forEach(field => {
            const count = currentAudit[field.key] ? parseInt(currentAudit[field.key]) : 0;
            // Only count error parameters (not achievements/bonuses) in total
            if (field.parameter_type === 'error' || !field.parameter_type) {
                totalErrorsCount += count;
            }
        });
    }
    
    // Step 3: Show rating dialog (Uber-style) with integrated feedback
    // Show rating dialog if rating system is enabled and no rating exists yet
    let rating = null;
    let feedback = null;
    
    if (ENABLE_RATING_SYSTEM) {
        // Check if rating already exists - prevent editing
        const existingRating = currentAudit.audit_rating || 0;
        if (existingRating > 0) {
            // Rating already exists, skip rating dialog
            console.log('Rating already exists, skipping rating dialog');
        } else {
            const ratingResult = await showRatingDialog();
            
            if (ratingResult.rating === null) return; // User cancelled rating
            
            rating = ratingResult.rating;
            feedback = ratingResult.feedback;
        }
    }
    
    // Step 4: Save acknowledgment and rating to database
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not available');
        return;
    }
    
    try {
        // Record acknowledgment and rating in the database
        const acknowledgementTime = new Date().toISOString();
        const updateData = {
            acknowledgement_status: 'Acknowledged',
            acknowledgement_status_updated_at: acknowledgementTime
        };
        
        // Only include rating fields if rating was collected (errors were detected)
        if (rating !== null) {
            updateData.audit_rating = rating;
            updateData.audit_rating_feedback = feedback || null;
            updateData.audit_rated_at = acknowledgementTime;
        }
        
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update(updateData)
            .eq('id', currentAudit.id)
            .select();
        
        if (error) throw error;
        
        // Show success message
        if (window.confirmationDialog) {
            const successMessage = rating !== null 
                ? ` Audit acknowledged and feedback rated ${rating} star${rating !== 1 ? 's' : ''}. Thank you for your input!`
                : ' Audit acknowledged. Thank you for your confirmation.';
            await window.confirmationDialog.show({
                title: 'Success',
                message: successMessage,
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            const successMessage = rating !== null 
                ? ` Audit acknowledged and feedback rated ${rating} star${rating !== 1 ? 's' : ''}. Thank you for your input!`
                : ' Audit acknowledged. Thank you for your confirmation.';
            alert(successMessage);
        }
        
        // Reload audit data to reflect changes
        loadAuditFromURL();
        
    } catch (error) {
        console.error('Error acknowledging audit:', error);
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to record acknowledgment and rating. Please try again.',
                confirmText: 'OK',
                type: 'error'
            });
        } else {
            alert('Failed to record acknowledgment and rating. Please try again.');
        }
    }
}

// Setup footer rating star hover and click effects
function setupFooterRatingHover() {
    const footerRatingContainer = document.getElementById('footerRatingContainer');
    if (!footerRatingContainer) return;
    
    const stars = footerRatingContainer.querySelectorAll('.footer-star');
    if (stars.length === 0) return;
    
    // Get current rating and check if rating already exists
    const starRatingContainer = footerRatingContainer.querySelector('#footerRatingStars');
    const currentRating = parseInt(starRatingContainer?.dataset.rating || '0');
    const hasRating = starRatingContainer?.dataset.hasRating === 'true';
    
    // Check if footer is acknowledged (green) or not (gray)
    const footerBar = document.getElementById('footerBar');
    const isAcknowledged = footerBar && (footerBar.style.backgroundColor.includes('rgb(6, 95, 70)') || footerBar.style.backgroundColor.includes('#065f46'));
    
    // Default colors based on footer state
    const defaultUnfilledColor = isAcknowledged ? 'rgba(255,255,255,0.3)' : '#d1d5db';
    const hoverColor = '#fbbf24';
    
    stars.forEach((star, index) => {
        const starNumber = index + 1;
        const isFilled = starNumber <= currentRating;
        
        // Set initial color and active state
        if (isFilled) {
            const ratingColor = currentRating >= 4 ? '#fbbf24' : currentRating >= 3 ? '#f59e0b' : '#ef4444';
            star.style.color = ratingColor;
            star.classList.add('active');
        } else {
            star.style.color = defaultUnfilledColor;
            star.classList.remove('active');
        }
        
        // Only add click handler if rating doesn't exist yet
        if (!hasRating) {
            // Click handler - open modal with this rating pre-selected
            star.addEventListener('click', (e) => {
                e.stopPropagation();
                const clickedRating = parseInt(star.dataset.rating);
                handleFooterRatingClick(clickedRating);
            });
            
            // Mouse enter - fill this star and all before it (only if no rating exists)
            star.addEventListener('mouseenter', () => {
                stars.forEach((s, i) => {
                    if (i <= index) {
                        s.style.color = hoverColor;
                    } else {
                        s.style.color = defaultUnfilledColor;
                    }
                });
            });
        }
        
        // Mouse leave - restore original state
        if (starRatingContainer) {
            starRatingContainer.addEventListener('mouseleave', () => {
                stars.forEach((s, i) => {
                    const starNum = i + 1;
                    const wasFilled = starNum <= currentRating;
                    if (wasFilled) {
                        const ratingColor = currentRating >= 4 ? '#fbbf24' : currentRating >= 3 ? '#f59e0b' : '#ef4444';
                        s.style.color = ratingColor;
                    } else {
                        s.style.color = defaultUnfilledColor;
                    }
                });
            });
        }
    });
}

// Handle footer rating click - opens rating dialog
async function handleFooterRatingClick(clickedRating = 0) {
    // Check if rating system is enabled
    if (!ENABLE_RATING_SYSTEM) {
        return;
    }
    
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not available');
        return;
    }
    
    // Check if rating already exists - prevent editing
    const existingRating = currentAudit.audit_rating || 0;
    if (existingRating > 0) {
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Rating Already Submitted',
                message: 'This audit has already been rated. Ratings cannot be modified once submitted.',
                confirmText: 'OK',
                type: 'info'
            });
        } else {
            alert('This audit has already been rated. Ratings cannot be modified once submitted.');
        }
        return;
    }
    
    // Wait for confirmation dialog to be available
    if (!window.confirmationDialog) {
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!window.confirmationDialog) {
            alert('Error: Confirmation dialog not available. Please refresh the page.');
            return;
        }
    }
    
    // Show rating dialog with pre-selected rating if clicked from footer
    const ratingResult = await showRatingDialog(clickedRating);
    
    if (ratingResult.rating === null) return; // User cancelled rating
    
    const rating = ratingResult.rating;
    const feedback = ratingResult.feedback;
    
    // Save rating to database
    try {
        const ratedAt = new Date().toISOString();
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update({
                audit_rating: rating,
                audit_rating_feedback: feedback || null,
                audit_rated_at: ratedAt
            })
            .eq('id', currentAudit.id)
            .select();
        
        if (error) throw error;
        
        // Show success message
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: ` Feedback rating submitted: ${rating} star${rating !== 1 ? 's' : ''}. Thank you for your input!`,
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert(` Feedback rating submitted: ${rating} star${rating !== 1 ? 's' : ''}. Thank you for your input!`);
        }
        
        // Reload audit data to reflect changes
        loadAuditFromURL();
        
    } catch (error) {
        console.error('Error saving rating:', error);
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to save rating. Please try again.',
                confirmText: 'OK',
                type: 'error'
            });
        } else {
            alert('Failed to save rating. Please try again.');
        }
    }
}

// Highlight empty comment fields and provide visual guidance
function highlightEmptyCommentFields() {
    // Find all comment input fields
    const allCommentInputs = document.querySelectorAll('input[data-param-key]');
    const emptyInputs = [];
    
    // Check which inputs are empty
    allCommentInputs.forEach(input => {
        if (!input.value || !input.value.trim()) {
            emptyInputs.push(input);
            // Highlight with red border and background
            input.style.borderColor = '#ef4444';
            input.style.borderWidth = '2px';
            input.style.backgroundColor = '#fef2f2';
            input.style.boxShadow = '0 0 0 3px rgba(239, 68, 68, 0.1)';
            
            // Add focus event to remove highlighting when user starts typing
            const removeHighlight = () => {
                input.style.borderColor = '#d1d5db';
                input.style.borderWidth = '1px';
                input.style.backgroundColor = '';
                input.style.boxShadow = '';
                input.removeEventListener('input', removeHighlight);
                input.removeEventListener('focus', removeHighlight);
            };
            input.addEventListener('input', removeHighlight);
            input.addEventListener('focus', removeHighlight);
        }
    });
    
    // Scroll to the first empty field
    if (emptyInputs.length > 0) {
        const firstEmptyInput = emptyInputs[0];
        firstEmptyInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Focus the first empty input after a short delay
        setTimeout(() => {
            firstEmptyInput.focus();
        }, 300);
    }
    
    // Show a message in the reversal form area
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    if (reversalFormContainer) {
        // Remove any existing validation message
        const existingMessage = reversalFormContainer.querySelector('.validation-message');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        // Create and show validation message
        const messageDiv = document.createElement('div');
        messageDiv.className = 'validation-message';
        messageDiv.style.cssText = `
            background-color: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 0.2812rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            color: #991b1b;
            font-size: 0.6094rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        `;
        messageDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <svg style="width: 1rem; height: 1rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="8" x2="12" y2="12"/>
                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                </svg>
                <span>At least one parameter comment is required. Please add comments to the highlighted fields in the Error Details section above.</span>
            </div>
        `;
        
        // Insert message at the top of the form
        const form = document.getElementById('reversalForm');
        if (form) {
            reversalFormContainer.insertBefore(messageDiv, form);
        } else {
            reversalFormContainer.insertBefore(messageDiv, reversalFormContainer.firstChild);
        }
        
        // Scroll to the message
        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

// Handle reversal form submission
document.addEventListener('DOMContentLoaded', function() {
    const reversalForm = document.getElementById('reversalForm');
    if (reversalForm) {
        reversalForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Verify that current user is the audited employee
            if (!isCurrentUserAuditedEmployee()) {
                alert('Error: You can only submit reversal requests for audits assigned to you.');
                return;
            }
            
            if (!currentAudit || !currentTableName) {
                alert('Error: Audit data not available');
                return;
            }
            
            // Check if Supabase client is initialized
            if (!window.supabaseClient) {
                alert('Error: Database connection not available. Please refresh the page and try again.');
                return;
            }
            
            // Validate required fields
            const reversalType = document.getElementById('reversalType').value;
            const reversalReason = document.getElementById('reversalReasonDropdown').value;
            
            if (!reversalType || !reversalReason) {
                alert('Please fill in all required fields (marked with *)');
                return;
            }
            
            // Get all parameters with comments (automatically included)
            // First, check database comments
            let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
            
            // Also check inline comment inputs in the DOM (real-time fallback)
            const inlineComments = {};
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    if (input.value && input.value.trim()) {
                        comments.push(input.value.trim());
                    }
                });
                if (comments.length > 0) {
                    inlineComments[field.key] = { comments: comments };
                }
            });
            
            // Merge inline comments (takes precedence if they exist)
            parameterComments = { ...parameterComments, ...inlineComments };
            
            // Find all parameters that have comments (check both formats)
            const parametersWithComments = currentErrorFields.filter(field => {
                const fieldComment = parameterComments[field.key];
                if (!fieldComment) return false;
                
                // Check for single comment format: {comment: "text"}
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    return true;
                }
                
                // Check for array format: {comments: ["text1", "text2"]}
                if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    return fieldComment.comments.some(c => c && c.trim());
                }
                
                return false;
            });
            
            if (parametersWithComments.length === 0) {
                // Highlight all empty comment fields and scroll to the first one
                highlightEmptyCommentFields();
                return;
            }
            
            // Build justification from parameter comments
            const selectedParameters = [];
            const justificationParts = [];
            
            parametersWithComments.forEach(field => {
                const fieldComment = parameterComments[field.key];
                let commentText = '';
                
                // Get comment text (handle both formats)
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    commentText = fieldComment.comment.trim();
                } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    // Join all comments with newlines
                    commentText = fieldComment.comments.filter(c => c && c.trim()).join('\n');
                }
                
                if (commentText) {
                    selectedParameters.push(field.label);
                    justificationParts.push(`${field.label}: ${commentText}`);
                }
            });
            
            const detailedJustification = justificationParts.join('\n\n');
            
            // Capture FULL audit state BEFORE updating (for activity log)
            const fullAuditState = {
                parameters: {},
                feedback: {},
                score: currentAudit.average_score || currentAudit.averageScore || 0,
                passing_status: currentAudit.passing_status || currentAudit.passingStatus || '',
                acknowledgement_status: currentAudit.acknowledgement_status || currentAudit.acknowledgementStatus || '',
                // Capture all other relevant audit fields
                audited_employee_email: currentAudit.audited_employee_email || currentAudit.auditedEmployeeEmail || null,
                auditor_email: currentAudit.auditor_email || currentAudit.auditorEmail || null,
                conversation_id: currentAudit.conversation_id || currentAudit.conversationId || null
            };
            
            // Capture all parameter values
            if (currentErrorFields && currentErrorFields.length > 0) {
                currentErrorFields.forEach(field => {
                    const fieldKey = field.key;
                    const value = currentAudit[fieldKey] || 0;
                    fullAuditState.parameters[fieldKey] = value;
                    
                    // Capture feedback
                    const feedbackKey = `feedback_${fieldKey}`;
                    const feedbackValue = currentAudit[feedbackKey] || null;
                    fullAuditState.feedback[fieldKey] = feedbackValue;
                });
            }
            
            // Get user info for activity log
            const userInfo = getCurrentUserInfo();
            const logUserEmail = userInfo?.email || currentUserEmail || '';
            const logUserName = userInfo?.name || userInfo?.email || 'Unknown';
            
            // Gather form data - use column names that match the database schema
            // Based on actual schema: fnchat_cfd table does NOT have reversal_status column
            // Status is tracked via reversal_approved and reversal_responded_at fields
            // New workflow: Set initial state to team_lead_review
            // Check if this is a resubmission after CQC send-back
            // Note: getReversalWorkflowState function needs to be defined in audit-view.html too
            const ackStatus = (currentAudit?.acknowledgement_status || currentAudit?.acknowledgementStatus || '').toLowerCase();
            const isResubmission = ackStatus.includes('cqc_sent_back') || ackStatus.includes('agent_re_review');
            
            const reversalData = {
                reversal_requested_at: isResubmission ? currentAudit.reversal_requested_at : new Date().toISOString(), // Keep original timestamp on resubmission
                reversal_type: reversalType,
                // Combine reversal reason and detailed justification from parameter comments
                reversal_justification_from_agent: `${reversalReason}: ${detailedJustification}`,
                reversal_metrics_parameters: selectedParameters.join(', ') || null,
                // within_auditor_scope is now set by auditor during processing, not by agent
                score_before_appeal: currentAudit.average_score || currentAudit.averageScore || null,
                // Save parameter comments to database when reversal is submitted
                parameter_comments: parameterComments,
                // Set workflow state: New reversals or resubmissions start at Team Lead review
                acknowledgement_status: 'pending - team_lead_review',
                acknowledgement_status_updated_at: new Date().toISOString(),
                // Clear previous review data on resubmission
                reversal_approved_by: null,
                // reversal_resolved_by is deprecated - cleared in reversal_requests instead
                reversal_responded_at: null,
                reversal_approved: null
                // Note: reversal_status column doesn't exist in the schema
                // Status is determined by acknowledgement_status workflow state
                // reversal_responded_at is null until final decision
            };
            
            // Don't set reversal_approved and reversal_responded_at to null explicitly
            // They will remain null by default if not set
            
            console.log('Submitting reversal request with data:', reversalData);
            console.log('Table name:', currentTableName);
            console.log('Audit ID:', currentAudit.id);
            
            // Helper function to retry database operations on schema cache errors
            async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    if (attempt > 0) {
                        // Wait longer on each retry (exponential backoff)
                        console.log(`Retrying database operation (attempt ${attempt + 1}/${maxRetries})...`);
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const result = await operation();
                    
                    // If no error, return success
                    if (!result.error) {
                        return result;
                    }
                    
                    // If it's a schema cache error, retry
                    if (result.error.message && (
                        result.error.message.includes('schema cache') ||
                        result.error.message.includes('Could not find') ||
                        result.error.message.includes('column') && result.error.message.includes('schema cache')
                    )) {
                        console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                        continue;
                    }
                    
                    // If it's not a schema cache error, return immediately
                    return result;
                }
                
                // Return last result after all retries exhausted
                return await operation();
            }
            
            try {
                // FIRST: Log the original state to activity log BEFORE updating
                try {
                    const activityLogData = {
                        audit_id: currentAudit.id,
                        scorecard_table_name: currentTableName,
                        activity_type: 'reversal_requested',
                        activity_timestamp: new Date().toISOString(),
                        performed_by_email: logUserEmail,
                        performed_by_name: logUserName,
                        audit_state_snapshot: fullAuditState,
                        parameters_snapshot: fullAuditState.parameters,
                        feedback_snapshot: fullAuditState.feedback,
                        score_snapshot: fullAuditState.score,
                        passing_status_snapshot: fullAuditState.passing_status,
                        reversal_type: reversalType,
                        reversal_justification: `${reversalReason}: ${detailedJustification}`,
                        change_reason: 'Reversal requested by audited employee',
                        metadata: {
                            reversal_metrics_parameters: selectedParameters,
                            // within_auditor_scope is now set by auditor during processing, not by agent
                            parameter_comments: parameterComments
                        }
                    };
                    
                    const { error: logError } = await window.supabaseClient
                        .from('audit_activity_log')
                        .insert(activityLogData);
                    
                    if (logError) {
                        console.error('Error logging reversal request to activity log:', logError);
                        // Don't throw - continue with reversal submission even if logging fails
                    } else {
                        console.log('Successfully logged reversal request to activity log');
                    }
                } catch (logErr) {
                    console.error('Error creating activity log entry:', logErr);
                    // Don't throw - continue with reversal submission
                }
                
                // ALSO: Create reversal_requests record (new structure)
                try {
                    // Check if reversal_requests record already exists (for resubmissions)
                    const { data: existingReversalRequest } = await window.supabaseClient
                        .from('reversal_requests')
                        .select('id')
                        .eq('audit_id', currentAudit.id)
                        .eq('scorecard_table_name', currentTableName)
                        .maybeSingle();
                    
                    if (!existingReversalRequest) {
                        // Create new reversal_requests record
                        const reversalRequestData = {
                            audit_id: currentAudit.id,
                            scorecard_table_name: currentTableName,
                            requested_at: isResubmission ? currentAudit.reversal_requested_at : new Date().toISOString(),
                            requested_by_email: logUserEmail,
                            requested_by_name: logUserName,
                            reversal_type: reversalType,
                            justification: `${reversalReason}: ${detailedJustification}`,
                            metrics_parameters: selectedParameters.join(', ') || null,
                            attachments: null, // Can be added later if needed
                            original_score: currentAudit.average_score || currentAudit.averageScore || 0,
                            original_passing_status: currentAudit.passing_status || currentAudit.passingStatus || 'Not Passing',
                            original_parameters: fullAuditState.parameters, // Store actual parameter values, not parameter_comments!
                            original_feedback: fullAuditState.feedback,
                            within_auditor_scope: document.getElementById('withinAuditorScope')?.checked || false,
                            sla_hours: null // Will be calculated during processing
                        };
                        
                        const { data: newReversalRequest, error: rrError } = await window.supabaseClient
                            .from('reversal_requests')
                            .insert(reversalRequestData)
                            .select()
                            .single();
                        
                        if (rrError) {
                            console.error('Error creating reversal_requests record:', rrError);
                            // Don't throw - continue with reversal submission
                        } else {
                            console.log('Successfully created reversal_requests record:', newReversalRequest.id);
                            
                            // Create initial workflow state - start with 'submitted' then transition to 'team_lead_review'
                            // First create 'submitted' state
                            const { data: submittedState, error: submittedError } = await window.supabaseClient
                                .from('reversal_workflow_states')
                                .insert({
                                    reversal_request_id: newReversalRequest.id,
                                    state: 'submitted',
                                    entered_at: newReversalRequest.requested_at,
                                    entered_by_email: logUserEmail,
                                    entered_by_name: logUserName,
                                    notes: 'Reversal requested by agent',
                                    is_current: false
                                })
                                .select()
                                .single();
                            
                            if (!submittedError && submittedState) {
                                // Then create 'team_lead_review' state (current)
                                const { data: workflowState, error: wsError } = await window.supabaseClient
                                    .from('reversal_workflow_states')
                                    .insert({
                                        reversal_request_id: newReversalRequest.id,
                                        state: 'team_lead_review',
                                        entered_at: newReversalRequest.requested_at,
                                        entered_by_email: logUserEmail,
                                        entered_by_name: logUserName,
                                        notes: 'Reversal requested by agent - awaiting Team Lead review',
                                        previous_state_id: submittedState.id,
                                        is_current: true
                                    })
                                    .select()
                                    .single();
                                
                                if (!wsError && workflowState) {
                                    // Update reversal_request to point to current state
                                    await window.supabaseClient
                                        .from('reversal_requests')
                                        .update({ current_state_id: workflowState.id })
                                        .eq('id', newReversalRequest.id);
                                }
                            }
                        }
                    } else {
                        console.log('Reversal_requests record already exists, skipping creation');
                    }
                } catch (rrErr) {
                    console.error('Error creating reversal_requests record:', rrErr);
                    // Don't throw - continue with reversal submission
                }
                
                // THEN: Update the audit record with reversal data
                // First, try with parameter_comments included
                let result = await retryOnSchemaCacheError(async () => {
                    return await window.supabaseClient
                        .from(currentTableName)
                        .update(reversalData)
                        .eq('id', currentAudit.id)
                        .select();
                });
                
                let data = result.data;
                let error = result.error;
                
                // If error is specifically about parameter_comments column not existing, retry without it
                if (error && error.message && (
                    error.message.includes('parameter_comments') && 
                    (error.message.includes('Could not find') || error.message.includes('does not exist') || error.message.includes('column'))
                )) {
                    console.warn('parameter_comments column not found, retrying without it...');
                    
                    // Create a copy without parameter_comments
                    const reversalDataWithoutComments = { ...reversalData };
                    delete reversalDataWithoutComments.parameter_comments;
                    
                    result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentTableName)
                            .update(reversalDataWithoutComments)
                            .eq('id', currentAudit.id)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully submitted reversal request without parameter_comments column');
                    }
                }
                
                if (error) throw error;
                
                // Update currentAudit object immediately to reflect reversal submission
                if (currentAudit && data && data.length > 0) {
                    const updatedAudit = data[0];
                    currentAudit.reversalRequestedAt = updatedAudit.reversal_requested_at;
                    currentAudit.reversal_requested_at = updatedAudit.reversal_requested_at;
                    currentAudit.reversalType = updatedAudit.reversal_type;
                    currentAudit.reversal_type = updatedAudit.reversal_type;
                    currentAudit.reversalJustificationFromAgent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversal_justification_from_agent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversalMetricsParameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.reversal_metrics_parameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.withinAuditorScope = updatedAudit.within_auditor_scope;
                    currentAudit.within_auditor_scope = updatedAudit.within_auditor_scope;
                }
                
                // Show pending dialog (not success - reversal is under review)
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Reversal Request Submitted',
                        message: ' Your reversal request has been submitted and is now under Team Lead review.\n\nYou will be notified once a decision has been made.',
                        confirmText: 'OK',
                        type: 'info'
                    });
                } else {
                alert(' Your reversal request has been submitted and is now under Team Lead review.\n\nYou will be notified once a decision has been made.');
                }
                
                // Hide form and reload audit data
                toggleReversalForm();
                location.reload();
                
            } catch (error) {
                console.error('Error submitting reversal request:', error);
                console.error('Error details:', error.message, error);
                
                // Check if this is a schema cache or column error
                let errorMessage = error.message || 'Unknown error occurred';
                if (error.message && (
                    error.message.includes('schema cache') ||
                    error.message.includes('Could not find') ||
                    (error.message.includes('column') && error.message.includes('schema cache'))
                )) {
                    errorMessage = 'The database schema cache is being updated. Please wait a moment and try again. If the issue persists, the column may need to be added to the database table.';
                }
                
                // Provide more helpful error message
                let errorMsg = 'Failed to submit reversal request.\n\n';
                errorMsg += 'Error: ' + errorMessage + '\n\n';
                errorMsg += 'Please try again or contact support if the issue persists.';
                
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Error',
                        message: errorMsg,
                        confirmText: 'OK',
                        type: 'error'
                    });
                } else {
                    alert(errorMsg);
                }
            }
        });
    }
});
</script>

    <!-- Image Viewer Modal -->
    <div id="imageViewerModal" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; cursor: pointer;" onclick="if(event.target.id === 'imageViewerModal') closeImageViewer();" onkeydown="if(event.key === 'Escape') closeImageViewer(); if(event.key === 'ArrowLeft') navigateImage('prev'); if(event.key === 'ArrowRight') navigateImage('next');">
        <!-- Close Button -->
        <button id="imageViewerClose" onclick="closeImageViewer(); event.stopPropagation();" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 2.5rem; height: 2.5rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">
            
        </button>
        
        <!-- Previous Button -->
        <button id="imageViewerPrev" onclick="navigateImage('prev'); event.stopPropagation();" style="position: absolute; left: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Previous ()">
            
        </button>
        
        <!-- Next Button -->
        <button id="imageViewerNext" onclick="navigateImage('next'); event.stopPropagation();" style="position: absolute; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Next ()">
            
        </button>
        
        <!-- Image Counter -->
        <div id="imageViewerCounter" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 0.5rem 1rem; border-radius: 1.5rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; z-index: 10001;">
            1 / 1
        </div>
        
        <!-- Image Container -->
        <div style="max-width: 95%; max-height: 95%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation();">
            <img id="imageViewerImg" src="" alt="Conversation image" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 0.5rem 2rem rgba(0,0,0,0.5);">
        </div>
    </div>

</body>
</html>