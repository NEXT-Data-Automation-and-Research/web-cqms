<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Auditors' Dashboard | CQMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="dark-mode.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <script src="timezone-utils.js"></script>
    <script src="date-filter-utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        .header-actions {
            display: flex;
            gap: 0.5625rem;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.4688rem 0.75rem;
            background-color: var(--background-white);
            color: var(--text-color);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            font-size: 0.6562rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family);
        }

        .action-btn:hover {
            background-color: var(--gray-50);
            border-color: var(--primary-color);
        }

        .action-btn.active {
            background-color: var(--primary-color);
            color: var(--white);
            border-color: var(--primary-color);
        }

        .action-btn svg {
            width: 0.75rem;
            height: 0.75rem;
        }

        /* Date Range Picker */
        .date-picker-dropdown {
            position: relative;
            display: inline-block;
        }

        .date-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.375rem;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 9.8438rem;
        }

        .date-dropdown-menu.active {
            display: block;
        }

        /* Filter Dropdown */
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-dropdown-menu {
            display: none;
            position: absolute;
            top: calc(100% + 0.375rem);
            left: 0;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 20rem;
            max-width: 90vw;
        }

        .filter-dropdown-menu.active {
            display: block;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .filter-label {
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .filter-input, .filter-select {
            padding: 0.375rem 0.5625rem;
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.2812rem;
            font-size: 0.6562rem;
            font-family: var(--font-family);
            background-color: var(--background-white);
            color: var(--text-color);
        }

        .filter-input:focus, .filter-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* Loading animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Smooth transitions for stat cards */
        #statsContainer > div {
            transition: opacity 0.3s ease;
        }
        
        /* Smooth transitions for table updates */
        #performanceTableBody {
            transition: opacity 0.2s ease;
        }
        
        /* Hourly Breakdown responsive layout */
        #hourlyBreakdownTable .hourly-content,
        #dynamicHourlyBreakdownTable .hourly-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            padding: 0.75rem;
        }
        
        @media (max-width: 768px) {
            #hourlyBreakdownTable .hourly-content,
            #dynamicHourlyBreakdownTable .hourly-content {
                grid-template-columns: 1fr;
            }
        }
        
        .lunch-break-row:hover .lunch-break-text {
            opacity: 1 !important;
        }
    </style>

</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
    <p class="page-heading">Auditors' Dashboard</p>
    <div style="margin-bottom: 1.125rem; width: 100%;"></div>

        
            <!-- Tab Navigation -->
            <div style="position: relative; display: flex; background-color: var(--dark-forest); border-radius: 0.4688rem; overflow: hidden; width: 100%; max-width: 15rem; margin: 0.9375rem auto; padding: 0.2344rem; margin-top: 2rem;">
                <div style="position: absolute; top: 0.2344rem; height: calc(100% - 0.4688rem); background-color: var(--primary-color); border-radius: 0.2344rem; transition: all 0.3s ease; left: 0.2344rem; width: calc(50% - 0.2344rem);"></div>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" class="active" onclick="switchTab(this, 0)">Team Stats</button>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" onclick="switchTab(this, 1)">Standup View</button>
            </div>

    <!-- Action Buttons -->
    <div class="header-actions" style="margin-top: 1.125rem; margin-bottom: 1.125rem; justify-content: center;">
        <!-- Week Navigation -->
        <div style="display: flex; align-items: center; gap: 0.5625rem;">
            <button class="action-btn" id="prevWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Previous Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>
            <div class="action-btn" id="weekDisplay" style="padding: 0.4688rem 0.75rem; cursor: default; background-color: var(--primary-color); color: var(--white); border-color: var(--primary-color);">
                <span id="weekText">Week -</span>
            </div>
            <button class="action-btn" id="nextWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Next Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </button>
        </div>
        <!-- Date Range Picker -->
        <div class="date-picker-dropdown">
            <button class="action-btn" id="dateBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span id="dateBtnText">Date Range</span>
                <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div class="date-dropdown-menu" id="dateDropdown">
                <div class="filter-group">
                    <label class="filter-label">Start Date</label>
                    <input type="date" class="filter-input" id="startDate">
                </div>
                <div class="filter-group">
                    <label class="filter-label">End Date</label>
                    <input type="date" class="filter-input" id="endDate">
                </div>
                <div style="display: flex; gap: 0.375rem; margin-top: 0.375rem;">
                    <button class="action-btn" style="flex: 1;" onclick="applyDateFilter()">Apply</button>
                    <button class="action-btn" style="flex: 1;" onclick="clearDateFilter()">Clear</button>
                </div>
            </div>
        </div>
        <!-- Quick Date Filters -->
        <div style="display: flex; align-items: center; gap: 0.375rem;">
            <button class="action-btn quick-date-btn active" id="todayBtn" onclick="applyQuickDateFilter('today')">Today</button>
            <button class="action-btn quick-date-btn" id="yesterdayBtn" onclick="applyQuickDateFilter('yesterday')">Yesterday</button>
            <button class="action-btn quick-date-btn" id="thisMonthBtn" onclick="applyQuickDateFilter('thisMonth')">This Month</button>
            <button class="action-btn quick-date-btn" id="lastMonthBtn" onclick="applyQuickDateFilter('lastMonth')">Last Month</button>
        </div>
        <div class="filter-dropdown">
            <button class="action-btn" id="filterBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                </svg>
                <span>Filter</span>
            </button>
            <!-- Filter Dropdown Menu -->
            <div class="filter-dropdown-menu" id="filterDropdown">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5625rem; padding-bottom: 0.375rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <div style="font-size: 0.6562rem; font-weight: 600; color: #1A733E;">Filters</div>
                    <button onclick="clearFilters()" style="padding: 0.2812rem 0.5625rem; background-color: #f9fafb; color: #374151; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif; cursor: pointer;">Clear All</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr)); gap: 0.75rem;">
                    <!-- Status Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Status</label>
                        <select class="filter-input" id="statusFilter" onchange="applyFilters()">
                            <option value="">All Statuses</option>
                            <option value="pending">Pending</option>
                            <option value="in_progress">In Progress</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <!-- Channel Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Channel</label>
                        <select class="filter-input" id="channelFilter" onchange="applyFilters()">
                            <option value="">All Channels</option>
                        </select>
                    </div>
                    <!-- Auditor Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Auditor</label>
                        <select class="filter-input" id="auditorFilter" onchange="applyFilters()">
                            <option value="">All Auditors</option>
                        </select>
                    </div>
                    <!-- Employee Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Employee</label>
                        <select class="filter-input" id="employeeFilter" onchange="applyFilters()">
                            <option value="">All Employees</option>
                        </select>
                    </div>
                    <!-- Scorecard Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Scorecard</label>
                        <select class="filter-input" id="scorecardFilter" onchange="applyFilters()">
                            <option value="">All Scorecards</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

            <!-- stat Cards -->
            <div id="statsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(9rem, 1fr)); gap: 1.125rem; margin-bottom: 1.5rem; width: 100%;">
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div id="stat1Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Assigned</div>
                    <div id="stat1Count" style="font-size: 2.625rem; font-weight: 700; line-height: 1.2; margin-bottom: auto;">-</div>
                    <div id="stat1Workload" style="margin-top: auto; font-size: 0.5625rem; opacity: 0.9; line-height: 1.3; display: flex; gap: 0.375rem; flex-wrap: wrap;">
                        <div id="stat1Avg">Avg: -</div>
                        <div id="stat1Max">Max: -</div>
                        <div id="stat1Min">Min: -</div>
                </div>
                </div>
                <div id="completedCard" style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Completed</div>
                    <div style="display: flex; align-items: baseline; gap: 0.375rem; margin-bottom: auto; line-height: 1.2;">
                        <div id="completedCount" style="font-size: 2.625rem; font-weight: 700;">-</div>
                        <div id="backlogCountText" style="font-size: 0.5625rem; opacity: 0.85; font-weight: 500;"></div>
                    </div>
                    <div style="margin-top: auto; min-height: 0.75rem;">
                        <div id="targetAchieved" style="font-size: 0.5625rem; opacity: 0.9; line-height: 1.2; margin-bottom: 0.1875rem;">-</div>
                        <div id="completedProgressBar" class="progress-bar-container" style="width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-bottom: 0.1875rem; display: none;">
                            <div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: 0%;"></div>
                </div>
                </div>
                </div>
                <div id="remainingCard" style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Remaining</div>
                    <div id="remainingCount" style="font-size: 2.625rem; font-weight: 700; line-height: 1.2; margin-bottom: auto;">-</div>
                    <div style="font-size: 0.5625rem; opacity: 0; height: 0.5625rem; margin-top: 0.1875rem;">&nbsp;</div>
                </div>
                <div id="stat4Card" style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: none; flex-direction: column;">
                    <div id="stat4Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">In Progress</div>
                    <div id="stat4CountContainer" style="display: flex; align-items: flex-start; gap: 0.5rem; margin-bottom: auto;">
                        <div id="stat4Count" style="font-size: 2.625rem; font-weight: 700; line-height: 1.2;">-</div>
                        <div id="stat4ChipsContainer" style="display: none; flex-direction: column; gap: 0.25rem; margin-top: 0.25rem;">
                            <div id="stat4PassingCount" style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; background-color: rgba(16, 185, 129, 0.2); color: #10b981; line-height: 1.2;">
                                <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                </svg>
                                <span>-</span>
                            </div>
                            <div id="stat4NotPassingCount" style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; background-color: rgba(239, 68, 68, 0.2); color: #ef4444; line-height: 1.2;">
                                <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                <span>-</span>
                            </div>
                        </div>
                    </div>
                    <div id="stat4Subtitle" style="font-size: 0.5625rem; opacity: 0.9; line-height: 1.2; margin-top: auto; min-height: 0.5625rem;">-</div>
                </div>
                <div id="stat5Card" style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div id="stat5Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Reversals</div>
                    <div id="stat5Count" style="font-size: 2.625rem; font-weight: 700; line-height: 1.2; margin-bottom: auto;">-</div>
                    <div id="stat5Subtitle" style="font-size: 0.5625rem; opacity: 0.9; line-height: 1.2; margin-top: auto; min-height: 0.5625rem;"></div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div id="stat6Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Avg Duration</div>
                    <div id="stat6Count" style="font-size: 1.875rem; font-weight: 700; line-height: 1.2; margin-bottom: auto;">-</div>
                    <div id="stat6Subtitle" style="font-size: 0.5625rem; opacity: 0.9; line-height: 1.2; margin-top: auto; min-height: 0.5625rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 6.5rem; display: flex; flex-direction: column;">
                    <div id="stat7Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.375rem; line-height: 1.2;">Passing Rate</div>
                    <div style="display: flex; align-items: flex-start; gap: 0.5rem; margin-bottom: auto;">
                        <div id="stat7Count" style="font-size: 2.625rem; font-weight: 700; line-height: 1.2;">-</div>
                        <div style="display: flex; flex-direction: column; gap: 0.25rem; margin-top: 0.25rem;">
                            <div id="stat7PassingCount" style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; background-color: rgba(16, 185, 129, 0.2); color: #10b981; line-height: 1.2;">
                                <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                </svg>
                                <span>-</span>
                            </div>
                            <div id="stat7NotPassingCount" style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; background-color: rgba(239, 68, 68, 0.2); color: #ef4444; line-height: 1.2;">
                                <svg style="width: 0.5rem; height: 0.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                                <span>-</span>
                            </div>
                        </div>
                    </div>
                    <div id="stat7Subtitle" style="font-size: 0.5625rem; opacity: 0.9; line-height: 1.2; margin-top: auto; min-height: 0.5625rem;">-</div>
                </div>
            </div>


            <!-- Data Table -->
            <div id="performanceTable" style="background-color: var(--white); border-radius: 0.5625rem; box-shadow: 0 0.0469rem 0.1406rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; max-width: 80%; width: fit-content; min-width: 100%;">
                <div style="background-color: #f8f9fa; padding: 0.5625rem 0.75rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <h3 style="font-size: 0.8438rem; font-weight: 600; color: var(--text-color);">Progress Overview</h3>
                </div>
                <div style="padding: 0.75rem; overflow-x: auto;">
                    <div id="tableHeader" style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0 0.5625rem 0; font-weight: 700; font-size: 0.6562rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; min-width: fit-content;">
                        <div>Name</div>
                        <div style="text-align: center;">Assigned</div>
                        <div style="text-align: center;">Completed</div>
                        <div style="text-align: center;">Remaining</div>
                        <div style="text-align: center;">Avg Duration</div>
                        <div style="text-align: center;">Progress Meter</div>
                    </div>
                    <div id="performanceTableBody" style="min-width: fit-content;">
                        <div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Dynamic/Realtime Hourly Breakdown Container -->
            <div id="dynamicHourlyBreakdownTable" style="background-color: var(--white); border-radius: 0.5625rem; box-shadow: 0 0.0469rem 0.1406rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; max-width: 80%; width: fit-content; min-width: 100%; margin-top: 1.5rem;">
                <div style="background-color: #f8f9fa; padding: 0.5625rem 0.75rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <h3 style="font-size: 0.8438rem; font-weight: 600; color: var(--text-color);">Dynamic/Realtime Hourly Breakdown</h3>
                </div>
                <div class="hourly-content">
                    <!-- Chart on the left -->
                    <div style="min-height: 20rem; position: relative;">
                        <canvas id="dynamicHourlyChart"></canvas>
                    </div>
                    <!-- Table on the right -->
                    <div style="overflow-x: auto;">
                        <div id="dynamicHourlyTableBody" style="min-width: fit-content;">
                            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hourly Breakdown Container -->
            <div id="hourlyBreakdownTable" style="background-color: var(--white); border-radius: 0.5625rem; box-shadow: 0 0.0469rem 0.1406rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; max-width: 80%; width: fit-content; min-width: 100%; margin-top: 1.5rem;">
                <div style="background-color: #f8f9fa; padding: 0.5625rem 0.75rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <h3 style="font-size: 0.8438rem; font-weight: 600; color: var(--text-color);">Hourly Breakdown</h3>
                </div>
                <div class="hourly-content">
                    <!-- Chart on the left -->
                    <div style="min-height: 20rem; position: relative;">
                        <canvas id="hourlyChart"></canvas>
                    </div>
                    <!-- Table on the right -->
                    <div style="overflow-x: auto;">
                        <div id="hourlyTableBody" style="min-width: fit-content;">
                            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>


<script>
// ============================================================================
// Global Variables
// ============================================================================
let currentTab = 0; // 0 = Team Stats, 1 = Standup View (removed Your Stats)
let allAssignments = [];
let unfilteredAssignments = []; // Store unfiltered data
let currentUserEmail = '';
let allUsers = [];
let currentFilters = {
    status: '',
    channel: '',
    auditor: '',
    employee: '',
    scorecard: ''
};
let allScorecards = [];
let cachedScorecardTables = []; // Cache scorecard table names to avoid repeated queries
let currentWeek = null;
let currentWeekYear = null;
let dateFilter = { start: null, end: null };
let useWeekFilter = false; // Default to month view instead of week view
let presenceChannel = null;
let onlineAuditors = new Set(); // Track online auditor emails
let heartbeatInterval = null;
let isInitialLoad = true; // Track if this is the first load
let isLoading = false; // Track if data is currently loading
let renderInProgress = false; // Prevent duplicate renders
let loadingTimeout = null; // Track loading timeout
let currentFetchId = 0; // Track the current fetch request ID to cancel stale fetches

// ============================================================================
// Initialize Page
// ============================================================================
document.addEventListener('DOMContentLoaded', async function() {
    // Check page access using centralized access control
    if (!window.accessControl || !window.accessControl.enforcePageAccess('auditor-dashboard.html')) {
        return; // Access denied, user will be redirected
    }
    
    await initializeDashboard();
    initializeSlider();
});

async function initializeDashboard() {
    try {
        // Hide stat4 card immediately (IN PROGRESS - not used in Team Stats)
        const stat4Card = document.getElementById('stat4Card');
        if (stat4Card) {
            stat4Card.style.display = 'none';
        }
        
        // Show initial loading state
        showLoadingState();
        
        // Wait for Supabase to be ready
        let attempts = 0;
        while (!window.supabaseClient && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            hideLoadingState();
            return;
        }

        // Get current user
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        currentUserEmail = userInfo.email;

        if (!currentUserEmail) {
            console.error('No user logged in');
            hideLoadingState();
            return;
        }

        // Initialize today filter (default view)
        initializeTodayFilter();
        setupEventListeners();

        // Load all data in parallel for faster initialization
        await Promise.all([
            loadAllUsers(),
            loadScorecards(),
            loadAssignments()
        ]);
        
        // Setup presence tracking after everything is loaded
        await setupPresenceTracking();
        
        // Mark initial load as complete after a short delay to ensure all renders are done
        setTimeout(() => {
            isInitialLoad = false;
        }, 500);
        
        // Hide loading state
        hideLoadingState();
        
    } catch (error) {
        console.error('Error initializing dashboard:', error);
        hideLoadingState();
    }
}

// Get current period dates (week or date range) in Dhaka timezone
function getCurrentPeriodDates() {
    if (dateFilter.start || dateFilter.end) {
        // Using date range filter
        // dateFilter.start and dateFilter.end are stored as date strings (YYYY-MM-DD format)
        return {
            start: dateFilter.start ? getDhakaStartOfDay(parseDhakaDate(dateFilter.start)) : new Date(0),
            end: dateFilter.end ? getDhakaEndOfDay(parseDhakaDate(dateFilter.end)) : getDhakaNow()
        };
    } else if (useWeekFilter && currentWeek !== null) {
        // Using week filter
        return getDhakaWeekDates(currentWeek, currentWeekYear);
    } else {
        // Default to today in Dhaka timezone
        const today = getDhakaNow();
        return {
            start: getDhakaStartOfDay(today),
            end: getDhakaEndOfDay(today)
        };
    }
}

// ============================================================================
// Helper Functions for Parallelized Queries
// ============================================================================
// Helper to convert audit duration to minutes
// NEW FORMAT: All numeric values are in SECONDS (as of timer update)
// LEGACY FORMAT: String time formats (MM:SS or HH:MM:SS) or very old numeric values in minutes
function convertDurationToMinutes(duration) {
    if (!duration) return 0;
    
    let durationInMinutes = 0;
    if (typeof duration === 'number') {
        // All numeric audit_duration values are now in seconds, convert to minutes
        durationInMinutes = duration / 60;
    } else if (typeof duration === 'string') {
        // Try parsing as integer first
        const asInt = parseInt(duration);
        if (!isNaN(asInt)) {
            // If it's a numeric string, treat as seconds (new format)
            durationInMinutes = asInt / 60; // Convert seconds to minutes
        } else {
            // Legacy format: time string (MM:SS or HH:MM:SS)
            const timeParts = duration.split(':');
            if (timeParts.length === 2) {
                // MM:SS format
                const minutes = parseInt(timeParts[0]) || 0;
                const seconds = parseInt(timeParts[1]) || 0;
                durationInMinutes = minutes + (seconds / 60);
            } else if (timeParts.length === 3) {
                // HH:MM:SS format
                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;
                durationInMinutes = (hours * 60) + minutes + (seconds / 60);
            }
        }
    }
    return durationInMinutes;
}

// Helper to format duration text
function formatDurationText(avgDurationMinutes) {
    if (avgDurationMinutes <= 0) return '-';
    
    if (avgDurationMinutes >= 60) {
        const hours = Math.floor(avgDurationMinutes / 60);
        const minutes = Math.round(avgDurationMinutes % 60);
        return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    } else {
        return `${Math.round(avgDurationMinutes)}m`;
    }
}

// ============================================================================
// Load Data
// ============================================================================
async function loadAllUsers() {
    try {
        // Use sessionStorage cache for users (5 minutes cache, same as home.html)
        const cachedUsers = sessionStorage.getItem('cachedUsers');
        const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
        const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
        
        if (cachedUsers && cacheAge < 300000) { // 5 minutes cache
            allUsers = JSON.parse(cachedUsers);
            console.log(`Loaded ${allUsers.length} users from cache`);
        } else {
            const { data, error } = await window.supabaseClient
                .from('users')
                .select('email, name, role, channel, quality_mentor')
                .eq('is_active', true);
            
            if (error) throw error;
            
            allUsers = data || [];
            console.log(`Loaded ${allUsers.length} users`);
            
            // Cache users in sessionStorage
            sessionStorage.setItem('cachedUsers', JSON.stringify(allUsers));
            sessionStorage.setItem('cachedUsersTime', Date.now().toString());
        }
        
    } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
    }
}

async function loadScorecards() {
    try {
        // Always fetch fresh data
        const { data, error } = await window.supabaseClient
            .from('scorecards')
            .select('id, name, table_name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        allScorecards = data || [];
        cachedScorecardTables = allScorecards.map(s => s.table_name).filter(Boolean);
        
        // Update UI with fresh data
        console.log('Updating UI with fresh scorecards');
        populateScorecardFilter();
        
    } catch (error) {
        console.error('Error loading scorecards:', error);
        allScorecards = [];
        cachedScorecardTables = [];
    }
}

async function loadAssignments() {
    try {
        const period = getCurrentPeriodDates();
        
        // Show loading state (always show when loading assignments)
        showLoadingState();
        
        // Populate filters with empty data so UI is ready
        populateChannelFilter();
        populateAuditorFilter();
        populateEmployeeFilter();
        
        // Always fetch fresh data
        await fetchAndCacheAssignments(period);
        
    } catch (error) {
        console.error('Error loading assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
        hideLoadingState();
    }
}

async function fetchAndCacheAssignments(period) {
    // Capture the current fetch ID at the start of this fetch
    const fetchId = currentFetchId;
    
    try {
        // Set loading state immediately
        isLoading = true;
        
        let assignmentsQuery = window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .eq('auditor_email', currentUserEmail)
            .order('created_at', { ascending: false });
        
        // Apply date filters server-side if possible (convert Dhaka to UTC)
        if (period && period.start) {
            assignmentsQuery = assignmentsQuery.gte('created_at', dhakaDateToUTCISO(period.start));
        }
        if (period && period.end) {
            assignmentsQuery = assignmentsQuery.lte('created_at', dhakaDateToUTCISO(period.end));
        }
        
        let { data, error } = await assignmentsQuery;
        
        // If server-side date filter fails, try without date filter and filter client-side
        if (error && period && (period.start || period.end)) {
            console.warn('Server-side date filter failed, falling back to client-side filtering:', error);
            const retryResult = await window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .eq('auditor_email', currentUserEmail)
                .order('created_at', { ascending: false });
            
            if (retryResult.data && period && period.start) {
                retryResult.data = retryResult.data.filter(assignment => {
                    // Use scheduled_date if available, otherwise created_at
                    const dateToUse = assignment.scheduled_date 
                        ? new Date(assignment.scheduled_date + 'T00:00:00')
                        : assignment.created_at;
                    if (!dateToUse) return false;
                    const assignmentDate = toDhakaTime(dateToUse);
                    return (!period.start || assignmentDate >= period.start) && 
                           (!period.end || assignmentDate <= period.end);
                });
            }
            data = retryResult.data;
            error = retryResult.error;
        }
        
        if (error) throw error;
        
        // Check if this fetch is still the current one before processing data
        if (fetchId !== currentFetchId) {
            console.log('Fetch cancelled - newer fetch in progress');
            isLoading = false;
            return;
        }
        
        allAssignments = data || [];
        unfilteredAssignments = [...allAssignments]; // Store unfiltered copy
        console.log(`Loaded ${allAssignments.length} assignments`);
        
        // Populate filters
        populateChannelFilter();
        populateAuditorFilter();
        populateEmployeeFilter();
        
        // Check again before updating UI (in case fetch was cancelled during filter population)
        if (fetchId !== currentFetchId) {
            console.log('Fetch cancelled - newer fetch in progress');
            isLoading = false;
            return;
        }
        
        // Check one more time before calling updateDashboard (which triggers stats fetches)
        if (fetchId !== currentFetchId) {
            console.log('Fetch cancelled - newer fetch in progress');
            isLoading = false;
            return;
        }
        
        // Update UI with fresh data
        console.log('Updating UI with fresh assignments');
        await updateDashboard();
        
        isLoading = false;
        
    } catch (error) {
        console.error('Error fetching assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
        isLoading = false;
        hideLoadingState();
    }
}

// ============================================================================
// Update Dashboard
// ============================================================================
async function updateDashboard() {
    // Prevent duplicate updates
    if (renderInProgress) {
        return;
    }
    
    renderInProgress = true;
    
    try {
        if (currentTab === 0) {
            // Team Stats
            await updateTeamStats();
        } else if (currentTab === 1) {
            // Standup View
            await updateStandupView();
        }
    } finally {
        // Use a small delay to prevent rapid re-renders
        setTimeout(() => {
            renderInProgress = false;
        }, 100);
    }
}

// Note: updateYourStats() function has been moved to create-audit.html

async function updateTeamStats() {
    // Only proceed if we're still on Team Stats tab
    if (currentTab !== 0) {
        return;
    }
    
    const period = getCurrentPeriodDates();
    
    // Show loading if initial load
    if (isInitialLoad) {
        showLoadingState();
    }
    
    // Always fetch fresh data
    await fetchAndCacheTeamStats(period);
}

async function fetchAndCacheTeamStats(period) {
    // Capture the current fetch ID at the start of this fetch
    const fetchId = currentFetchId;
    
    try {
        // Ensure allUsers is loaded
        if (!allUsers || allUsers.length === 0) {
            console.warn('Users not loaded yet, waiting...');
            await loadAllUsers();
        }
        
        // Check if this fetch is still the current one
        if (fetchId !== currentFetchId) {
            console.log('Team stats fetch cancelled - newer fetch in progress');
            return;
        }
        
        // Load assignments in two ways:
        // 1. Assignments scheduled in the date range (for assigned count)
        // 2. Assignments completed in the date range (for completed count)
        // This ensures we show auditors who either have assignments scheduled OR completed in the period
        
        // Query 1: Assignments scheduled in the date range
        // Filter by scheduled_date if available, otherwise created_at
        let scheduledQuery = window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .order('created_at', { ascending: false });
        
        // Try to filter by scheduled_date on server-side first (if period is a single day)
        // For date range, we'll filter client-side since scheduled_date is a DATE column
        let { data: scheduledData, error: scheduledError } = await scheduledQuery;
        
        // Filter by scheduled_date (or created_at as fallback) client-side
        let scheduledAssignments = [];
        if (scheduledData) {
            scheduledAssignments = scheduledData.filter(assignment => {
                // Use scheduled_date if available, otherwise created_at
                let assignmentDate;
                if (assignment.scheduled_date) {
                    // scheduled_date is a DATE string (YYYY-MM-DD), parse it in Dhaka timezone
                    assignmentDate = getDhakaStartOfDay(parseDhakaDate(assignment.scheduled_date));
                } else if (assignment.created_at) {
                    // Fallback to created_at - get the date part in Dhaka timezone
                    assignmentDate = getDhakaStartOfDay(assignment.created_at);
                } else {
                    return false; // No date available
                }
                
                // Check if assignment date falls within the period (compare at day level)
                // period.start and period.end are already start/end of day in Dhaka timezone
                // Compare dates by converting to YYYY-MM-DD strings for reliable comparison
                const assignmentDateStr = formatDhakaDateForInput(assignmentDate);
                const periodStartStr = period.start ? formatDhakaDateForInput(period.start) : null;
                const periodEndStr = period.end ? formatDhakaDateForInput(period.end) : null;
                
                const inRange = (!periodStartStr || assignmentDateStr >= periodStartStr) && 
                               (!periodEndStr || assignmentDateStr <= periodEndStr);
                
                return inRange;
            });
        }
        
        // Query 2: Assignments completed in the date range (for completed count)
        let completedQuery = window.supabaseClient
                .from('audit_assignments')
                .select('*')
            .eq('status', 'completed')
            .not('completed_at', 'is', null)
            .order('completed_at', { ascending: false });
            
        // Apply date filters for completed_at server-side
            if (period.start) {
            completedQuery = completedQuery.gte('completed_at', dhakaDateToUTCISO(period.start));
            }
            if (period.end) {
            completedQuery = completedQuery.lte('completed_at', dhakaDateToUTCISO(period.end));
        }
        
        let { data: completedData, error: completedError } = await completedQuery;
        
        // If server-side date filter fails, filter client-side
        if (completedError && period && (period.start || period.end)) {
            console.warn('Server-side completed_at filter failed, falling back to client-side filtering:', completedError);
                const retryResult = await window.supabaseClient
                    .from('audit_assignments')
                    .select('*')
                .eq('status', 'completed')
                .not('completed_at', 'is', null)
                .order('completed_at', { ascending: false });
                
                if (retryResult.data && period.start) {
                    retryResult.data = retryResult.data.filter(assignment => {
                    if (!assignment.completed_at) return false;
                    const completedDate = toDhakaTime(assignment.completed_at);
                    return (!period.start || completedDate >= period.start) && 
                           (!period.end || completedDate <= period.end);
                });
            }
            completedData = retryResult.data;
            completedError = retryResult.error;
        }
        
        // Merge both sets of assignments (scheduled + completed) to get all relevant assignments
        // Use a Map to deduplicate by assignment ID
        const assignmentsMap = new Map();
        
        // Add scheduled assignments
        scheduledAssignments.forEach(a => assignmentsMap.set(a.id, a));
        
        // Add completed assignments (may overlap with scheduled, but that's fine - Map will dedupe)
        if (completedData) {
            completedData.forEach(a => assignmentsMap.set(a.id, a));
        }
        
        const teamAssignments = Array.from(assignmentsMap.values());
        
        // Get unique auditor emails from all assignments (scheduled OR completed in period)
        const auditorEmails = [...new Set(teamAssignments.map(a => a.auditor_email).filter(Boolean))];
        
        // Get user info for all auditors (any role)
        const auditors = auditorEmails.map(email => {
            const user = allUsers.find(u => u.email === email);
            return user || { email, name: email, role: 'Unknown' };
        });
        
        if (auditors.length === 0) {
            const tableBody = document.getElementById('performanceTableBody');
            tableBody.innerHTML = `
                <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                    No auditors found with assignments in the selected date range.
                </div>
            `;
            
            // Reset stats
            document.getElementById('stat1Label').textContent = 'ASSIGNED';
            document.getElementById('stat1Count').textContent = '0';
            document.getElementById('completedCount').textContent = '0';
            document.getElementById('targetAchieved').textContent = '-';
            const remainingCount = document.getElementById('remainingCount');
            if (remainingCount) remainingCount.textContent = '0';
            const completedProgressBar = document.getElementById('completedProgressBar');
            if (completedProgressBar) completedProgressBar.style.display = 'none';
            document.getElementById('stat4Label').textContent = 'IN PROGRESS';
            document.getElementById('stat4Count').textContent = '0';
            document.getElementById('stat4Subtitle').textContent = '-';
            document.getElementById('stat5Label').textContent = 'REVERSALS';
            document.getElementById('stat5Count').textContent = '0';
            const stat5Card = document.getElementById('stat5Card');
            if (stat5Card) stat5Card.style.backgroundColor = 'var(--dark-forest)';
            document.getElementById('stat7Label').textContent = 'PASSING RATE';
            document.getElementById('stat7Count').textContent = '0';
            document.getElementById('stat7Subtitle').textContent = '';
            const stat7PassingCount = document.getElementById('stat7PassingCount');
            const stat7NotPassingCount = document.getElementById('stat7NotPassingCount');
            if (stat7PassingCount) {
                const span = stat7PassingCount.querySelector('span');
                if (span) span.textContent = '0 Passed';
            }
            if (stat7NotPassingCount) {
                const span = stat7NotPassingCount.querySelector('span');
                if (span) span.textContent = '0 Not Passed';
            }
            const stat7Card = document.getElementById('stat7Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
            if (stat7Card) {
                const progressBar = stat7Card.querySelector('.progress-bar-container');
                if (progressBar) progressBar.remove();
            }
            hideLoadingState();
            return;
        }
        
        // Calculate overall team stats
        // Assigned count: assignments scheduled in the period
        const totalAssigned = scheduledAssignments.length;
        const inProgress = scheduledAssignments.filter(a => a.status === 'in_progress').length;
        const pending = scheduledAssignments.filter(a => a.status === 'pending').length;
        // Completed count: assignments that are scheduled in the period AND completed
        // (not just any completed assignment, but ones scheduled for this period)
        const completed = scheduledAssignments.filter(a => a.status === 'completed').length;
        const remaining = pending + inProgress;
        
        // Calculate team average audit duration, reversal count, and passing rate in parallel
        let avgDurationText = '-';
        let avgDurationSubtitle = 'per audit';
        let teamReversalCount = 0;
        let teamPassingRate = 0;
        let teamPassingCount = 0;
        let teamNotPassingCount = 0;
        
        try {
            // Ensure scorecards are loaded
            if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
                await loadScorecards();
            }
            
            // Discover all audit tables using get_audit_tables RPC (matching audit-reports.html)
            let tablesToQuery = [];
            try {
                const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
                
                if (!tablesError && allTables && allTables.length > 0) {
                    // Filter out ai_analysis_results and calibration_results and map to table names
                    tablesToQuery = allTables
                        .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                        .map(t => t.table_name);
                } else {
                    // Fallback: use scorecard tables
                    tablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
                }
            } catch (rpcError) {
                console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
                // Fallback: use scorecard tables
                tablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
            
            if (tablesToQuery.length > 0) {
                // Parallelize all audit table queries
                const queryPromises = tablesToQuery.map(async (tableName) => {
                    try {
                        // Build queries with date filters (count all audits, not just Quality Analysts)
                        let durationQuery = window.supabaseClient
                            .from(tableName)
                            .select('audit_duration, submitted_at')
                            .not('audit_duration', 'is', null);
                        
                        let reversalQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at')
                            .not('reversal_requested_at', 'is', null);
                        
                        let passingQuery = window.supabaseClient
                            .from(tableName)
                            .select('passing_status, submitted_at');
                        
                        // Apply date filters server-side if possible (convert Dhaka to UTC)
                        if (period.start) {
                            durationQuery = durationQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            reversalQuery = reversalQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            passingQuery = passingQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                        }
                        if (period.end) {
                            durationQuery = durationQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            reversalQuery = reversalQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            passingQuery = passingQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                        }
                        
                        // Query for duration, reversals, and passing status in parallel for each table
                        // Note: completed count is now from assignments table, not scorecard tables
                        const [durationResult, reversalResult, passingResult] = await Promise.all([
                            (async () => {
                                try {
                                    let result = await durationQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false; // Exclude if no date when filtering
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('audit_duration, submitted_at')
                                        .not('audit_duration', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await reversalQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at')
                                        .not('reversal_requested_at', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await passingQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('passing_status, submitted_at');
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })()
                        ]);
                        
                        return {
                            durations: durationResult.data || [],
                            reversals: reversalResult.data || [],
                            passing: passingResult.data || []
                        };
                    } catch (err) {
                        console.warn(`Error querying ${tableName}:`, err);
                        return { durations: [], reversals: [], passing: [] };
                    }
                });
                
                const results = await Promise.all(queryPromises);
                
                // Aggregate results
                let totalDuration = 0;
                let auditCount = 0;
                let totalAudits = 0;
                let passedAudits = 0;
                
                results.forEach(result => {
                    result.durations.forEach(audit => {
                        const durationInMinutes = convertDurationToMinutes(audit.audit_duration);
                        if (durationInMinutes > 0) {
                            totalDuration += durationInMinutes;
                            auditCount++;
                        }
                    });
                    teamReversalCount += result.reversals.length;
                    
                    // Count passing rate
                    result.passing.forEach(audit => {
                        totalAudits++;
                        const passingStatus = audit.passing_status || audit.passingStatus;
                        const normalizedStatus = normalizePassingStatus(passingStatus);
                        if (normalizedStatus === 'Passed') {
                            passedAudits++;
                        }
                    });
                });
                
                // Calculate passing rate
                if (totalAudits > 0) {
                    teamPassingRate = Math.round((passedAudits / totalAudits) * 100);
                    teamPassingCount = passedAudits;
                    teamNotPassingCount = totalAudits - passedAudits;
                }
                
                if (auditCount > 0) {
                    const avgDuration = totalDuration / auditCount;
                    avgDurationText = formatDurationText(avgDuration);
                }
            }
            // Note: completed count is from assignments table (assignments created in period with status='completed')
            // This ensures consistency with totalAssigned which is also filtered by created_at
        } catch (error) {
            console.error('Error calculating team stats:', error);
            // completed count remains 0 if there's an error (always use scorecard tables)
        }
        
        // Calculate same-day completed (assignments scheduled and completed on the same day)
        // For the selected period, count assignments that are:
        // 1. Scheduled in the period
        // 2. Completed (regardless of when completed)
        // This means if scheduled for Dec 3 and completed on Dec 1, it counts as completed on Dec 3
        let sameDayCompleted = completed; // Already filtered to scheduled assignments that are completed
        
        const percentage = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        console.log('Team Stats - Reversal count:', teamReversalCount);
        console.log('Team Stats - Completed count:', completed);
        
        // Ensure scorecards are loaded
        if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
            await loadScorecards();
        }
        
        // Discover all audit tables using get_audit_tables RPC (matching audit-reports.html)
        let auditorTablesToQuery = [];
        try {
            const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
            
            if (!tablesError && allTables && allTables.length > 0) {
                // Filter out ai_analysis_results and calibration_results and map to table names
                auditorTablesToQuery = allTables
                    .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                    .map(t => t.table_name);
            } else {
                // Fallback: use scorecard tables
                auditorTablesToQuery = cachedScorecardTables.length > 0 
            ? cachedScorecardTables 
            : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
        } catch (rpcError) {
            console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
            // Fallback: use scorecard tables
            auditorTablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
        }
        
        // Parallelize all auditor duration queries
        const auditorDurationPromises = auditors.map(async (qa) => {
            // Get assignments scheduled in period for this auditor
            const qaScheduledAssignments = scheduledAssignments.filter(a => a.auditor_email === qa.email);
            
            // Get assignments completed in period for this auditor
            const qaCompletedInPeriod = completedData ? completedData.filter(a => a.auditor_email === qa.email) : [];
            
            // For stats: 
            // - Assigned: assignments scheduled in the period
            // - Completed: assignments that are BOTH scheduled in period AND completed
            //   (not just any completed assignment, but ones scheduled for this period)
            const qaInProgress = qaScheduledAssignments.filter(a => a.status === 'in_progress').length;
            const qaPending = qaScheduledAssignments.filter(a => a.status === 'pending').length;
            
            // Completed count: only count assignments that are scheduled in this period AND completed
            // This means if an assignment is scheduled for Dec 3 and completed, it shows as completed on Dec 3
            // If it's scheduled for Dec 3 but completed on Dec 1, it still shows as completed on Dec 3 (not Dec 1)
            const qaCompleted = qaScheduledAssignments.filter(a => a.status === 'completed').length;
            const qaRemaining = qaPending + qaInProgress;
            
            // For duration calculation, we need all assignments for this auditor
            const qaAssignments = teamAssignments.filter(a => a.auditor_email === qa.email);
            
            // Calculate average duration by querying scorecard tables (based on submitted_at)
            let avgDurationText = '-';
            try {
                if (auditorTablesToQuery.length > 0) {
                    const durationPromises = auditorTablesToQuery.map(async (tableName) => {
                        try {
                            // Build query with date filters for duration
                            let query = window.supabaseClient
                                .from(tableName)
                                .select('audit_duration, submitted_at')
                                .eq('auditor_email', qa.email)
                                .not('audit_duration', 'is', null);
                            
                            // Apply date filters server-side if possible (convert Dhaka to UTC)
                            if (period.start) {
                                query = query.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            }
                            if (period.end) {
                                query = query.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            }
                            
                            // Query duration (we use assignments table for completed count, not scorecard tables)
                            const durationResult = await query;
                            
                            // Check if error is due to missing auditor_email column - skip this table if so
                            // Only skip if error message specifically mentions auditor_email
                            if (durationResult.error) {
                                const errorMessage = durationResult.error.message || JSON.stringify(durationResult.error);
                                if (errorMessage.includes('auditor_email') && 
                                    (durationResult.error.code === '42703' || durationResult.error.code === 'PGRST116')) {
                                    console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                    return { audits: [] };
                                }
                            }
                            
                            let audits = durationResult.data;
                            let error = durationResult.error;
                            
                            // If server-side date filter fails, try without date filter and filter client-side
                            if (error && period && (period.start || period.end)) {
                                const retryQuery = window.supabaseClient
                                    .from(tableName)
                                    .select('audit_duration, submitted_at')
                                    .eq('auditor_email', qa.email)
                                    .not('audit_duration', 'is', null);
                                
                                const retryResult = await retryQuery;
                                
                                // Check if error is due to missing auditor_email column - skip this table if so
                                if (retryResult.error) {
                                    const retryErrorMessage = retryResult.error.message || JSON.stringify(retryResult.error);
                                    if (retryErrorMessage.includes('auditor_email') && 
                                        (retryResult.error.code === '42703' || retryResult.error.code === 'PGRST116')) {
                                        console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                        return { audits: [] };
                                    }
                                }
                                
                                if (retryResult.data && period.start) {
                                    retryResult.data = retryResult.data.filter(audit => {
                                        if (!audit.submitted_at) return false;
                                        const auditDate = toDhakaTime(audit.submitted_at);
                                        return (!period.start || auditDate >= period.start) && 
                                               (!period.end || auditDate <= period.end);
                                    });
                                }
                                
                                audits = retryResult.data;
                                error = retryResult.error;
                            }
                            
                            if (error) {
                                return { audits: [] };
                            }
                            
                            // Fallback client-side filtering if needed
                            let filteredAudits = audits || [];
                            
                            // Apply client-side date filtering if period exists
                            if (period && (period.start || period.end)) {
                                filteredAudits = filteredAudits.filter(audit => {
                                    if (!audit.submitted_at) return false;
                                    const auditDate = toDhakaTime(audit.submitted_at);
                                    return (!period.start || auditDate >= period.start) && 
                                           (!period.end || auditDate <= period.end);
                                });
                            }
                            
                            return { audits: filteredAudits };
                        } catch (err) {
                            console.warn(`Error getting duration from ${tableName} for ${qa.email}:`, err);
                            return { audits: [] };
                        }
                    });
                    
                    const allResults = await Promise.all(durationPromises);
                    const flatAudits = allResults.flatMap(r => r.audits);
                    
                    // Calculate average duration from audits submitted in the period
                    let totalDuration = 0;
                    let auditCount = 0;
                    
                    flatAudits.forEach(audit => {
                        const durationInMinutes = convertDurationToMinutes(audit.audit_duration);
                        if (durationInMinutes > 0) {
                            totalDuration += durationInMinutes;
                            auditCount++;
                        }
                    });
                    
                    if (auditCount > 0) {
                        const avgDuration = totalDuration / auditCount;
                        avgDurationText = formatDurationText(avgDuration);
                    }
                }
                // Note: qaCompleted count is from assignments table (assignments created in period with status='completed')
                // This ensures consistency with qaAssignments which is also filtered by created_at
            } catch (error) {
                console.error(`Error calculating stats for ${qa.email}:`, error);
                // qaCompleted count remains 0 if there's an error (always use scorecard tables)
            }
            
            // Calculate backlog and early completions: Assignments completed in the period but scheduled for a different day
            // Early = completed before scheduled_date
            // Backlog = completed after scheduled_date
            // Use Dhaka timezone for date comparison to match the rest of the dashboard
            let backlogCount = 0;
            let earlyCount = 0;
            let backlogDates = []; // Store dates when backlog audits were scheduled
            let earlyDates = []; // Store dates when early audits were scheduled
            try {
                // Get assignments completed in the period for this auditor
                const qaCompletedInPeriod = completedData ? completedData.filter(a => a.auditor_email === qa.email) : [];
                
                if (qaCompletedInPeriod.length > 0 && period) {
                    // Separate early and backlog items
                    const earlyItems = [];
                    const backlogItems = [];
                    
                    qaCompletedInPeriod.forEach(a => {
                        if (!a.completed_at) return;
                        const completedDate = toDhakaTime(a.completed_at);
                        // Check if completed date falls within the period
                        const inPeriod = (!period.start || completedDate >= period.start) && 
                                        (!period.end || completedDate <= period.end);
                        if (!inPeriod) return;
                        
                        // Check if scheduled_date is different from completed date
                        let scheduledDate;
                        if (a.scheduled_date) {
                            scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                        } else if (a.created_at) {
                            scheduledDate = getDhakaStartOfDay(a.created_at);
                        } else {
                            return; // No scheduled date to compare
                        }
                        
                        const completedDay = getDhakaStartOfDay(completedDate);
                        const scheduledDay = getDhakaStartOfDay(scheduledDate);
                        
                        // If scheduled date is different from completed date
                        if (scheduledDay.getTime() !== completedDay.getTime()) {
                            // Early = completed before scheduled date
                            if (completedDay.getTime() < scheduledDay.getTime()) {
                                earlyItems.push(a);
                            } else {
                                // Backlog = completed after scheduled date
                                backlogItems.push(a);
                            }
                        }
                    });
                
                earlyCount = earlyItems.length;
                backlogCount = backlogItems.length;
                
                earlyDates = [...new Set(earlyItems.map(a => {
                    let scheduledDate;
                    if (a.scheduled_date) {
                        scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                    } else if (a.created_at) {
                        scheduledDate = getDhakaStartOfDay(a.created_at);
                    } else {
                        return 'Unknown';
                    }
                    return formatDhakaDate(scheduledDate, { year: 'numeric', month: 'short', day: 'numeric' });
                }))].sort();
                
                backlogDates = [...new Set(backlogItems.map(a => {
                    let scheduledDate;
                    if (a.scheduled_date) {
                        scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                    } else if (a.created_at) {
                        scheduledDate = getDhakaStartOfDay(a.created_at);
                    } else {
                        return 'Unknown';
                    }
                    return formatDhakaDate(scheduledDate, { year: 'numeric', month: 'short', day: 'numeric' });
                }))].sort();
                }
            } catch (error) {
                console.warn(`Error calculating backlog/early for ${qa.email}:`, error);
                backlogCount = 0;
                earlyCount = 0;
                backlogDates = [];
                earlyDates = [];
            }
            
            // Calculate same-day completed: assignments scheduled in the period that are completed
            // This means if scheduled for Dec 3 and completed (even on Dec 1), it counts as completed on Dec 3
            // Backlog is separate - it's assignments completed in the period but scheduled for a different day
            let sameDayCompleted = qaCompleted; // Already filtered to scheduled assignments that are completed
            
            // Use scheduled assignments count for percentage calculation
            const qaPercentage = qaScheduledAssignments.length > 0 ? Math.round((sameDayCompleted / qaScheduledAssignments.length) * 100) : 0;
            
            return {
                name: qa.name || qa.email,
                email: qa.email,
                assigned: qaScheduledAssignments.length, // Count of assignments scheduled in period
                completed: sameDayCompleted, // Count of assignments completed in period (same-day only, excluding backlog/early)
                remaining: qaRemaining,
                percentage: qaPercentage,
                avgDuration: avgDurationText,
                backlogCovered: backlogCount,
                backlogDates: backlogDates,
                earlyCovered: earlyCount,
                earlyDates: earlyDates,
                isCurrentUser: qa.email === currentUserEmail
            };
        });
        
        const auditorStats = await Promise.all(auditorDurationPromises);
        
        // Sort by assigned count (descending) and then by name
        auditorStats.sort((a, b) => {
            if (b.assigned !== a.assigned) {
                return b.assigned - a.assigned;
            }
            return a.name.localeCompare(b.name);
        });
        
        // Calculate total backlog and early counts from all auditors
        const totalBacklogCount = auditorStats.reduce((sum, auditor) => sum + (auditor.backlogCovered || 0), 0);
        const totalEarlyCount = auditorStats.reduce((sum, auditor) => sum + (auditor.earlyCovered || 0), 0);
        
        // Note: sameDayCompleted is already calculated above, excluding backlog
        // Recalculate percentage based on same-day completed count (already done above)
        const adjustedPercentage = percentage;
        
        // Prepare the stats data
        const statsData = {
            totalAssigned,
            completed: sameDayCompleted, // Same-day completed count (excluding backlog/early)
            inProgress,
            pending,
            remaining,
            percentage: adjustedPercentage,
            avgDurationText,
            avgDurationSubtitle,
            teamReversalCount,
            teamPassingRate,
            teamPassingCount,
            teamNotPassingCount,
            totalBacklogCount,
            totalEarlyCount,
            auditorStats,
            auditorsCount: auditors.length,
            period: period
        };
        
        // Check if this fetch is still the current one before updating UI
        if (fetchId !== currentFetchId) {
            console.log('Team stats fetch cancelled - newer fetch in progress');
            return;
        }
        
        // Update UI with fresh data (only if still on Team Stats tab)
        if (currentTab === 0) {
            console.log('Updating UI with fresh team stats');
            await renderTeamStats(statsData);
            
            // Show hourly breakdown in Team Stats view
            const hourlyBreakdownTable = document.getElementById('hourlyBreakdownTable');
            if (hourlyBreakdownTable) {
                hourlyBreakdownTable.style.display = 'block';
            }
            
            // Show dynamic hourly breakdown in Team Stats view
            const dynamicHourlyBreakdownTable = document.getElementById('dynamicHourlyBreakdownTable');
            if (dynamicHourlyBreakdownTable) {
                dynamicHourlyBreakdownTable.style.display = 'block';
            }
            
            // Load and render dynamic hourly breakdown
            if (period && statsData.auditorStats) {
                await renderDynamicHourlyBreakdown(period, statsData.auditorStats, statsData.totalAssigned);
            }
            
            // Load and render hourly breakdown
            if (period && statsData.auditorStats) {
                await renderHourlyBreakdown(period, statsData.auditorStats, statsData.totalAssigned);
            }
            
            // Update online status indicators after rendering
            setTimeout(() => updateOnlineStatusIndicators(), 100);
            hideLoadingState();
        } else {
            console.log('Skipping team stats render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading team stats:', error);
        hideLoadingState();
        
        // Show error message in table
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && currentTab === 0) {
            tableBody.innerHTML = `
                <div style="text-align: center; padding: 1.5rem; color: #ef4444;">
                    Error loading data. Please refresh the page.
                </div>
            `;
        }
        
        // Reset stats to default values
        try {
            document.getElementById('stat1Label').textContent = 'ASSIGNED';
            document.getElementById('stat1Count').textContent = '0';
            document.getElementById('completedCount').textContent = '0';
            document.getElementById('targetAchieved').textContent = '-';
            const remainingCount = document.getElementById('remainingCount');
            if (remainingCount) remainingCount.textContent = '0';
            const completedProgressBar = document.getElementById('completedProgressBar');
            if (completedProgressBar) completedProgressBar.style.display = 'none';
            document.getElementById('stat4Label').textContent = 'IN PROGRESS';
            document.getElementById('stat4Count').textContent = '0';
            document.getElementById('stat4Subtitle').textContent = '-';
            document.getElementById('stat5Label').textContent = 'REVERSALS';
            document.getElementById('stat5Count').textContent = '0';
            const stat5Card = document.getElementById('stat5Card');
            if (stat5Card) stat5Card.style.backgroundColor = 'var(--dark-forest)';
            document.getElementById('stat7Label').textContent = 'PASSING RATE';
            document.getElementById('stat7Count').textContent = '0';
            document.getElementById('stat7Subtitle').textContent = '';
            const stat7PassingCount = document.getElementById('stat7PassingCount');
            const stat7NotPassingCount = document.getElementById('stat7NotPassingCount');
            if (stat7PassingCount) {
                const span = stat7PassingCount.querySelector('span');
                if (span) span.textContent = '0 Passed';
            }
            if (stat7NotPassingCount) {
                const span = stat7NotPassingCount.querySelector('span');
                if (span) span.textContent = '0 Not Passed';
            }
            const stat7Card = document.getElementById('stat7Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
            if (stat7Card) {
                const progressBar = stat7Card.querySelector('.progress-bar-container');
                if (progressBar) progressBar.remove();
            }
        } catch (e) {
            // Ignore errors if elements don't exist
        }
    }
}

async function renderTeamStats(statsData) {
    const {
        totalAssigned,
        completed,
        inProgress,
        remaining,
        percentage,
        avgDurationText,
        avgDurationSubtitle,
        teamReversalCount,
        teamPassingRate,
        teamPassingCount,
        teamNotPassingCount,
        totalBacklogCount,
        totalEarlyCount,
        auditorStats,
        period
    } = statsData;
    
    // Get auditors from stats data (any role, not just Quality Analysts)
    const auditorsCount = statsData.auditorsCount || auditorStats.length;
    
    // Get stat card elements once at the top of the function
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    const stat7Card = document.getElementById('stat7Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    
    if (auditorStats.length === 0) {
        const tableBody = document.getElementById('performanceTableBody');
        tableBody.innerHTML = `
            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                No Quality Analysts found in the system.
            </div>
        `;
        
        // Reset stats
        document.getElementById('stat1Label').textContent = 'ASSIGNED';
        document.getElementById('stat1Count').textContent = '0';
        document.getElementById('stat1Avg').textContent = 'Avg: -';
        document.getElementById('stat1Max').textContent = 'Max: -';
        document.getElementById('stat1Min').textContent = 'Min: -';
        document.getElementById('completedCount').textContent = '0';
        document.getElementById('targetAchieved').textContent = '-';
        const remainingCount = document.getElementById('remainingCount');
        if (remainingCount) remainingCount.textContent = '0';
        const completedProgressBar = document.getElementById('completedProgressBar');
        if (completedProgressBar) completedProgressBar.style.display = 'none';
        document.getElementById('stat4Label').textContent = 'IN PROGRESS';
        document.getElementById('stat4Count').textContent = '0';
        document.getElementById('stat4Subtitle').textContent = '-';
        document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
        document.getElementById('stat5Count').textContent = '0';
        const stat5Card = document.getElementById('stat5Card');
        if (stat5Card) stat5Card.style.backgroundColor = 'var(--dark-forest)';
        document.getElementById('stat7Label').textContent = 'PASSING RATE';
        document.getElementById('stat7Count').textContent = '0';
        document.getElementById('stat7Subtitle').textContent = '';
        const stat7PassingCount = document.getElementById('stat7PassingCount');
        const stat7NotPassingCount = document.getElementById('stat7NotPassingCount');
        if (stat7PassingCount) {
            const span = stat7PassingCount.querySelector('span');
            if (span) span.textContent = '0 Passed';
        }
        if (stat7NotPassingCount) {
            const span = stat7NotPassingCount.querySelector('span');
            if (span) span.textContent = '0 Not Passed';
        }
        const stat7Card = document.getElementById('stat7Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
        if (stat7Card) {
            const progressBar = stat7Card.querySelector('.progress-bar-container');
            if (progressBar) progressBar.remove();
        }
        return;
    }
    
    // Hide the 4th card (IN PROGRESS) in Team Stats - not used in Team Stats
    // Show the 6th and 7th stat cards (in case they were hidden in standup view)
    if (stat4Card) {
        stat4Card.style.display = 'none';
    }
    
    const stat6Card = document.getElementById('stat6Count').closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'flex';
    }
    
    // Show stat7Card (Passing Rate) in Team Stats
    if (stat7Card) {
        stat7Card.style.display = 'flex';
    }
    
    // Calculate workload metrics (average, max, min assigned per auditor)
    let avgAssigned = 0;
    let maxAssigned = 0;
    let minAssigned = 0;
    
    if (auditorStats.length > 0) {
        const assignedCounts = auditorStats.map(s => s.assigned || 0);
        const totalAssignedCount = assignedCounts.reduce((sum, count) => sum + count, 0);
        avgAssigned = Math.round((totalAssignedCount / auditorStats.length) * 10) / 10; // Round to 1 decimal
        maxAssigned = Math.max(...assignedCounts);
        minAssigned = Math.min(...assignedCounts.filter(c => c > 0)); // Exclude 0 if there are any non-zero values
        if (minAssigned === Infinity || minAssigned === -Infinity) {
            minAssigned = 0; // If all are 0, set min to 0
        }
    }
    
    // Update stat cards with team stats
    document.getElementById('stat1Label').textContent = 'ASSIGNED';
    document.getElementById('stat1Count').textContent = totalAssigned;
    document.getElementById('stat1Avg').textContent = `Avg: ${avgAssigned}`;
    document.getElementById('stat1Max').textContent = `Max: ${maxAssigned}`;
    document.getElementById('stat1Min').textContent = `Min: ${minAssigned}`;
    document.getElementById('completedCount').textContent = completed;
    
    // Update backlog and early count text next to completed count
    const backlogCountText = document.getElementById('backlogCountText');
    if (backlogCountText) {
        const backlogCount = totalBacklogCount || 0;
        const earlyCount = totalEarlyCount || 0;
        const parts = [];
        if (backlogCount > 0) {
            parts.push(`+${backlogCount} Backlog`);
        }
        if (earlyCount > 0) {
            parts.push(`+${earlyCount} Early`);
        }
        if (parts.length > 0) {
            backlogCountText.textContent = parts.join(', ');
            backlogCountText.style.display = 'block';
        } else {
            backlogCountText.textContent = '';
            backlogCountText.style.display = 'none';
        }
    }
    
    // Update remaining count in separate remaining card
    const remainingCount = document.getElementById('remainingCount');
    if (remainingCount) {
    remainingCount.textContent = remaining;
    }
    
    // Update progress bar in completed card with temperature-based color
    const completedProgressBar = document.getElementById('completedProgressBar');
    if (completedProgressBar) {
        const progressBarFill = completedProgressBar.querySelector('div');
        if (progressBarFill && totalAssigned > 0) {
            const progressPercentage = Math.min(100, Math.round((completed / totalAssigned) * 100));
            progressBarFill.style.width = `${progressPercentage}%`;
            progressBarFill.style.background = getProgressBarColor(progressPercentage);
            completedProgressBar.style.display = 'block';
        } else {
            completedProgressBar.style.display = 'none';
        }
    }
    
    document.getElementById('targetAchieved').textContent = `${percentage}% Target Achieved`;
    
    // Update 5th card to REVERSALS
    document.getElementById('stat5Label').textContent = 'REVERSALS';
    document.getElementById('stat5Count').textContent = teamReversalCount;
    document.getElementById('stat5Subtitle').textContent = '';
    
    // Change card background to red if reversal count > 0
    const stat5Card = document.getElementById('stat5Card');
    if (stat5Card) {
        if (teamReversalCount > 0) {
            stat5Card.style.backgroundColor = '#dc2626'; // Darker red color
        } else {
            stat5Card.style.backgroundColor = 'var(--dark-forest)'; // Default dark forest color
        }
    }
    
    // Update 6th card to AVG DURATION
    document.getElementById('stat6Label').textContent = 'AVG DURATION';
    document.getElementById('stat6Count').textContent = avgDurationText;
    document.getElementById('stat6Subtitle').textContent = avgDurationSubtitle;
    
    // Update 7th card to PASSING RATE (new card)
    // stat7Card is already declared at the top of the function
    document.getElementById('stat7Label').textContent = 'PASSING RATE';
    const stat7Count = document.getElementById('stat7Count');
    if (stat7Count) {
        stat7Count.style.fontSize = '2.625rem';
        stat7Count.textContent = (teamPassingRate || 0) + '%';
        
        // Update chips with passing and not passing counts
        const passingCount = teamPassingCount || 0;
        const notPassingCount = teamNotPassingCount || 0;
        const stat7PassingCount = document.getElementById('stat7PassingCount');
        const stat7NotPassingCount = document.getElementById('stat7NotPassingCount');
        
        if (stat7PassingCount) {
            const span = stat7PassingCount.querySelector('span');
            if (span) span.textContent = `${passingCount} Passed`;
        }
        if (stat7NotPassingCount) {
            const span = stat7NotPassingCount.querySelector('span');
            if (span) span.textContent = `${notPassingCount} Not Passed`;
        }
        
        // Add/update progress bar
        let progressContainer = stat7Card?.querySelector('.progress-bar-container');
        if (!progressContainer && stat7Card) {
            progressContainer = document.createElement('div');
            progressContainer.className = 'progress-bar-container';
            progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
            const stat7Subtitle = document.getElementById('stat7Subtitle');
            if (stat7Subtitle && stat7Subtitle.parentElement) {
                stat7Subtitle.parentElement.insertBefore(progressContainer, stat7Subtitle);
            }
        }
        if (progressContainer) {
            const passingRate = teamPassingRate || 0;
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${passingRate}%;"></div>`;
        }
        
        // Clear subtitle (chips now show the counts)
        const stat7Subtitle = document.getElementById('stat7Subtitle');
        if (stat7Subtitle) {
            stat7Subtitle.textContent = '';
        }
    }
    
    // Update table header
    const tableHeader = document.getElementById('tableHeader');
    tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr)';
    tableHeader.style.display = 'grid';
    tableHeader.style.gap = '0.75rem';
    tableHeader.style.alignItems = 'center';
    tableHeader.innerHTML = `
        <div>Name</div>
        <div style="text-align: center;">Assigned</div>
        <div style="text-align: center;">Completed</div>
        <div style="text-align: center;">Remaining</div>
        <div style="text-align: center;">Avg Duration</div>
        <div style="text-align: center;">Progress Meter</div>
    `;
    
    // Update table with all auditors (any role)
    const tableBody = document.getElementById('performanceTableBody');
    tableBody.innerHTML = auditorStats.map(stats => {
        // Build tooltip text for backlog and early
        let backlogTooltip = '';
        let earlyTooltip = '';
        if (stats.backlogCovered > 0 && stats.backlogDates && stats.backlogDates.length > 0) {
            const datesText = stats.backlogDates.join(', ');
            backlogTooltip = `${stats.backlogCovered} backlog covered from ${datesText}`;
        }
        if (stats.earlyCovered > 0 && stats.earlyDates && stats.earlyDates.length > 0) {
            const datesText = stats.earlyDates.join(', ');
            earlyTooltip = `${stats.earlyCovered} early completed for ${datesText}`;
        }
        
        return `
        <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6; ${stats.isCurrentUser ? 'background-color: #f0fdf4;' : ''}" data-auditor-email="${escapeHtml(stats.email)}">
            <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600; display: flex; align-items: center;" data-label="Name">
                ${escapeHtml(stats.name)}${stats.isCurrentUser ? ' <span style="color: var(--primary-color); font-size: 0.5625rem;">(You)</span>' : ''}
                ${onlineAuditors.has(stats.email) ? '<span class="online-indicator" style="display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);" title="Online"></span>' : ''}
            </div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Assigned">${stats.assigned}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Completed">
                <div style="display: inline-flex; align-items: baseline; gap: 0.25rem; flex-wrap: wrap; justify-content: center;">
                    <span>${stats.completed}</span>
                    ${stats.earlyCovered > 0 ? `<span style="font-size: 0.5rem; color: #10b981; font-weight: 600; cursor: help;" title="${escapeHtml(earlyTooltip)}">+${stats.earlyCovered} Early</span>` : ''}
                    ${stats.backlogCovered > 0 ? `<span style="font-size: 0.5rem; color: #f59e0b; font-weight: 600; cursor: help;" title="${escapeHtml(backlogTooltip)}">+${stats.backlogCovered} Backlog</span>` : ''}
                </div>
            </div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Remaining">${stats.remaining}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Avg Duration">${stats.avgDuration}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Progress">
                <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: center;">
                    <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage}%</span>
                    <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative; max-width: 5rem;">
                        <div style="height: 100%; background: ${getProgressBarColor(stats.percentage)}; border-radius: 0.2812rem; transition: width 0.3s ease; width: ${stats.percentage}%;"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
    }).join('');
    
    // Update online status indicators after rendering
    setTimeout(() => updateOnlineStatusIndicators(), 100);
}

let hourlyChartInstance = null;
let dynamicHourlyChartInstance = null;

function renderHourlyChart(labels, data, targetPerHour = 0, workingHours = [], sortedHours = []) {
    try {
        // Validate inputs
        if (!labels || !Array.isArray(labels) || labels.length === 0) {
            console.warn('Invalid chart labels');
            return;
        }
        if (!data || !Array.isArray(data) || data.length === 0) {
            console.warn('Invalid chart data');
            return;
        }
        
        const canvas = document.getElementById('hourlyChart');
        if (!canvas) {
            console.warn('Hourly chart canvas not found');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.warn('Could not get chart context');
            return;
        }
        
        // Destroy existing chart if it exists
        if (hourlyChartInstance) {
            hourlyChartInstance.destroy();
            hourlyChartInstance = null;
        }
        
        // Create target line data (target for working hours, null for others)
        const targetData = sortedHours && workingHours ? sortedHours.map(hour => {
            const isWorkingHour = workingHours.includes(hour);
            return isWorkingHour ? targetPerHour : null;
        }) : [];
        
        // Calculate dynamic Y-axis max based on target and actual data
        const maxDataValue = Math.max(...data, 0);
        const maxValue = Math.max(maxDataValue, targetPerHour);
        // Add 20% padding and round up to nearest 0.5
        const yAxisMax = Math.ceil(maxValue * 1.2 * 2) / 2;
        
        hourlyChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Total Audits',
                    data: data,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    pointBackgroundColor: '#10b981',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2
                },
                {
                    label: 'Target',
                    data: targetData,
                    borderColor: '#f59e0b',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        font: {
                            size: 11
                        },
                        usePointStyle: true,
                        padding: 15
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    padding: 12,
                    titleFont: {
                        size: 12,
                        weight: '600'
                    },
                    bodyFont: {
                        size: 11
                    },
                    callbacks: {
                        label: function(context) {
                            if (context.datasetIndex === 0) {
                                // Main data line
                                const value = context.parsed.y;
                                const hourIndex = context.dataIndex;
                                if (sortedHours && sortedHours.length > hourIndex) {
                                    const hour = sortedHours[hourIndex];
                                    const isWorkingHour = workingHours && workingHours.includes(hour);
                                    
                                    if (isWorkingHour && targetPerHour > 0) {
                                        const status = value >= targetPerHour ? ' (Target Met )' : ' (Target Not Met )';
                                        return value + ' audits' + status;
                                    }
                                }
                                return value + ' audits';
                            } else {
                                // Target line
                                if (context.parsed.y !== null) {
                                    return 'Target: ' + context.parsed.y + ' audits';
                                }
                                return '';
                            }
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yAxisMax,
                    ticks: {
                        stepSize: yAxisMax <= 10 ? 1 : (yAxisMax <= 20 ? 2 : Math.ceil(yAxisMax / 10)),
                        font: {
                            size: 10
                        },
                        color: '#6b7280'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                x: {
                    ticks: {
                        font: {
                            size: 10
                        },
                        color: '#6b7280',
                        maxRotation: 45,
                        minRotation: 45
                    },
                    grid: {
                        display: false
                    }
                }
            }
        },
        plugins: [
            {
                id: 'datalabels',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, i) => {
                        const meta = chart.getDatasetMeta(i);
                        meta.data.forEach((point, index) => {
                            const value = dataset.data[index];
                            if (i === 0) {
                                // Show labels for actual data
                                if (value > 0) {
                                    const x = point.x;
                                    const y = point.y;
                                    const text = value.toString();
                                    ctx.save();
                                    ctx.font = '600 10px Poppins';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'bottom';
                                    
                                    // Draw white background/stroke for visibility
                                    ctx.strokeStyle = '#ffffff';
                                    ctx.lineWidth = 3;
                                    ctx.lineJoin = 'round';
                                    ctx.miterLimit = 2;
                                    ctx.strokeText(text, x, y - 8);
                                    
                                    // Draw the actual text
                                    ctx.fillStyle = '#10b981';
                                    ctx.fillText(text, x, y - 8);
                                    ctx.restore();
                                }
                            } else if (i === 1) {
                                // Show labels for target line (above the point)
                                if (value !== null && value !== undefined && value > 0) {
                                    const x = point.x;
                                    const y = point.y;
                                    const text = value.toFixed(1);
                                    ctx.save();
                                    ctx.font = '600 10px Poppins';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'bottom';
                                    
                                    // Draw white background/stroke for visibility
                                    ctx.strokeStyle = '#ffffff';
                                    ctx.lineWidth = 3;
                                    ctx.lineJoin = 'round';
                                    ctx.miterLimit = 2;
                                    ctx.strokeText(text, x, y - 8);
                                    
                                    // Draw the actual text
                                    ctx.fillStyle = '#f59e0b';
                                    ctx.fillText(text, x, y - 8);
                                    ctx.restore();
                                }
                            }
                        });
                    });
                }
            },
            {
                id: 'targetLines',
                afterDatasetsDraw: (chart) => {
                    if (!sortedHours || !workingHours || targetPerHour <= 0) return;
                    
                    const ctx = chart.ctx;
                    const meta0 = chart.getDatasetMeta(0); // Actual data
                    const meta1 = chart.getDatasetMeta(1); // Target line
                    
                    sortedHours.forEach((hour, index) => {
                        const isWorkingHour = workingHours.includes(hour);
                        if (!isWorkingHour) return;
                        
                        const actualPoint = meta0.data[index];
                        const targetPoint = meta1.data[index];
                        
                        if (!actualPoint || !targetPoint || targetPoint.y === null) return;
                        
                        const actualValue = data[index] || 0;
                        const targetValue = targetPerHour;
                        
                        // Only draw line if there's a difference
                        if (Math.abs(actualValue - targetValue) > 0.01) {
                            ctx.save();
                            
                            // Color: red if below target, green if above
                            ctx.strokeStyle = actualValue >= targetValue ? '#10b981' : '#ef4444';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([]);
                            
                            // Draw vertical line from target to actual
                            ctx.beginPath();
                            ctx.moveTo(actualPoint.x, targetPoint.y);
                            ctx.lineTo(actualPoint.x, actualPoint.y);
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    });
                }
            },
            {
                id: 'lunchBreak',
                beforeDatasetsDraw: (chart) => {
                    if (!sortedHours) return;
                    
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const xScale = chart.scales.x;
                    const yScale = chart.scales.y;
                    
                    // Find indices for lunch break hours (13:30 to 14:30)
                    const lunchStartIndex = sortedHours.findIndex(hour => hour === '13:30');
                    const lunchEndIndex = sortedHours.findIndex(hour => hour === '14:30');
                    
                    if (lunchStartIndex === -1 || lunchEndIndex === -1) return;
                    
                    const meta0 = chart.getDatasetMeta(0);
                    if (!meta0.data[lunchStartIndex] || !meta0.data[lunchEndIndex]) return;
                    
                    const startX = meta0.data[lunchStartIndex].x;
                    const endX = meta0.data[lunchEndIndex].x;
                    const width = endX - startX;
                    
                    // Draw shaded rectangle for lunch break (from 1:30 to 2:30)
                    ctx.save();
                    ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
                    ctx.fillRect(startX, chartArea.top, width, chartArea.bottom - chartArea.top);
                    ctx.restore();
                    
                    // Add vertical text label centered between 1:30 and 2:30, vertically centered in chart
                    ctx.save();
                    ctx.fillStyle = '#f59e0b';
                    ctx.font = '600 9px Poppins';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    ctx.translate(startX + width / 2, centerY);
                    ctx.rotate(-Math.PI / 2); // Rotate 90 degrees counterclockwise
                    ctx.fillText('Lunch Break', 0, 0);
                    ctx.restore();
                }
            }
        ]
    });
    } catch (error) {
        console.error('Error rendering hourly chart:', error);
    }
}

async function renderHourlyBreakdown(period, auditorStats, totalAssigned = 0) {
    try {
        // Only show hourly breakdown in Team Stats view
        if (currentTab !== 0) {
            const hourlyTableBody = document.getElementById('hourlyTableBody');
            if (hourlyTableBody) {
                hourlyTableBody.innerHTML = '';
            }
            // Clear chart
            if (hourlyChartInstance) {
                hourlyChartInstance.destroy();
                hourlyChartInstance = null;
            }
            return;
        }
        
        const hourlyTableBody = document.getElementById('hourlyTableBody');
        if (!hourlyTableBody) return;
        
        // Check if auditorStats is valid
        if (!auditorStats || !Array.isArray(auditorStats) || auditorStats.length === 0) {
            hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No auditors found</div>';
            return;
        }
        
        // Check if period is valid
        if (!period) {
            hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No date range selected</div>';
            return;
        }
        
        hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>';
        
        // Ensure scorecards are loaded
        if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
            await loadScorecards();
        }
        
        // Discover all audit tables
        let tablesToQuery = [];
        try {
            const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
            
            if (!tablesError && allTables && allTables.length > 0) {
                tablesToQuery = allTables
                    .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                    .map(t => t.table_name);
            } else {
                tablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
        } catch (rpcError) {
            console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
            tablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
        }
        
        if (tablesToQuery.length === 0) {
            hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No audit data available</div>';
            return;
        }
        
        // Query all audits with submitted_at and auditor_email
        const auditPromises = tablesToQuery.map(async (tableName) => {
            try {
                let query = window.supabaseClient
                    .from(tableName)
                    .select('submitted_at, auditor_email')
                    .not('submitted_at', 'is', null);
                
                // Apply date filters
                if (period.start) {
                    query = query.gte('submitted_at', dhakaDateToUTCISO(period.start));
                }
                if (period.end) {
                    query = query.lte('submitted_at', dhakaDateToUTCISO(period.end));
                }
                
                const result = await query;
                
                // Check if error is due to missing auditor_email column
                if (result.error) {
                    const errorMessage = result.error.message || JSON.stringify(result.error);
                    if (errorMessage.includes('auditor_email') && 
                        (result.error.code === '42703' || result.error.code === 'PGRST116')) {
                        console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                        return [];
                    }
                    throw result.error;
                }
                
                // Filter client-side if needed
                let audits = result.data || [];
                if (period.start) {
                    audits = audits.filter(audit => {
                        if (!audit.submitted_at) return false;
                        const auditDate = toDhakaTime(audit.submitted_at);
                        return (!period.start || auditDate >= period.start) && 
                               (!period.end || auditDate <= period.end);
                    });
                }
                
                return audits;
            } catch (err) {
                console.warn(`Error querying ${tableName} for hourly breakdown:`, err);
                return [];
            }
        });
        
        const allAuditResults = await Promise.all(auditPromises);
        const allAudits = allAuditResults.flat();
        
        // Group by hour starting at :30 minutes (in Dhaka timezone) and auditor
        // Starting at 9:30 AM, ending at 9:30 PM
        const hourlyData = {};
        
        allAudits.forEach(audit => {
            if (!audit.submitted_at) return;
            
            const submittedDate = toDhakaTime(audit.submitted_at);
            const hour = submittedDate.getHours();
            const minutes = submittedDate.getMinutes();
            
            // Group by hour starting at :30 (9:30-10:29 -> 9:30, 10:30-11:29 -> 10:30, etc.)
            let groupHour = hour;
            
            // If minutes < 30, it belongs to the previous hour's :30 slot
            if (minutes < 30) {
                groupHour = hour - 1;
                if (groupHour < 0) groupHour = 23; // Handle midnight edge case
            }
            
            // Only include hours from 9:30 to 21:30 (9 AM to 9 PM at :30)
            if (groupHour < 9 || groupHour > 21) {
                return; // Skip audits outside the shift hours
            }
            
            const hourKey = `${groupHour.toString().padStart(2, '0')}:30`;
            const auditorEmail = audit.auditor_email || 'Unknown';
            
            if (!hourlyData[hourKey]) {
                hourlyData[hourKey] = {};
            }
            
            if (!hourlyData[hourKey][auditorEmail]) {
                hourlyData[hourKey][auditorEmail] = 0;
            }
            
            hourlyData[hourKey][auditorEmail]++;
        });
        
        // Get auditor names
        const auditorMap = {};
        auditorStats.forEach(stat => {
            auditorMap[stat.email] = stat.name;
        });
        
        // Check if there's any data after 18:30 (6:30 PM)
        const hasDataAfter1830 = Object.keys(hourlyData).some(hourKey => {
            const hour = parseInt(hourKey.split(':')[0]);
            return hour > 18;
        });
        
        // Prepare hours array - default to 9:30am-6:30pm, extend to 9:30pm if data exists
        const maxHour = hasDataAfter1830 ? 21 : 18;
        const sortedHours = [];
        for (let h = 9; h <= maxHour; h++) {
            sortedHours.push(`${h.toString().padStart(2, '0')}:30`);
        }
        
        if (sortedHours.length === 0) {
            hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No audit activity in the selected period</div>';
            return;
        }
        
        // Get auditors from Progress Overview (auditorStats) only
        const progressOverviewAuditors = new Set(auditorStats.map(stat => stat.email));
        
        // Filter to only include auditors from Progress Overview
        const sortedAuditors = auditorStats
            .map(stat => stat.email)
            .sort((a, b) => {
                const nameA = auditorMap[a] || a;
                const nameB = auditorMap[b] || b;
                return nameA.localeCompare(nameB);
            });
        
        // Calculate total audits per hour for chart
        const hourlyTotals = {};
        sortedHours.forEach(hour => {
            const hourData = hourlyData[hour] || {};
            let total = 0;
            sortedAuditors.forEach(email => {
                total += (hourData[email] || 0);
            });
            hourlyTotals[hour] = total;
        });
        
        // Prepare chart data - show 9:30am to 9:30pm at :30 intervals
        const chartLabels = sortedHours.map(h => {
            const [hourStr, minStr] = h.split(':');
            const hourNum = parseInt(hourStr);
            const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
            const ampm = hourNum < 12 ? 'AM' : 'PM';
            return `${displayHour}:${minStr} ${ampm}`;
        });
        
        const chartData = sortedHours.map(hour => hourlyTotals[hour] || 0);
        
        // Calculate target per hour (8 working hours: 10:30, 11:30, 12:30, 1:30, 3:30, 4:30, 5:30, 6:30)
        // Note: 9:30 AM has no target (shift starts), 2:30 PM has no target (lunch break period 1:30-2:30)
        // Each hour shows target for work done in the previous hour (e.g., 10:30 shows target for 9:30-10:30)
        const workingHours = ['10:30', '11:30', '12:30', '13:30', '15:30', '16:30', '17:30', '18:30'];
        const targetPerHour = totalAssigned > 0 ? Math.round((totalAssigned / 8) * 10) / 10 : 0; // Round to 1 decimal (8 working hours)
        
        // Render chart with target visualization
        renderHourlyChart(chartLabels, chartData, targetPerHour, workingHours, sortedHours);
        
        // Build table HTML with Target and Status columns
        let tableHTML = `
            <div style="display: grid; grid-template-columns: minmax(4rem, 1fr) minmax(3.5rem, 0.8fr) minmax(3.5rem, 0.8fr) repeat(${sortedAuditors.length}, minmax(5rem, 1fr)); gap: 0.75rem; align-items: center; padding: 0.375rem 0 0.5625rem 0; font-weight: 700; font-size: 0.6562rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 0.0469rem solid #e5e7eb; margin-bottom: 0.375rem;">
                <div>Hour</div>
                <div style="text-align: center;">Target</div>
                <div style="text-align: center;">Status</div>
                ${sortedAuditors.map(email => `<div style="text-align: center;">${escapeHtml(auditorMap[email] || email)}</div>`).join('')}
            </div>
        `;
        
        sortedHours.forEach(hour => {
            const hourData = hourlyData[hour] || {};
            // Format hour to AM/PM format with :30 minutes
            const [hourStr, minStr] = hour.split(':');
            const hourNum = parseInt(hourStr);
            const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
            const ampm = hourNum < 12 ? 'AM' : 'PM';
            const hourDisplay = `${displayHour}:${minStr} ${ampm}`;
            
            // Check if this is lunch break (2:30 PM only)
            const isLunchBreak = hour === '14:30';
            
            // Calculate total for this hour
            const hourTotal = hourlyTotals[hour] || 0;
            
            // Check if this is a working hour (1:30 has target, 2:30 does not)
            const isWorkingHour = workingHours.includes(hour);
            const target = isWorkingHour ? targetPerHour : 0;
            const targetMet = isWorkingHour ? (hourTotal >= target) : null;
            
            // Add lunch break indicator (only at 2:30 PM, shown on hover in Status column)
            const lunchBreakIndicator = isLunchBreak ? '<span class="lunch-break-text" style="font-size: 0.5rem; color: #f59e0b; opacity: 0; transition: opacity 0.2s;">Lunch</span>' : '';
            
            tableHTML += `
                <div class="${isLunchBreak ? 'lunch-break-row' : ''}" style="display: grid; grid-template-columns: minmax(4rem, 1fr) minmax(3.5rem, 0.8fr) minmax(3.5rem, 0.8fr) repeat(${sortedAuditors.length}, minmax(5rem, 1fr)); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6; ${isLunchBreak ? 'background-color: rgba(245, 158, 11, 0.05);' : ''}">
                    <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600;">${hourDisplay}</div>
                    <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">${isWorkingHour ? target : ''}</div>
                    <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">
                        ${targetMet === true ? '<span style="color: #10b981; font-weight: 600;"></span>' : targetMet === false ? '<span style="color: #ef4444; font-weight: 600;"></span>' : ''}${lunchBreakIndicator}
                    </div>
                    ${sortedAuditors.map(email => {
                        const count = hourData[email] || 0;
                        return `<div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">${count > 0 ? count : ''}</div>`;
                    }).join('')}
                </div>
            `;
        });
        
        hourlyTableBody.innerHTML = tableHTML;
        
    } catch (error) {
        console.error('Error rendering hourly breakdown:', error);
        const hourlyTableBody = document.getElementById('hourlyTableBody');
        if (hourlyTableBody) {
            hourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading hourly breakdown</div>';
        }
    }
}

// ============================================================================
// Dynamic Hourly Breakdown Functions
// ============================================================================

function renderDynamicHourlyChart(labels, data, dynamicTargets = [], workingHours = [], sortedHours = [], deficiencies = [], currentHourIndex = -1) {
    try {
        // Validate inputs
        if (!labels || !Array.isArray(labels) || labels.length === 0) {
            console.warn('Invalid dynamic chart labels');
            return;
        }
        if (!data || !Array.isArray(data) || data.length === 0) {
            console.warn('Invalid dynamic chart data');
            return;
        }
        
        const canvas = document.getElementById('dynamicHourlyChart');
        if (!canvas) {
            console.warn('Dynamic hourly chart canvas not found');
            return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.warn('Could not get dynamic chart context');
            return;
        }

        // Destroy existing chart instance if it exists
        if (dynamicHourlyChartInstance) {
            dynamicHourlyChartInstance.destroy();
            dynamicHourlyChartInstance = null;
        }

        // Create dynamic target line data (target for working hours, null for others)
        // dynamicTargets parameter is already mapped to sortedHours (as chartDynamicTargets)
        // So we can use it directly as targetData
        const targetData = dynamicTargets || [];

        // Calculate dynamic Y-axis max based on target and actual data
        const maxDataValue = Math.max(...data, 0);
        const validTargets = targetData.filter(t => t !== null && t !== undefined && t > 0);
        const maxTargetValue = validTargets.length > 0 ? Math.max(...validTargets) : 0;
        const maxValue = Math.max(maxDataValue, maxTargetValue);
        // Add 20% padding and round up to nearest 0.5
        const yAxisMax = maxValue > 0 ? Math.ceil(maxValue * 1.2 * 2) / 2 : 10;
        
        dynamicHourlyChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Total Audits',
                        data: data,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#10b981',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        order: 1 // Draw actual data line below target
                    },
                    {
                        label: 'Dynamic Target',
                        data: targetData,
                        borderColor: '#f59e0b',
                        backgroundColor: 'transparent',
                        borderWidth: 2.5,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        tension: 0,
                        spanGaps: false,
                        order: 0 // Draw target line on top
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: {
                                size: 11
                            },
                            usePointStyle: true,
                            padding: 15
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 12,
                            weight: '600'
                        },
                        bodyFont: {
                            size: 11
                        },
                        callbacks: {
                            label: function(context) {
                                if (context.datasetIndex === 0) {
                                    // Main data line
                                    const value = context.parsed.y;
                                    const hourIndex = context.dataIndex;
                                    if (sortedHours && sortedHours.length > hourIndex) {
                                        const hour = sortedHours[hourIndex];
                                        const isWorkingHour = workingHours && workingHours.includes(hour);
                                        
                                        // targetData is available in closure
                                        const targetValue = targetData && targetData[hourIndex];
                                        if (isWorkingHour && targetValue !== null && targetValue !== undefined && targetValue > 0) {
                                            const status = value >= targetValue ? ' (Target Met )' : ' (Target Not Met )';
                                            return value + ' audits' + status;
                                        }
                                    }
                                    return value + ' audits';
                                } else {
                                    // Dynamic Target line
                                    if (context.parsed.y !== null) {
                                        return 'Dynamic Target: ' + context.parsed.y.toFixed(1) + ' audits';
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: yAxisMax,
                        ticks: {
                            stepSize: yAxisMax <= 10 ? 1 : (yAxisMax <= 20 ? 2 : Math.ceil(yAxisMax / 10)),
                            font: {
                                size: 10
                            },
                            color: '#6b7280'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 10
                            },
                            color: '#6b7280',
                            maxRotation: 45,
                            minRotation: 45
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            },
            plugins: [
                {
                    id: 'datalabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach((point, index) => {
                                const value = dataset.data[index];
                                if (i === 0) {
                                    // Show labels for actual data
                                    if (value > 0) {
                                        const x = point.x;
                                        const y = point.y;
                                        const text = value.toString();
                                        ctx.save();
                                        ctx.font = '600 10px Poppins';
                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'bottom';
                                        
                                        // Draw white background/stroke for visibility
                                        ctx.strokeStyle = '#ffffff';
                                        ctx.lineWidth = 3;
                                        ctx.lineJoin = 'round';
                                        ctx.miterLimit = 2;
                                        ctx.strokeText(text, x, y - 8);
                                        
                                        // Draw the actual text
                                        ctx.fillStyle = '#10b981';
                                        ctx.fillText(text, x, y - 8);
                                        ctx.restore();
                                    }
                                } else if (i === 1) {
                                    // Show labels for dynamic target line (above the point)
                                    if (value !== null && value !== undefined && value > 0) {
                                        const x = point.x;
                                        const y = point.y;
                                        const hourIndex = index;
                                        
                                        // Get deficiency if this is a past hour
                                        const hour = sortedHours && sortedHours[hourIndex];
                                        const workingHourIndex = hour ? workingHours.indexOf(hour) : -1;
                                        const deficiency = deficiencies && deficiencies[hourIndex];
                                        const isPastHour = currentHourIndex >= 0 && workingHourIndex >= 0 && workingHourIndex < currentHourIndex;
                                        
                                        ctx.save();
                                        
                                        // Draw target value with white background/stroke
                                        const targetText = value.toFixed(1);
                                        ctx.font = '600 10px Poppins';
                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'bottom';
                                        
                                        // Draw white background/stroke for visibility
                                        ctx.strokeStyle = '#ffffff';
                                        ctx.lineWidth = 3;
                                        ctx.lineJoin = 'round';
                                        ctx.miterLimit = 2;
                                        ctx.strokeText(targetText, x, y - 8);
                                        
                                        // Draw the actual text
                                        ctx.fillStyle = '#f59e0b';
                                        ctx.fillText(targetText, x, y - 8);
                                        
                                        // Draw deficiency below target if it's a past hour with shortfall
                                        if (isPastHour && deficiency !== null && deficiency > 0) {
                                            const deficiencyText = `-${deficiency.toFixed(1)}`;
                                            ctx.font = '600 9px Poppins';
                                            ctx.textBaseline = 'top';
                                            
                                            // Draw white background/stroke for deficiency
                                            ctx.strokeStyle = '#ffffff';
                                            ctx.lineWidth = 3;
                                            ctx.strokeText(deficiencyText, x, y - 8 + 12);
                                            
                                            // Draw the actual text
                                            ctx.fillStyle = '#ef4444';
                                            ctx.fillText(deficiencyText, x, y - 8 + 12);
                                        }
                                        
                                        ctx.restore();
                                    }
                                }
                            });
                        });
                    }
                },
                {
                    id: 'targetLines',
                    afterDatasetsDraw: (chart) => {
                        if (!sortedHours || !workingHours || !targetData || targetData.length === 0) return;
                        
                        const ctx = chart.ctx;
                        const meta0 = chart.getDatasetMeta(0); // Actual data
                        const meta1 = chart.getDatasetMeta(1); // Dynamic Target line
                        
                        sortedHours.forEach((hour, index) => {
                            const isWorkingHour = workingHours.includes(hour);
                            if (!isWorkingHour) return;
                            
                            const actualPoint = meta0.data[index];
                            const targetPoint = meta1.data[index];
                            
                            if (!actualPoint || !targetPoint || targetPoint.y === null) return;
                            
                            const actualValue = data[index] || 0;
                            const targetValue = targetData[index];
                            
                            if (!targetValue || targetValue <= 0) return;
                            
                            // Only draw line if there's a difference
                            if (Math.abs(actualValue - targetValue) > 0.01) {
                                ctx.save();
                                
                                // Color: red if below target, green if above
                                ctx.strokeStyle = actualValue >= targetValue ? '#10b981' : '#ef4444';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([]);
                                
                                // Draw vertical line from target to actual
                                ctx.beginPath();
                                ctx.moveTo(actualPoint.x, targetPoint.y);
                                ctx.lineTo(actualPoint.x, actualPoint.y);
                                ctx.stroke();
                                
                                ctx.restore();
                            }
                        });
                    }
                },
                {
                    id: 'lunchBreak',
                    beforeDatasetsDraw: (chart) => {
                        if (!sortedHours) return;
                        
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;
                        
                        // Find indices for lunch break hours (13:30 to 14:30)
                        const lunchStartIndex = sortedHours.findIndex(hour => hour === '13:30');
                        const lunchEndIndex = sortedHours.findIndex(hour => hour === '14:30');
                        
                        if (lunchStartIndex === -1 || lunchEndIndex === -1) return;
                        
                        const meta0 = chart.getDatasetMeta(0);
                        if (!meta0.data[lunchStartIndex] || !meta0.data[lunchEndIndex]) return;
                        
                        const startX = meta0.data[lunchStartIndex].x;
                        const endX = meta0.data[lunchEndIndex].x;
                        const width = endX - startX;
                        
                        // Draw shaded rectangle for lunch break (from 1:30 to 2:30)
                        ctx.save();
                        ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
                        ctx.fillRect(startX, chartArea.top, width, chartArea.bottom - chartArea.top);
                        ctx.restore();
                        
                        // Add vertical text label centered between 1:30 and 2:30, vertically centered in chart
                        ctx.save();
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = '600 9px Poppins';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const centerY = (chartArea.top + chartArea.bottom) / 2;
                        ctx.translate(startX + width / 2, centerY);
                        ctx.rotate(-Math.PI / 2); // Rotate 90 degrees counterclockwise
                        ctx.fillText('Lunch Break', 0, 0);
                        ctx.restore();
                    }
                }
            ]
        });
    } catch (error) {
        console.error('Error rendering dynamic hourly chart:', error);
    }
}

function calculateDynamicHourlyTargets(totalAssigned, completedSoFar, currentHour, workingHours) {
    const remainingTarget = totalAssigned - completedSoFar;
    const currentHourIndex = workingHours.findIndex(h => {
        const hour = parseInt(h.split(':')[0]);
        return hour >= currentHour;
    });
    
    if (currentHourIndex === -1) {
        return workingHours.map(() => 0);
    }
    
    const remainingWorkingHours = workingHours.slice(currentHourIndex);
    const remainingHoursCount = remainingWorkingHours.length;
    
    if (remainingHoursCount === 0) {
        return workingHours.map(() => 0);
    }
    
    const baseTargetPerHour = totalAssigned / 8;
    const hoursPassed = currentHourIndex;
    const expectedCompletedByNow = baseTargetPerHour * hoursPassed;
    const deficit = expectedCompletedByNow - completedSoFar;
    
    if (deficit <= 0) {
        return workingHours.map((hour, index) => {
            if (index < currentHourIndex) return 0;
            return baseTargetPerHour;
        });
    }
    
    const additionalTargetPerHour = deficit / remainingHoursCount;
    const dynamicTargetPerHour = baseTargetPerHour + additionalTargetPerHour;
    
    return workingHours.map((hour, index) => {
        if (index < currentHourIndex) return 0;
        return dynamicTargetPerHour;
    });
}

async function renderDynamicHourlyBreakdown(period, auditorStats, totalAssigned = 0) {
    try {
        // Only show dynamic hourly breakdown in Team Stats view
        if (currentTab !== 0) {
            const dynamicHourlyTableBody = document.getElementById('dynamicHourlyTableBody');
            if (dynamicHourlyTableBody) {
                dynamicHourlyTableBody.innerHTML = '';
            }
            if (dynamicHourlyChartInstance) {
                dynamicHourlyChartInstance.destroy();
                dynamicHourlyChartInstance = null;
            }
            return;
        }
        
        const dynamicHourlyTableBody = document.getElementById('dynamicHourlyTableBody');
        if (!dynamicHourlyTableBody) {
            console.warn('Dynamic hourly table body not found');
            return;
        }
        
        if (!auditorStats || !Array.isArray(auditorStats) || auditorStats.length === 0) {
            dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No auditors found</div>';
            return;
        }
        
        if (!period) {
            dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No date range selected</div>';
            return;
        }
        
        // Only show for today's data
        try {
            const today = getDhakaNow();
            const todayStr = formatDhakaDateForInput(today);
            const periodStartStr = period.start ? formatDhakaDateForInput(period.start) : null;
            const periodEndStr = period.end ? formatDhakaDateForInput(period.end) : null;
            
            if (periodStartStr !== todayStr || periodEndStr !== todayStr) {
                dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Dynamic breakdown available only for today</div>';
                if (dynamicHourlyChartInstance) {
                    dynamicHourlyChartInstance.destroy();
                    dynamicHourlyChartInstance = null;
                }
                return;
            }
        } catch (dateError) {
            console.error('Error checking date for dynamic breakdown:', dateError);
            dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error checking date range</div>';
            return;
        }
        
        dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>';
        
        if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
            await loadScorecards();
        }
        
        let tablesToQuery = [];
        try {
            const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
            if (!tablesError && allTables && allTables.length > 0) {
                tablesToQuery = allTables
                    .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                    .map(t => t.table_name);
            } else {
                tablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
        } catch (rpcError) {
            tablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
        }
        
        if (tablesToQuery.length === 0) {
            dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No audit data available</div>';
            return;
        }
        
        const auditPromises = tablesToQuery.map(async (tableName) => {
            try {
                let query = window.supabaseClient
                    .from(tableName)
                    .select('submitted_at, auditor_email')
                    .not('submitted_at', 'is', null);
                
                if (period.start) {
                    query = query.gte('submitted_at', dhakaDateToUTCISO(period.start));
                }
                if (period.end) {
                    query = query.lte('submitted_at', dhakaDateToUTCISO(period.end));
                }
                
                const result = await query;
                if (result.error) {
                    const errorMessage = result.error.message || JSON.stringify(result.error);
                    if (errorMessage.includes('auditor_email') && 
                        (result.error.code === '42703' || result.error.code === 'PGRST116')) {
                        return [];
                    }
                    throw result.error;
                }
                
                let audits = result.data || [];
                if (period.start) {
                    audits = audits.filter(audit => {
                        if (!audit.submitted_at) return false;
                        const auditDate = toDhakaTime(audit.submitted_at);
                        return (!period.start || auditDate >= period.start) && 
                               (!period.end || auditDate <= period.end);
                    });
                }
                return audits;
            } catch (err) {
                console.warn(`Error querying ${tableName} for dynamic hourly breakdown:`, err);
                return [];
            }
        });
        
        const allAuditResults = await Promise.all(auditPromises);
        const allAudits = allAuditResults.flat();
        
        const now = toDhakaTime(new Date());
        const currentHour = now.getHours();
        const currentMinutes = now.getMinutes();
        
        const hourlyData = {};
        allAudits.forEach(audit => {
            if (!audit.submitted_at) return;
            const submittedDate = toDhakaTime(audit.submitted_at);
            const hour = submittedDate.getHours();
            const minutes = submittedDate.getMinutes();
            let groupHour = hour;
            if (minutes < 30) {
                groupHour = hour - 1;
                if (groupHour < 0) groupHour = 23;
            }
            if (groupHour < 9 || groupHour > 21) return;
            const hourKey = `${groupHour.toString().padStart(2, '0')}:30`;
            const auditorEmail = audit.auditor_email || 'Unknown';
            if (!hourlyData[hourKey]) hourlyData[hourKey] = {};
            if (!hourlyData[hourKey][auditorEmail]) hourlyData[hourKey][auditorEmail] = 0;
            hourlyData[hourKey][auditorEmail]++;
        });
        
        const auditorMap = {};
        auditorStats.forEach(stat => {
            auditorMap[stat.email] = stat.name;
        });
        
        const hasDataAfter1830 = Object.keys(hourlyData).some(hourKey => {
            const hour = parseInt(hourKey.split(':')[0]);
            return hour > 18;
        });
        
        const maxHour = hasDataAfter1830 ? 21 : 18;
        const sortedHours = [];
        for (let h = 9; h <= maxHour; h++) {
            sortedHours.push(`${h.toString().padStart(2, '0')}:30`);
        }
        
        if (sortedHours.length === 0) {
            dynamicHourlyTableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No audit activity in the selected period</div>';
            return;
        }
        
        const sortedAuditors = auditorStats
            .map(stat => stat.email)
            .sort((a, b) => {
                const nameA = auditorMap[a] || a;
                const nameB = auditorMap[b] || b;
                return nameA.localeCompare(nameB);
            });
        
        const hourlyTotals = {};
        sortedHours.forEach(hour => {
            const hourData = hourlyData[hour] || {};
            let total = 0;
            sortedAuditors.forEach(email => {
                total += (hourData[email] || 0);
            });
            hourlyTotals[hour] = total;
        });
        
        let completedSoFar = 0;
        sortedHours.forEach(hour => {
            const hourNum = parseInt(hour.split(':')[0]);
            if (hourNum < currentHour || (hourNum === currentHour && currentMinutes >= 30)) {
                completedSoFar += (hourlyTotals[hour] || 0);
            }
        });
        
        const workingHours = ['10:30', '11:30', '12:30', '13:30', '15:30', '16:30', '17:30', '18:30'];
        
        // Find current hour index in working hours
        const currentHourIndex = workingHours.findIndex(h => {
            const hour = parseInt(h.split(':')[0]);
            return hour >= currentHour;
        });
        
        const chartLabels = sortedHours.map(h => {
            const [hourStr, minStr] = h.split(':');
            const hourNum = parseInt(hourStr);
            const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
            const ampm = hourNum < 12 ? 'AM' : 'PM';
            return `${displayHour}:${minStr} ${ampm}`;
        });
        
        const chartData = sortedHours.map(hour => hourlyTotals[hour] || 0);
        
        // Calculate historical dynamic targets for each hour
        // For past hours, calculate what the target was at that specific time
        const chartDynamicTargets = sortedHours.map((hour, hourIndex) => {
            const index = workingHours.indexOf(hour);
            if (index < 0) return null; // Non-working hour
            
            // For past hours, calculate what the dynamic target was FOR that hour when it was current
            if (currentHourIndex >= 0 && index < currentHourIndex) {
                // Calculate completed so far up to (but not including) this hour
                let completedUpToThisHour = 0;
                const thisHourNum = parseInt(hour.split(':')[0]);
                sortedHours.forEach((h, idx) => {
                    const hNum = parseInt(h.split(':')[0]);
                    // Count hours before this hour (completed before this hour started)
                    if (hNum < thisHourNum || (hNum === thisHourNum && idx < hourIndex)) {
                        completedUpToThisHour += (hourlyTotals[h] || 0);
                    }
                });
                
                // Calculate what the target would have been FOR this hour when it was the current hour
                // When this hour was current, we calculate targets starting from this hour
                const historicalTargets = calculateDynamicHourlyTargets(
                    totalAssigned, 
                    completedUpToThisHour, 
                    thisHourNum, 
                    workingHours
                );
                
                // When this hour was current, currentHourIndex would have been 'index'
                // So the target for this hour would be at historicalTargets[index]
                // But the function sets past hours to 0, so we need to get it differently
                // Actually, when thisHourNum was current, the function calculates for index >= currentHourIndex
                // So if currentHourIndex = index (this hour), then historicalTargets[index] should have the target
                
                // However, the function returns 0 for index < currentHourIndex
                // So when we call it with thisHourNum, if currentHourIndex = index, then index is NOT < index
                // So historicalTargets[index] should have the calculated target
                if (historicalTargets && historicalTargets[index] !== undefined) {
                    // If it's 0, it means it was set to 0 because it was considered "past"
                    // But we want the target that was calculated for it when it was current
                    // So we need to recalculate it manually
                    if (historicalTargets[index] > 0) {
                        return historicalTargets[index];
                    }
                    
                    // If it's 0, we need to calculate what it should have been
                    // When this hour was current, it was the first remaining hour
                    const baseTargetPerHour = totalAssigned / 8;
                    const hoursPassedAtThatTime = index; // How many working hours had passed
                    const expectedCompletedByThen = baseTargetPerHour * hoursPassedAtThatTime;
                    const deficitAtThatTime = expectedCompletedByThen - completedUpToThisHour;
                    const remainingHoursAtThatTime = workingHours.length - index;
                    
                    if (deficitAtThatTime <= 0) {
                        // On track, use base target
                        return baseTargetPerHour;
                    } else {
                        // Behind, calculate dynamic target
                        const additionalTargetPerHour = deficitAtThatTime / remainingHoursAtThatTime;
                        return baseTargetPerHour + additionalTargetPerHour;
                    }
                }
                
                return null;
            }
            
            // For current and future hours, calculate dynamic target based on current state
            if (index >= currentHourIndex) {
                const dynamicTargets = calculateDynamicHourlyTargets(totalAssigned, completedSoFar, currentHour, workingHours);
                if (dynamicTargets && dynamicTargets[index] !== undefined && dynamicTargets[index] > 0) {
                    return dynamicTargets[index];
                }
            }
            
            return null;
        });
        
        // Calculate deficiencies for past hours (target - actual)
        const deficiencies = sortedHours.map((hour, hourIndex) => {
            const index = workingHours.indexOf(hour);
            if (index < 0) return null;
            
            const actual = chartData[hourIndex] || 0;
            const target = chartDynamicTargets[hourIndex];
            
            // Only calculate deficiency for past working hours where we had a target
            if (currentHourIndex >= 0 && index < currentHourIndex && target !== null && target > 0) {
                const deficiency = target - actual;
                return deficiency > 0 ? deficiency : 0; // Only show positive deficiency (shortfall)
            }
            
            return null;
        });
        
        renderDynamicHourlyChart(chartLabels, chartData, chartDynamicTargets, workingHours, sortedHours, deficiencies, currentHourIndex);
        
        let tableHTML = `
            <div style="display: grid; grid-template-columns: minmax(4rem, 1fr) minmax(3.5rem, 0.8fr) minmax(3.5rem, 0.8fr) repeat(${sortedAuditors.length}, minmax(5rem, 1fr)); gap: 0.75rem; align-items: center; padding: 0.375rem 0 0.5625rem 0; font-weight: 700; font-size: 0.6562rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 0.0469rem solid #e5e7eb; margin-bottom: 0.375rem;">
                <div>Hour</div>
                <div style="text-align: center;">Dynamic Target</div>
                <div style="text-align: center;">Status</div>
                ${sortedAuditors.map(email => `<div style="text-align: center;">${escapeHtml(auditorMap[email] || email)}</div>`).join('')}
            </div>
        `;
        
        sortedHours.forEach((hour, hourIndex) => {
            const hourData = hourlyData[hour] || {};
            const [hourStr, minStr] = hour.split(':');
            const hourNum = parseInt(hourStr);
            const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
            const ampm = hourNum < 12 ? 'AM' : 'PM';
            const hourDisplay = `${displayHour}:${minStr} ${ampm}`;
            const isLunchBreak = hour === '14:30';
            const hourTotal = hourlyTotals[hour] || 0;
            
            // Use the same chartDynamicTargets array that's used in the chart
            // This ensures table and chart show the exact same values
            const dynamicTarget = chartDynamicTargets[hourIndex];
            const workingHourIndex = workingHours.indexOf(hour);
            const isPastHour = currentHourIndex >= 0 && workingHourIndex >= 0 && workingHourIndex < currentHourIndex;
            const deficiency = deficiencies && deficiencies[hourIndex];
            const targetMet = (dynamicTarget !== null && dynamicTarget !== undefined && dynamicTarget > 0) ? (hourTotal >= dynamicTarget) : null;
            const lunchBreakIndicator = isLunchBreak ? '<span class="lunch-break-text" style="font-size: 0.5rem; color: #f59e0b; opacity: 0; transition: opacity 0.2s;">Lunch</span>' : '';
            
            // Format target display with deficiency for past hours
            let targetDisplay = '';
            if (dynamicTarget !== null && dynamicTarget !== undefined && dynamicTarget > 0) {
                targetDisplay = dynamicTarget.toFixed(1);
                // Add deficiency in red for past hours with shortfall
                if (isPastHour && deficiency !== null && deficiency > 0) {
                    targetDisplay += ` <span style="color: #ef4444; font-size: 0.5625rem;">(-${deficiency.toFixed(1)})</span>`;
                }
            }
            
            tableHTML += `
                <div class="${isLunchBreak ? 'lunch-break-row' : ''}" style="display: grid; grid-template-columns: minmax(4rem, 1fr) minmax(3.5rem, 0.8fr) minmax(3.5rem, 0.8fr) repeat(${sortedAuditors.length}, minmax(5rem, 1fr)); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6; ${isLunchBreak ? 'background-color: rgba(245, 158, 11, 0.05);' : ''}">
                    <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600;">${hourDisplay}</div>
                    <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">${targetDisplay}</div>
                    <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">
                        ${targetMet === true ? '<span style="color: #10b981; font-weight: 600;"></span>' : targetMet === false ? '<span style="color: #ef4444; font-weight: 600;"></span>' : ''}${lunchBreakIndicator}
                    </div>
                    ${sortedAuditors.map(email => {
                        const count = hourData[email] || 0;
                        return `<div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;">${count > 0 ? count : ''}</div>`;
                    }).join('')}
                </div>
            `;
        });
        
        dynamicHourlyTableBody.innerHTML = tableHTML;
        
    } catch (error) {
        console.error('Error rendering dynamic hourly breakdown:', error);
        console.error('Error stack:', error.stack);
        const dynamicHourlyTableBody = document.getElementById('dynamicHourlyTableBody');
        if (dynamicHourlyTableBody) {
            dynamicHourlyTableBody.innerHTML = `<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading dynamic hourly breakdown: ${error.message || 'Unknown error'}</div>`;
        }
        // Clear chart on error
        if (dynamicHourlyChartInstance) {
            try {
                dynamicHourlyChartInstance.destroy();
                dynamicHourlyChartInstance = null;
            } catch (chartError) {
                console.error('Error destroying chart:', chartError);
            }
        }
    }
}

async function updateStandupView() {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    // Update UI structure immediately (cards, table headers) - instant feedback
    renderStandupViewStructure();
    
    const period = getCurrentPeriodDates();
    
    // Show loading if initial load
    if (isInitialLoad) {
        showLoadingState();
    }
    
    // Always fetch fresh data
    await fetchAndCacheStandupView(period);
}

// Render the UI structure immediately (cards, table headers) - no data needed
function renderStandupViewStructure() {
    // Update table header for standup view immediately
    const tableHeader = document.getElementById('tableHeader');
    if (tableHeader) {
        tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr)';
        tableHeader.style.display = 'grid';
        tableHeader.style.gap = '0.75rem';
        tableHeader.style.alignItems = 'center';
        tableHeader.innerHTML = `
            <div>Channel</div>
            <div>Assigned</div>
            <div>Completed</div>
            <div>Remaining</div>
            <div>Progress Meter</div>
        `;
    }
    
    // Show loading state in table body
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>';
    }
    
    // Update card labels immediately (values will be updated when data loads)
    const stat1Label = document.getElementById('stat1Label');
    if (stat1Label) stat1Label.textContent = 'ASSIGNED';
    
    // Note: 3rd card (REMAINING) has been merged into completed card, so we don't need to update it separately
    
    // Update 4th card to PASSING RATE
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        stat4Card.style.display = 'flex';
        const label = stat4Card.querySelector('#stat4Label');
        if (label) label.textContent = 'PASSING RATE';
    }
    
    // Update 5th card to REVERSALS
    const stat5Label = document.getElementById('stat5Label');
    if (stat5Label) stat5Label.textContent = 'REVERSALS';
    
    // Hide 6th card (AVG DURATION)
    const stat6Card = document.getElementById('stat6Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'none';
    }
    
    // Hide 7th card (PASSING RATE - only shown in Team Stats)
    const stat7Card = document.getElementById('stat7Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat7Card) {
        stat7Card.style.display = 'none';
    }
    
    // Hide hourly breakdown in standup view
    const hourlyBreakdownTable = document.getElementById('hourlyBreakdownTable');
    if (hourlyBreakdownTable) {
        hourlyBreakdownTable.style.display = 'none';
    }
    
    // Hide dynamic hourly breakdown in standup view
    const dynamicHourlyBreakdownTable = document.getElementById('dynamicHourlyBreakdownTable');
    if (dynamicHourlyBreakdownTable) {
        dynamicHourlyBreakdownTable.style.display = 'none';
    }
}

// Render standup view data (called with cached or fresh data)
function renderStandupViewData(standupData) {
    const {
        totalAssigned,
        completed,
        percentage,
        coveragePercent,
        passingRate,
        passingCount,
        notPassingCount,
        standupReversalCount,
        channelStats
    } = standupData;
    
    // Hide hourly breakdown table and chart in standup view
    const hourlyTableBody = document.getElementById('hourlyTableBody');
    if (hourlyTableBody) {
        hourlyTableBody.innerHTML = '';
    }
    // Clear chart
    if (hourlyChartInstance) {
        hourlyChartInstance.destroy();
        hourlyChartInstance = null;
    }
    
    // Hide dynamic hourly breakdown table and chart in standup view
    const dynamicHourlyTableBody = document.getElementById('dynamicHourlyTableBody');
    if (dynamicHourlyTableBody) {
        dynamicHourlyTableBody.innerHTML = '';
    }
    // Clear dynamic chart
    if (dynamicHourlyChartInstance) {
        dynamicHourlyChartInstance.destroy();
        dynamicHourlyChartInstance = null;
    }
    
    // Update stat cards
    const stat1Count = document.getElementById('stat1Count');
    if (stat1Count) stat1Count.textContent = totalAssigned || 0;
    
    const completedCount = document.getElementById('completedCount');
    if (completedCount) completedCount.textContent = completed || 0;
    
    // Hide backlog/early counts in standup view (team-specific)
    const backlogCountText = document.getElementById('backlogCountText');
    if (backlogCountText) {
        backlogCountText.textContent = '';
        backlogCountText.style.display = 'none';
    }
    
    // Calculate remaining from totalAssigned and completed
    const remaining = (totalAssigned || 0) - (completed || 0);
    
    // Update remaining count in separate remaining card
    const remainingCount = document.getElementById('remainingCount');
    if (remainingCount) {
        remainingCount.textContent = remaining;
    }
    
    // Update progress bar in completed card (showing coverage/completion percentage) with temperature-based color
    const completedProgressBar = document.getElementById('completedProgressBar');
    if (completedProgressBar) {
        const progressBarFill = completedProgressBar.querySelector('div');
        if (progressBarFill && totalAssigned > 0) {
            const progressPercentage = coveragePercent || percentage || 0;
            progressBarFill.style.width = `${progressPercentage}%`;
            progressBarFill.style.background = getProgressBarColor(progressPercentage);
            completedProgressBar.style.display = 'block';
        } else {
            completedProgressBar.style.display = 'none';
        }
    }
    
    const targetAchieved = document.getElementById('targetAchieved');
    if (targetAchieved) targetAchieved.textContent = `${percentage || 0}% Target Achieved`;
    
    // Update 4th card to PASSING RATE with progress bar
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        const countDiv = stat4Card.querySelector('#stat4Count');
        if (countDiv) {
            countDiv.style.fontSize = '2.625rem';
            countDiv.textContent = (passingRate || 0) + '%';
            
            // Show chips container and update chips with passing and not passing counts
            const chipsContainer = document.getElementById('stat4ChipsContainer');
            const passCount = passingCount || 0;
            const notPassCount = notPassingCount || 0;
            
            if (chipsContainer) {
                chipsContainer.style.display = 'flex';
            }
            
            const stat4PassingCount = document.getElementById('stat4PassingCount');
            const stat4NotPassingCount = document.getElementById('stat4NotPassingCount');
            
            if (stat4PassingCount) {
                const span = stat4PassingCount.querySelector('span');
                if (span) span.textContent = `${passCount} Passed`;
            }
            if (stat4NotPassingCount) {
                const span = stat4NotPassingCount.querySelector('span');
                if (span) span.textContent = `${notPassCount} Not Passed`;
            }
            
            // Clear subtitle (chips now show the counts)
            const subtitle = stat4Card.querySelector('#stat4Subtitle');
            if (subtitle) {
                subtitle.textContent = '';
            }
            
            // Add/update progress bar at the bottom of the card (before subtitle)
            let progressContainer = stat4Card.querySelector('.progress-bar-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
                // Insert before subtitle to place it at the bottom of the card
                if (subtitle && subtitle.parentElement) {
                    subtitle.parentElement.insertBefore(progressContainer, subtitle);
                } else {
                    stat4Card.appendChild(progressContainer);
                }
            }
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${passingRate || 0}%;"></div>`;
        }
    }
    
    // Update 5th card to REVERSALS
    const stat5Count = document.getElementById('stat5Count');
    if (stat5Count) stat5Count.textContent = standupReversalCount || 0;
    
    const stat5Subtitle = document.getElementById('stat5Subtitle');
    if (stat5Subtitle) stat5Subtitle.textContent = '';
    
    // Change card background to red if reversal count > 0
    const stat5Card = document.getElementById('stat5Card');
    if (stat5Card) {
        if (standupReversalCount > 0) {
            stat5Card.style.backgroundColor = '#dc2626'; // Darker red color
        } else {
            stat5Card.style.backgroundColor = 'var(--dark-forest)'; // Default dark forest color
        }
    }
    
    // Update table with channel statistics
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        if (!channelStats || Object.keys(channelStats).length === 0) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No channel data available</div>';
        } else {
            const sortedChannels = Object.keys(channelStats).sort();
            tableBody.innerHTML = sortedChannels.map(channel => {
                const stats = channelStats[channel];
                
                return `
                    <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6;">
                        <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600;" data-label="Channel">${escapeHtml(channel)}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Assigned">${stats.assigned || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Completed">${stats.completed || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Remaining">${stats.remaining || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Progress">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage || 0}%</span>
                                <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative;">
                                    <div style="height: 100%; background: ${getProgressBarColor(stats.percentage || 0)}; border-radius: 0.2812rem; transition: width 0.3s ease; width: ${stats.percentage || 0}%;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }
}

async function fetchAndCacheStandupView(period) {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    // Capture the current fetch ID at the start of this fetch
    const fetchId = currentFetchId;
    
    try {
        // Load all audit assignments with date filtering
        // Filter to only Quality Analysts (auditors) to match Team Stats calculation
        
        // Load all assignments with date filtering (no role restriction)
        let assignmentsQuery = window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .order('created_at', { ascending: false });
        
        // Apply date filters server-side if possible (convert Dhaka to UTC)
        if (period.start) {
            assignmentsQuery = assignmentsQuery.gte('created_at', dhakaDateToUTCISO(period.start));
        }
        if (period.end) {
            assignmentsQuery = assignmentsQuery.lte('created_at', dhakaDateToUTCISO(period.end));
        }
        
        let { data, error } = await assignmentsQuery;
        
        // Check if this fetch is still the current one
        if (fetchId !== currentFetchId) {
            console.log('Standup view fetch cancelled - newer fetch in progress');
            return;
        }
        
        // If server-side date filter fails, try without date filter and filter client-side
        if (error && period && (period.start || period.end)) {
            console.warn('Server-side date filter failed, falling back to client-side filtering:', error);
            const retryResult = await window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .order('created_at', { ascending: false });
            
            if (retryResult.data && period.start) {
                retryResult.data = retryResult.data.filter(assignment => {
                    // Use scheduled_date if available, otherwise created_at
                    const dateToUse = assignment.scheduled_date 
                        ? new Date(assignment.scheduled_date + 'T00:00:00')
                        : assignment.created_at;
                    if (!dateToUse) return false;
                    const assignmentDate = toDhakaTime(dateToUse);
                    return (!period.start || assignmentDate >= period.start) && 
                           (!period.end || assignmentDate <= period.end);
                });
            }
            data = retryResult.data;
            error = retryResult.error;
        }
        
        // Check again after retry
        if (fetchId !== currentFetchId) {
            console.log('Standup view fetch cancelled - newer fetch in progress');
            return;
        }
        
        if (error) throw error;
        
        const allAuditAssignments = data || [];
        
        // Get unique auditor emails from assignments (any role, not just Quality Analysts)
        const auditorEmails = [...new Set(allAuditAssignments.map(a => a.auditor_email).filter(Boolean))];
        
        if (auditorEmails.length === 0) {
            const tableBody = document.getElementById('performanceTableBody');
            if (tableBody) {
                tableBody.innerHTML = `
                    <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                        No auditors found with assignments in the selected date range.
                    </div>
                `;
            }
            hideLoadingState();
            return;
        }
        
        // Calculate overall stats
        const totalAssigned = allAuditAssignments.length;
        const inProgress = allAuditAssignments.filter(a => a.status === 'in_progress').length;
        const pending = allAuditAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        
        // Calculate passing rate, reversal count, completed count, and duration in parallel
        let passingRate = 0;
        let passingCount = 0;
        let notPassingCount = 0;
        let standupReversalCount = 0;
        let completed = 0; // Will be calculated from scorecard tables
        // Store completed audits by channel for channel stats
        let completedAuditsByChannel = {};
        
        try {
            // Ensure scorecards are loaded
            if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
                await loadScorecards();
            }
            
            // Discover all audit tables using get_audit_tables RPC (matching audit-reports.html)
            let standupTablesToQuery = [];
            try {
                const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
                
                if (!tablesError && allTables && allTables.length > 0) {
                    // Filter out ai_analysis_results and calibration_results and map to table names
                    standupTablesToQuery = allTables
                        .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                        .map(t => t.table_name);
                } else {
                    // Fallback: use scorecard tables
                    standupTablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
                }
            } catch (rpcError) {
                console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
                // Fallback: use scorecard tables
                standupTablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
            
            if (standupTablesToQuery.length > 0) {
                // Parallelize all queries for each table
                const queryPromises = standupTablesToQuery.map(async (tableName) => {
                    try {
                        // Build queries with date filters
                        let passingQuery = window.supabaseClient
                            .from(tableName)
                            .select('passing_status, submitted_at');
                        
                        let reversalQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at')
                            .not('reversal_requested_at', 'is', null);
                        
                        let durationQuery = window.supabaseClient
                            .from(tableName)
                            .select('audit_duration, submitted_at')
                            .not('audit_duration', 'is', null);
                        
                        // Query to count completed audits (submitted in the period) - all audits regardless of auditor
                        // All audits in scorecard tables are completed by default (they have submitted_at)
                        let completedQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at, employee_email')
                            .not('submitted_at', 'is', null);
                        
                        // Apply date filters server-side if possible (convert Dhaka to UTC)
                        if (period.start) {
                            passingQuery = passingQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            reversalQuery = reversalQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            durationQuery = durationQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            completedQuery = completedQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                        }
                        if (period.end) {
                            passingQuery = passingQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            reversalQuery = reversalQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            durationQuery = durationQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            completedQuery = completedQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                        }
                        
                        // Query for passing status, reversals, completed audits, and duration in parallel
                        const [passingResult, reversalResult, durationResult, completedResult] = await Promise.all([
                            (async () => {
                                try {
                                    let result = await passingQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('passing_status, submitted_at');
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await reversalQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at')
                                        .not('reversal_requested_at', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await durationQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('audit_duration, submitted_at')
                                        .not('audit_duration', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await completedQuery;
                                    
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at, employee_email')
                                        .not('submitted_at', 'is', null);
                                    
                                    if (retryResult.data) {
                                        if (period && (period.start || period.end)) {
                                            retryResult.data = retryResult.data.filter(audit => {
                                                if (!audit.submitted_at) return false;
                                                const auditDate = toDhakaTime(audit.submitted_at);
                                                return (!period.start || auditDate >= period.start) && 
                                                       (!period.end || auditDate <= period.end);
                                            });
                                        }
                                    }
                                    return retryResult;
                                }
                            })()
                        ]);
                        
                        return {
                            passing: passingResult.data || [],
                            reversals: reversalResult.data || [],
                            durations: durationResult.data || [],
                            completed: completedResult.data || []
                        };
                    } catch (err) {
                        console.warn(`Error querying ${tableName}:`, err);
                        return { passing: [], reversals: [], durations: [], completed: [] };
                    }
                });
                
                const results = await Promise.all(queryPromises);
                
                // Aggregate results
                let totalAudits = 0;
                let passedAudits = 0;
                
                results.forEach(result => {
                    // Count passing rate
                    result.passing.forEach(audit => {
                        totalAudits++;
                        const passingStatus = audit.passing_status || audit.passingStatus;
                        const normalizedStatus = normalizePassingStatus(passingStatus);
                        if (normalizedStatus === 'Passed') {
                            passedAudits++;
                        }
                    });
                    
                    // Count reversals
                    standupReversalCount += result.reversals.length;
                    
                    // All audits in scorecard tables are completed by default (they have submitted_at)
                    const completedAudits = result.completed;
                    
                    // Count completed audits and group by channel
                    completedAudits.forEach(audit => {
                        completed++;
                        // Group by channel for channel stats
                        if (audit.employee_email) {
                            const emp = allUsers.find(u => u.email === audit.employee_email);
                            const channel = emp?.channel || 'Unknown';
                            if (!completedAuditsByChannel[channel]) {
                                completedAuditsByChannel[channel] = 0;
                            }
                            completedAuditsByChannel[channel]++;
                        }
                    });
                });
                
                // Calculate pass rate
                if (totalAudits > 0) {
                    passingRate = Math.round((passedAudits / totalAudits) * 100);
                    passingCount = passedAudits;
                    notPassingCount = totalAudits - passedAudits;
                }
            }
        } catch (error) {
            console.error('Error calculating standup stats:', error);
        }
        
        console.log('Standup View - Reversal count:', standupReversalCount);
        console.log('Standup View - Completed count:', completed);
        
        // Calculate backlog and early completions (assignments completed on a different day than scheduled)
        // Filter by completed_at date to show work completed in the selected period
        // Use Dhaka timezone for date comparison to match the rest of the dashboard
        // Early = completed before scheduled_date
        // Backlog = completed after scheduled_date
        let totalBacklogCount = 0;
        let totalEarlyCount = 0;
        let backlogByChannel = {}; // Track backlog per channel
        let earlyByChannel = {}; // Track early completions per channel
        
        try {
            // Fetch all completed assignments (any role), filtered by completed_at date
            let backlogQuery = window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .eq('status', 'completed')
                .not('completed_at', 'is', null);
            
            // Filter by completed_at date (when the audit was completed, not when it was assigned)
            if (period.start) {
                backlogQuery = backlogQuery.gte('completed_at', dhakaDateToUTCISO(period.start));
            }
            if (period.end) {
                backlogQuery = backlogQuery.lte('completed_at', dhakaDateToUTCISO(period.end));
            }
            
            const { data: completedAssignments, error: backlogError } = await backlogQuery;
            
            if (!backlogError && completedAssignments) {
                // Filter client-side to ensure accuracy with Dhaka timezone
                const earlyItems = [];
                const backlogItems = [];
                
                completedAssignments.forEach(a => {
                    if (!a.completed_at) return;
                    const completedDate = toDhakaTime(a.completed_at);
                    // Check if completed date falls within the period
                    const inPeriod = (!period.start || completedDate >= period.start) && 
                                    (!period.end || completedDate <= period.end);
                    if (!inPeriod) return;
                    
                    // Get scheduled date (prefer scheduled_date, fallback to created_at)
                    let scheduledDate;
                    if (a.scheduled_date) {
                        scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                    } else if (a.created_at) {
                        scheduledDate = getDhakaStartOfDay(a.created_at);
                    } else {
                        return; // No scheduled date to compare
                    }
                    
                    const completedDay = getDhakaStartOfDay(completedDate);
                    const scheduledDay = getDhakaStartOfDay(scheduledDate);
                    
                    // If scheduled date is different from completed date
                    if (scheduledDay.getTime() !== completedDay.getTime()) {
                        // Early = completed before scheduled date
                        if (completedDay.getTime() < scheduledDay.getTime()) {
                            earlyItems.push(a);
                        } else {
                            // Backlog = completed after scheduled date
                            backlogItems.push(a);
                        }
                    }
                });
                
                totalEarlyCount = earlyItems.length;
                totalBacklogCount = backlogItems.length;
                
                // Group early and backlog by channel
                earlyItems.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!earlyByChannel[channel]) {
                        earlyByChannel[channel] = 0;
                    }
                    earlyByChannel[channel]++;
                });
                
                backlogItems.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!backlogByChannel[channel]) {
                        backlogByChannel[channel] = 0;
                    }
                    backlogByChannel[channel]++;
                });
            } else if (backlogError) {
                // Fallback: filter from all assignments if query fails
                const earlyItems = [];
                const backlogItems = [];
                
                allAuditAssignments.forEach(a => {
                    if (a.status !== 'completed' || !a.completed_at) return;
                    const completedDate = toDhakaTime(a.completed_at);
                    // Check if completed date falls within the period
                    const inPeriod = (!period.start || completedDate >= period.start) && 
                                    (!period.end || completedDate <= period.end);
                    if (!inPeriod) return;
                    
                    // Get scheduled date (prefer scheduled_date, fallback to created_at)
                    let scheduledDate;
                    if (a.scheduled_date) {
                        scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                    } else if (a.created_at) {
                        scheduledDate = getDhakaStartOfDay(a.created_at);
                    } else {
                        return;
                    }
                    
                    const completedDay = getDhakaStartOfDay(completedDate);
                    const scheduledDay = getDhakaStartOfDay(scheduledDate);
                    
                    // If scheduled date is different from completed date
                    if (scheduledDay.getTime() !== completedDay.getTime()) {
                        // Early = completed before scheduled date
                        if (completedDay.getTime() < scheduledDay.getTime()) {
                            earlyItems.push(a);
                        } else {
                            // Backlog = completed after scheduled date
                            backlogItems.push(a);
                        }
                    }
                });
                
                totalEarlyCount = earlyItems.length;
                totalBacklogCount = backlogItems.length;
                
                // Group early and backlog by channel
                earlyItems.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!earlyByChannel[channel]) {
                        earlyByChannel[channel] = 0;
                    }
                    earlyByChannel[channel]++;
                });
                
                backlogItems.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!backlogByChannel[channel]) {
                        backlogByChannel[channel] = 0;
                    }
                    backlogByChannel[channel]++;
                });
            }
        } catch (error) {
            console.warn('Error calculating backlog/early for standup view:', error);
            // Fallback to simple calculation from allAuditAssignments
            const earlyItems = [];
            const backlogItems = [];
            
            allAuditAssignments.forEach(a => {
                if (a.status !== 'completed' || !a.completed_at) return;
                
                // Get scheduled date (prefer scheduled_date, fallback to created_at)
                let scheduledDate;
                if (a.scheduled_date) {
                    scheduledDate = getDhakaStartOfDay(parseDhakaDate(a.scheduled_date));
                } else if (a.created_at) {
                    scheduledDate = getDhakaStartOfDay(a.created_at);
                } else {
                    return;
                }
                
                const completedDate = toDhakaTime(a.completed_at);
                const completedDay = getDhakaStartOfDay(completedDate);
                const scheduledDay = getDhakaStartOfDay(scheduledDate);
                
                // If scheduled date is different from completed date
                if (scheduledDay.getTime() !== completedDay.getTime()) {
                    // Early = completed before scheduled date
                    if (completedDay.getTime() < scheduledDay.getTime()) {
                        earlyItems.push(a);
                    } else {
                        // Backlog = completed after scheduled date
                        backlogItems.push(a);
                    }
                }
            });
            
            totalEarlyCount = earlyItems.length;
            totalBacklogCount = backlogItems.length;
            
            // Group early and backlog by channel
            earlyItems.forEach(a => {
                const emp = allUsers.find(u => u.email === a.employee_email);
                const channel = emp?.channel || 'Unknown';
                if (!earlyByChannel[channel]) {
                    earlyByChannel[channel] = 0;
                }
                earlyByChannel[channel]++;
            });
            
            backlogItems.forEach(a => {
                const emp = allUsers.find(u => u.email === a.employee_email);
                const channel = emp?.channel || 'Unknown';
                if (!backlogByChannel[channel]) {
                    backlogByChannel[channel] = 0;
                }
                backlogByChannel[channel]++;
            });
        }
        
        // Exclude backlog and early audits from completed count (matching Team Stats logic exactly)
        // Completed count should only show same-day completions (not backlog/early)
        const sameDayCompleted = Math.max(0, completed - totalBacklogCount - totalEarlyCount);
        
        // Calculate percentage and coverage (using same-day completed count, matching Team Stats)
        const percentage = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        const coveragePercent = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        
        // Group assignments by channel (for assigned, inProgress, pending counts)
        const channelStats = {};
        
        allAuditAssignments.forEach(assignment => {
            // Find the employee to get their channel
            const emp = allUsers.find(u => u.email === assignment.employee_email);
            const channel = emp?.channel || 'Unknown';
            
            if (!channelStats[channel]) {
                channelStats[channel] = {
                    assigned: 0,
                    completed: 0, // Will be set from scorecard tables (same-day only)
                    inProgress: 0,
                    pending: 0,
                    remaining: 0,
                    percentage: 0
                };
            }
            
            channelStats[channel].assigned++;
            
            if (assignment.status === 'in_progress') {
                channelStats[channel].inProgress++;
            } else if (assignment.status === 'pending') {
                channelStats[channel].pending++;
            }
            // Note: completed count comes from scorecard tables, not assignment status
        });
        
        // Update completed counts from scorecard tables (completedAuditsByChannel)
        // This was populated in the results.forEach loop above
        // Exclude backlog and early per channel to match Team Stats logic
        Object.keys(completedAuditsByChannel || {}).forEach(channel => {
            if (!channelStats[channel]) {
                channelStats[channel] = {
                    assigned: 0,
                    completed: 0,
                    inProgress: 0,
                    pending: 0,
                    remaining: 0,
                    percentage: 0
                };
            }
            // Exclude backlog and early from completed count per channel (matching Team Stats logic)
            const channelBacklog = backlogByChannel[channel] || 0;
            const channelEarly = earlyByChannel[channel] || 0;
            const channelCompleted = completedAuditsByChannel[channel] || 0;
            channelStats[channel].completed = Math.max(0, channelCompleted - channelBacklog - channelEarly);
        });
        
        // Calculate remaining and percentage for each channel (using same-day completed count)
        Object.keys(channelStats).forEach(channel => {
            const stats = channelStats[channel];
            stats.remaining = stats.pending + stats.inProgress;
            stats.percentage = stats.assigned > 0 ? Math.round((stats.completed / stats.assigned) * 100) : 0;
        });
        
        // Prepare the standup data (using sameDayCompleted to match Team Stats)
        const standupData = {
            totalAssigned,
            completed: sameDayCompleted, // Use same-day completed count (excluding backlog)
            percentage,
            coveragePercent,
            passingRate,
            passingCount,
            notPassingCount,
            standupReversalCount,
            channelStats
        };
        
        // Check if this fetch is still the current one before updating UI
        if (fetchId !== currentFetchId) {
            console.log('Standup view fetch cancelled - newer fetch in progress');
            return;
        }
        
        // Update UI with fresh data (only if still on Standup View tab)
        if (currentTab === 1) {
            console.log('Updating UI with fresh standup view data');
            renderStandupViewData(standupData);
            hideLoadingState();
        } else {
            console.log('Skipping standup view render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading standup view:', error);
        // Show error in table
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && currentTab === 1) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading data. Please try again.</div>';
        }
    }
}

// ============================================================================
// Tab Switching
// ============================================================================
    async function switchTab(tabElement, index) {
    currentTab = index;
    
        const tabs = document.querySelectorAll('button[onclick*="switchTab"]');
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        // Remove active class from all tabs
        tabs.forEach(tab => tab.classList.remove('active'));
        // Add active class to clicked tab
        tabElement.classList.add('active');
        
        // Calculate position based on tab index and container width
        const containerPadding = 5; // 0.2344rem = 0.1758rem
        const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
        const sliderLeft = containerPadding + (index * tabWidth);
        
        slider.style.left = `${sliderLeft}px`;
        slider.style.width = `${tabWidth}px`;
        
    // Show/hide hourly breakdown based on tab
    const hourlyBreakdownTable = document.getElementById('hourlyBreakdownTable');
    if (hourlyBreakdownTable) {
        if (index === 0) {
            // Team Stats - show hourly breakdown
            hourlyBreakdownTable.style.display = 'block';
        } else {
            // Standup View - hide hourly breakdown
            hourlyBreakdownTable.style.display = 'none';
        }
    }
    
    // Show/hide dynamic hourly breakdown based on tab
    const dynamicHourlyBreakdownTable = document.getElementById('dynamicHourlyBreakdownTable');
    if (dynamicHourlyBreakdownTable) {
        if (index === 0) {
            // Team Stats - show dynamic hourly breakdown
            dynamicHourlyBreakdownTable.style.display = 'block';
        } else {
            // Standup View - hide dynamic hourly breakdown
            dynamicHourlyBreakdownTable.style.display = 'none';
        }
    }
    
    // Show loading state when switching tabs
    showLoadingState();
    
    // Update dashboard based on tab
    await updateDashboard();
}

// ============================================================================
// Initialize Slider
// ============================================================================
function initializeSlider() {
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        if (slider && tabBar) {
            // Disable transition for initial positioning
            slider.style.transition = 'none';
            
            // Calculate position for first tab (index 0)
            const containerPadding = 5; // 0.2344rem = 0.1758rem
            const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
            const sliderLeft = containerPadding + (0 * tabWidth); // First tab
            
            slider.style.left = `${sliderLeft}px`;
            slider.style.width = `${tabWidth}px`;
            
            // Re-enable transition after positioning
            requestAnimationFrame(() => {
                slider.style.transition = 'all 0.3s ease';
            });
        }
}

// ============================================================================
// Filter Functions
// ============================================================================
function toggleFilters() {
    const dropdown = document.getElementById('filterDropdown');
    const filterBtn = document.getElementById('filterBtn');
    if (dropdown && filterBtn) {
        dropdown.classList.toggle('active');
        filterBtn.classList.toggle('active');
    }
}

function populateChannelFilter() {
    const channelFilter = document.getElementById('channelFilter');
    if (!channelFilter) return;
    
    // Get unique channels from all users
    const uniqueChannels = [...new Set(allUsers.map(u => u.channel).filter(Boolean))];
    
    // Clear existing options except "All Channels"
    const existingValue = channelFilter.value;
    channelFilter.innerHTML = '<option value="">All Channels</option>';
    
    // Add channel options
    uniqueChannels.sort().forEach(channel => {
        const option = document.createElement('option');
        option.value = channel;
        option.textContent = channel;
        channelFilter.appendChild(option);
    });
    
    if (existingValue) channelFilter.value = existingValue;
}

function populateAuditorFilter() {
    const auditorFilter = document.getElementById('auditorFilter');
    if (!auditorFilter) return;
    
    // Get all unique auditors from assignments (any role, not just Quality Analysts)
    const auditorEmails = [...new Set(unfilteredAssignments.map(a => a.auditor_email).filter(Boolean))];
    const auditors = auditorEmails.map(email => {
        const user = allUsers.find(u => u.email === email);
        return user || { email, name: email };
    });
    
    const existingValue = auditorFilter.value;
    auditorFilter.innerHTML = '<option value="">All Auditors</option>';
    
    auditors.sort((a, b) => (a.name || a.email).localeCompare(b.name || b.email)).forEach(auditor => {
        const option = document.createElement('option');
        option.value = auditor.email;
        option.textContent = auditor.name || auditor.email;
        auditorFilter.appendChild(option);
    });
    
    if (existingValue) auditorFilter.value = existingValue;
}

function populateEmployeeFilter() {
    const employeeFilter = document.getElementById('employeeFilter');
    if (!employeeFilter) return;
    
    // Get unique employees from assignments
    const employeeEmails = [...new Set(unfilteredAssignments.map(a => a.employee_email).filter(Boolean))];
    
    const existingValue = employeeFilter.value;
    employeeFilter.innerHTML = '<option value="">All Employees</option>';
    
    employeeEmails.sort().forEach(email => {
        const user = allUsers.find(u => u.email === email);
        const option = document.createElement('option');
        option.value = email;
        option.textContent = user?.name || email;
        employeeFilter.appendChild(option);
    });
    
    if (existingValue) employeeFilter.value = existingValue;
}

function populateScorecardFilter() {
    const scorecardFilter = document.getElementById('scorecardFilter');
    if (!scorecardFilter) return;
    
    const existingValue = scorecardFilter.value;
    scorecardFilter.innerHTML = '<option value="">All Scorecards</option>';
    
    allScorecards.forEach(scorecard => {
        const option = document.createElement('option');
        option.value = scorecard.id;
        option.textContent = scorecard.name;
        scorecardFilter.appendChild(option);
    });
    
    if (existingValue) scorecardFilter.value = existingValue;
}

async function applyFilters() {
    // Show loading state when filters change
    showLoadingState();
    
    // Get filter values
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    currentFilters.status = statusEl ? statusEl.value : '';
    currentFilters.channel = channelEl ? channelEl.value : '';
    currentFilters.auditor = auditorEl ? auditorEl.value : '';
    currentFilters.employee = employeeEl ? employeeEl.value : '';
    currentFilters.scorecard = scorecardEl ? scorecardEl.value : '';
    
    // Start with unfiltered assignments (these are already filtered by date/week period from database)
    // unfilteredAssignments contains assignments for the current period only
    if (!unfilteredAssignments || unfilteredAssignments.length === 0) {
        console.warn('No unfiltered assignments available. Data may still be loading.');
        allAssignments = [];
    } else {
        allAssignments = [...unfilteredAssignments];
    }
    
    // Apply status filter
    if (currentFilters.status) {
        allAssignments = allAssignments.filter(a => a.status === currentFilters.status);
    }
    
    // Apply channel filter (need to look up employee's channel)
    if (currentFilters.channel) {
        allAssignments = allAssignments.filter(a => {
            const emp = allUsers.find(u => u.email === a.employee_email);
            return emp && emp.channel === currentFilters.channel;
        });
    }
    
    // Apply auditor filter
    if (currentFilters.auditor) {
        allAssignments = allAssignments.filter(a => a.auditor_email === currentFilters.auditor);
    }
    
    // Apply employee filter
    if (currentFilters.employee) {
        allAssignments = allAssignments.filter(a => a.employee_email === currentFilters.employee);
    }
    
    // Apply scorecard filter
    if (currentFilters.scorecard) {
        allAssignments = allAssignments.filter(a => a.scorecard_id === currentFilters.scorecard);
    }
    
    // Note: Date/week filtering is already applied when loading assignments from the database
    // in fetchAndCacheAssignments() and fetchAndCacheTeamStats(), so we don't need to filter again here
    // The unfilteredAssignments are already filtered by the current period (month/week/date range)
    
    console.log(`Filtered to ${allAssignments.length} assignments`);
    
    // Update the dashboard with filtered data
    await updateDashboard();
}

async function clearFilters() {
    // Reset filter inputs
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    if (statusEl) statusEl.value = '';
    if (channelEl) channelEl.value = '';
    if (auditorEl) auditorEl.value = '';
    if (employeeEl) employeeEl.value = '';
    if (scorecardEl) scorecardEl.value = '';
    
    // Reset filter state
    currentFilters = {
        status: '',
        channel: '',
        auditor: '',
        employee: '',
        scorecard: ''
    };
    
    // Restore unfiltered data
    allAssignments = [...unfilteredAssignments];
    
    // Update the dashboard
    await updateDashboard();
}

// ============================================================================
// Week and Date Filter Functions
// ============================================================================
function initializeTodayFilter() {
    const today = getDhakaNow();
    const startOfDay = getDhakaStartOfDay(today);
    const endOfDay = getDhakaEndOfDay(today);
    const startOfDayStr = formatDhakaDateForInput(startOfDay);
    const endOfDayStr = formatDhakaDateForInput(endOfDay);
    
    // Set date filter to today
    dateFilter.start = startOfDayStr;
    dateFilter.end = endOfDayStr;
    useWeekFilter = false;
    
    // Update date input fields
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    
    if (startDateEl) startDateEl.value = startOfDayStr;
    if (endDateEl) endDateEl.value = endOfDayStr;
    
    // Update date button text to show today
    if (dateBtnTextEl) {
        const start = formatDhakaDate(startOfDay, { month: 'short', day: 'numeric' });
        const end = formatDhakaDate(endOfDay, { month: 'short', day: 'numeric' });
        dateBtnTextEl.textContent = `${start} - ${end}`;
    }
    
    // Activate "Today" button
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    const todayBtn = document.getElementById('todayBtn');
    if (todayBtn) {
        todayBtn.classList.add('active');
    }
    
    // Update week display to show it's disabled
    updateWeekDisplay();
}

function updateWeekDisplay() {
    const weekTextEl = document.getElementById('weekText');
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    if (weekTextEl) {
        if (useWeekFilter && currentWeek !== null) {
            weekTextEl.textContent = `Week ${currentWeek}`;
        } else {
            weekTextEl.textContent = `Week ${currentWeek || '-'}`;
        }
    }
    
    // Always enable week navigation buttons - they can switch to week view when clicked
    // Matching employee-performance.html and audit-reports.html UX
    if (prevWeekBtn) {
        prevWeekBtn.disabled = false;
        prevWeekBtn.style.opacity = '1';
        prevWeekBtn.style.cursor = 'pointer';
    }
    
    if (nextWeekBtn) {
        nextWeekBtn.disabled = false;
        nextWeekBtn.style.opacity = '1';
        nextWeekBtn.style.cursor = 'pointer';
    }
    
    // Update week display styling
    if (weekDisplay) {
        if (useWeekFilter) {
            weekDisplay.style.backgroundColor = 'var(--primary-color)';
            weekDisplay.style.color = 'var(--white)';
            weekDisplay.style.borderColor = 'var(--primary-color)';
            weekDisplay.style.cursor = 'default';
        } else {
            weekDisplay.style.backgroundColor = '#f3f4f6';
            weekDisplay.style.color = '#6b7280';
            weekDisplay.style.borderColor = '#e5e7eb';
            weekDisplay.style.cursor = 'pointer';
        }
    }
}

function navigateWeek(direction) {
    // Cancel any ongoing fetches by incrementing the fetch ID
    currentFetchId++;
    
    // Reset loading and render states to allow new fetch to start
    isLoading = false;
    renderInProgress = false;
    
    // Show loading state when navigating weeks
    showLoadingState();
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    // Switch to week view when navigating (if not already in week view)
    if (!useWeekFilter) {
        useWeekFilter = true;
        dateFilter.start = null;
        dateFilter.end = null;
        const startDateEl = document.getElementById('startDate');
        const endDateEl = document.getElementById('endDate');
        const dateBtnTextEl = document.getElementById('dateBtnText');
        if (startDateEl) startDateEl.value = '';
        if (endDateEl) endDateEl.value = '';
        if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
        
        // Clear active state of quick filter buttons when switching to week view
        const quickDateButtons = document.querySelectorAll('.quick-date-btn');
        quickDateButtons.forEach(btn => btn.classList.remove('active'));
    }
    
    currentWeek += direction;
    
    if (currentWeek > 52) {
        currentWeek = 1;
        currentWeekYear += 1;
    } else if (currentWeek < 1) {
        currentWeek = 52;
        currentWeekYear -= 1;
    }
    
    updateWeekDisplay();
    
    // Reload assignments with new week filter
    loadAssignments();
}

// Function to switch to week view when week display is clicked
function switchToWeekView() {
    // Cancel any ongoing fetches by incrementing the fetch ID
    currentFetchId++;
    
    // Reset loading and render states to allow new fetch to start
    isLoading = false;
    renderInProgress = false;
    
    // Show loading state when switching to week view
    showLoadingState();
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    useWeekFilter = true;
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    
    // Clear active state of quick filter buttons when switching to week view
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    
    updateWeekDisplay();
    
    // Reload assignments with new week filter
    loadAssignments();
}

function setupEventListeners() {
    // Week navigation buttons
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    if (prevWeekBtn) {
        prevWeekBtn.addEventListener('click', () => {
            // If in month view, switch to week view first
            if (!useWeekFilter) {
                switchToWeekView();
            }
            // Navigate (will work whether we just switched or were already in week view)
            navigateWeek(-1);
        });
    }
    if (nextWeekBtn) {
        nextWeekBtn.addEventListener('click', () => {
            // If in month view, switch to week view first
            if (!useWeekFilter) {
                switchToWeekView();
            }
            // Navigate (will work whether we just switched or were already in week view)
            navigateWeek(1);
        });
    }
    
    // Make week display clickable to switch to week view when in month view
    if (weekDisplay) {
        weekDisplay.addEventListener('click', function() {
            if (!useWeekFilter) {
                switchToWeekView();
            }
        });
    }

    // Date button
    const dateBtn = document.getElementById('dateBtn');
    if (dateBtn) {
        dateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('dateDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        });
    }

    // Filter button
    const filterBtn = document.getElementById('filterBtn');
    if (filterBtn) {
        filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFilters();
        });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.date-picker-dropdown')) {
            const dateDropdown = document.getElementById('dateDropdown');
            if (dateDropdown) {
                dateDropdown.classList.remove('active');
            }
        }
        if (!e.target.closest('.filter-dropdown')) {
            const filterDropdown = document.getElementById('filterDropdown');
            const filterBtn = document.getElementById('filterBtn');
            if (filterDropdown) {
                filterDropdown.classList.remove('active');
            }
            if (filterBtn) {
                filterBtn.classList.remove('active');
            }
        }
    });
}

window.applyDateFilter = function() {
    // Cancel any ongoing fetches by incrementing the fetch ID
    currentFetchId++;
    
    // Reset loading and render states to allow new fetch to start
    isLoading = false;
    renderInProgress = false;
    
    // Show loading state when date filter changes
    showLoadingState();
    
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const startDate = startDateEl?.value || '';
    const endDate = endDateEl?.value || '';
    
    // Store as date strings to match employee-performance.html
    if (startDate) {
        dateFilter.start = startDate;
    } else {
        dateFilter.start = null;
    }
    
    if (endDate) {
        dateFilter.end = endDate;
    } else {
        dateFilter.end = null;
    }

    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDate || endDate) {
        // If only one date is provided, set both start and end to that date (single day view)
        if (startDate && !endDate) {
            dateFilter.end = startDate;
        } else if (endDate && !startDate) {
            dateFilter.start = endDate;
        }
        
        const start = startDate ? formatDhakaDate(parseDhakaDate(startDate), { month: 'short', day: 'numeric' }) : 'Start';
        const end = endDate ? formatDhakaDate(parseDhakaDate(endDate), { month: 'short', day: 'numeric' }) : 'End';
        if (dateBtnTextEl) dateBtnTextEl.textContent = `${start} - ${end}`;
        useWeekFilter = false;
        
        // Clear active state of quick filter buttons when using custom date range
        const quickDateButtons = document.querySelectorAll('.quick-date-btn');
        quickDateButtons.forEach(btn => btn.classList.remove('active'));
        
        updateWeekDisplay(); // Update week display to show "-"
    } else {
        // If both dates are cleared, reset to today view
        initializeTodayFilter();
    }

    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    
    // Reload assignments with new date filter
    loadAssignments();
};

window.clearDateFilter = function() {
    // Cancel any ongoing fetches by incrementing the fetch ID
    currentFetchId++;
    
    // Reset loading and render states to allow new fetch to start
    isLoading = false;
    renderInProgress = false;
    
    // Show loading state when clearing date filter
    showLoadingState();
    
    // Reset to today view
    initializeTodayFilter();
    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    updateWeekDisplay(); // Update week display
    
    // Reload assignments with today filter
    loadAssignments();
};

// Use shared date filter utility - wrap to provide page-specific callbacks
const originalApplyQuickDateFilter = window.applyQuickDateFilter;
window.applyQuickDateFilter = function(period) {
    // Cancel any ongoing fetches by incrementing the fetch ID
    currentFetchId++;
    
    // Reset loading and render states to allow new fetch to start
    isLoading = false;
    renderInProgress = false;
    
    // Show loading state when quick date filter changes
    showLoadingState();
    
    // Call the original function to update the date filter state
    originalApplyQuickDateFilter(period, {
        dateFilter: dateFilter,
        setUseWeekFilter: () => { useWeekFilter = false; },
        onUpdate: updateWeekDisplay,
        onRefresh: () => {
            // This callback might be called asynchronously, so we also call loadAssignments directly below
        }
    });
    
    // Call loadAssignments() directly to ensure it starts immediately and synchronously
    loadAssignments();
};

// Helper function to normalize passing status (handles both old and new values)
// Matching audit-reports.html implementation
function normalizePassingStatus(status) {
    if (!status) return status;
    
    // Convert to string and trim
    const statusStr = String(status).trim();
    
    // Convert old values to new ones for consistency
    // Handle "Passing", "Pass", "passed" (case-insensitive)
    if (statusStr === 'Passing' || statusStr === 'Pass' || statusStr.toLowerCase() === 'passed') {
        return 'Passed';
    }
    // Handle "Not Passing", "Not Pass", "not passed" (case-insensitive)
    if (statusStr === 'Not Passing' || statusStr === 'Not Pass' || statusStr.toLowerCase() === 'not passed') {
        return 'Not Passed';
    }
    
    // Return as-is if already normalized or unknown
    return statusStr;
}

// ============================================================================
// Realtime Presence Functions
// ============================================================================
async function setupPresenceTracking() {
    try {
        if (!window.supabaseClient || !currentUserEmail) {
            console.warn('Cannot setup presence: Supabase or user email not available');
            return;
        }

        // Get user info to check role
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        // Create a channel for auditor presence
        const channelName = 'auditor-presence';
        presenceChannel = window.supabaseClient.channel(channelName, {
            config: {
                presence: {
                    key: currentUserEmail, // Use email as presence key
                }
            }
        });

        // Track current user's presence
        presenceChannel
            .on('presence', { event: 'sync' }, () => {
                updateOnlineAuditors();
            })
            .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                console.log('User joined:', key, newPresences);
                updateOnlineAuditors();
            })
            .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                console.log('User left:', key, leftPresences);
                updateOnlineAuditors();
            })
            .subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    // Track current user as online
                    await trackPresence();
                    
                    // Set up heartbeat to keep presence alive
                    startHeartbeat();
                }
            });
    } catch (error) {
        console.error('Error setting up presence tracking:', error);
    }
}

async function trackPresence() {
    try {
        if (!presenceChannel) return;

        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        await presenceChannel.track({
            email: currentUserEmail,
            name: userInfo.name || currentUserEmail,
            role: userRole,
            online_at: dhakaDateToUTCISO(getDhakaNow()),
            page: 'auditor-dashboard'
        });
    } catch (error) {
        console.error('Error tracking presence:', error);
    }
}

function startHeartbeat() {
    // Clear any existing heartbeat
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
    }

    // Send heartbeat every 30 seconds to keep presence alive
    heartbeatInterval = setInterval(async () => {
        await trackPresence();
    }, 30000); // 30 seconds
}

function stopHeartbeat() {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
    }
}

function updateOnlineAuditors() {
    try {
        if (!presenceChannel) return;

        const state = presenceChannel.presenceState();
        const newOnlineAuditors = new Set();

        // Extract online auditor emails from presence state
        Object.values(state).forEach((presences) => {
            presences.forEach((presence) => {
                if (presence.role === 'Quality Analyst' && presence.email) {
                    newOnlineAuditors.add(presence.email);
                }
            });
        });

        onlineAuditors = newOnlineAuditors;
        
        // Update the UI to reflect online status
        updateOnlineStatusIndicators();
    } catch (error) {
        console.error('Error updating online auditors:', error);
    }
}

function updateOnlineStatusIndicators() {
    // Update status indicators in the table
    const tableBody = document.getElementById('performanceTableBody');
    if (!tableBody) return;

    // Find all rows and update their online status
    const rows = tableBody.querySelectorAll('div[data-auditor-email]');
    rows.forEach(row => {
        const auditorEmail = row.dataset.auditorEmail;
        const nameCell = row.querySelector('[data-label="Name"]');
        
        if (nameCell && auditorEmail) {
            if (onlineAuditors.has(auditorEmail)) {
                // Add or update online indicator
                let indicator = nameCell.querySelector('.online-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'online-indicator';
                    indicator.style.cssText = 'display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);';
                    indicator.title = 'Online';
                    nameCell.appendChild(indicator);
                }
            } else {
                // Remove online indicator
                const indicator = nameCell.querySelector('.online-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }
    });
}

async function cleanupPresence() {
    try {
        stopHeartbeat();
        
        if (presenceChannel) {
            await presenceChannel.untrack();
            await presenceChannel.unsubscribe();
            presenceChannel = null;
        }
    } catch (error) {
        console.error('Error cleaning up presence:', error);
    }
}

// ============================================================================
// Loading State Functions
// ============================================================================
function showLoadingState() {
    // Clear any existing timeout
    if (loadingTimeout) {
        clearTimeout(loadingTimeout);
    }
    
    // Show loading after a short delay to avoid flicker for fast loads
    loadingTimeout = setTimeout(() => {
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && !tableBody.querySelector('.loading-indicator')) {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-indicator';
            loadingDiv.style.cssText = 'text-align: center; padding: 2rem; color: #6b7280;';
            loadingDiv.innerHTML = `
                <div style="display: inline-block; width: 1.5rem; height: 1.5rem; border: 0.1875rem solid #e5e7eb; border-top-color: var(--primary-color); border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
                <div style="margin-top: 0.75rem; font-size: 0.6562rem;">Loading...</div>
            `;
            tableBody.innerHTML = '';
            tableBody.appendChild(loadingDiv);
        }
        
        // Add fade effect to stat cards
        const statCards = document.querySelectorAll('#statsContainer > div');
        statCards.forEach(card => {
            card.style.opacity = '0.6';
            card.style.transition = 'opacity 0.3s ease';
        });
    }, 200); // 200ms delay before showing loading
}

function hideLoadingState() {
    // Clear timeout if loading hasn't shown yet
    if (loadingTimeout) {
        clearTimeout(loadingTimeout);
        loadingTimeout = null;
    }
    
    // Remove loading indicator
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        const loadingIndicator = tableBody.querySelector('.loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.remove();
        }
    }
    
    // Restore stat cards opacity
    const statCards = document.querySelectorAll('#statsContainer > div');
    statCards.forEach(card => {
        card.style.opacity = '1';
    });
}

// ============================================================================
// Utility Functions
// ============================================================================
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Get progress bar color based on completion percentage (temperature-based)
function getProgressBarColor(percentage) {
    if (percentage <= 33) {
        // Red for low completion (0-33%)
        return 'linear-gradient(90deg, #ef4444, #f87171)';
    } else if (percentage <= 66) {
        // Yellow for medium completion (34-66%)
        return 'linear-gradient(90deg, #f59e0b, #fbbf24)';
    } else {
        // Green for high completion (67-100%)
        return 'linear-gradient(90deg, #10b981, #34d399)';
    }
}

// ============================================================================
// Cleanup on page unload
// ============================================================================
window.addEventListener('beforeunload', async () => {
    await cleanupPresence();
});
</script>


</body>
</html>
