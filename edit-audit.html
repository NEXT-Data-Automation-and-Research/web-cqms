<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Edit Audit | CQMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="intercom-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="dark-mode.js"></script>
    <script src="search.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f9fafb;
        }
        
        .full-width-container {
            width: 100%;
            padding: 0;
            margin: 0;
        }
        
        /* Override main-content padding and width for full-width form */
        .main-content {
            padding: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }

        /* Dark Mode Styles */
        [data-theme="dark"] body {
            background-color: var(--background-color) !important;
        }

        [data-theme="dark"] .full-width-container {
            background-color: var(--background-color) !important;
        }

        [data-theme="dark"] [style*="background: #f9fafb"],
        [data-theme="dark"] [style*="background:#f9fafb"],
        [data-theme="dark"] [style*="background-color: #f9fafb"],
        [data-theme="dark"] [style*="background-color:#f9fafb"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        [data-theme="dark"] [style*="background: white"],
        [data-theme="dark"] [style*="background:white"],
        [data-theme="dark"] [style*="background-color: white"],
        [data-theme="dark"] [style*="background-color:white"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        [data-theme="dark"] [style*="color: #374151"],
        [data-theme="dark"] [style*="color:#374151"],
        [data-theme="dark"] [style*="color: #1f2937"],
        [data-theme="dark"] [style*="color:#1f2937"] {
            color: var(--text-color) !important;
        }

        /* Text colors - ensure maximum contrast */
        [data-theme="dark"] [style*="color: #000000"],
        [data-theme="dark"] [style*="color:#000000"] {
            color: #ffffff !important; /* Pure white for maximum contrast in dark mode */
        }

        [data-theme="dark"] [style*="color: #1f2937"],
        [data-theme="dark"] [style*="color:#1f2937"],
        [data-theme="dark"] [style*="color: #374151"],
        [data-theme="dark"] [style*="color:#374151"] {
            color: #ffffff !important; /* Pure white for maximum contrast in dark mode */
        }

        [data-theme="dark"] [style*="border:"] [style*="#e5e7eb"],
        [data-theme="dark"] [style*="border-color: #e5e7eb"],
        [data-theme="dark"] [style*="border-color:#e5e7eb"],
        [data-theme="dark"] [style*="border:"] [style*="#d1d5db"],
        [data-theme="dark"] [style*="border-color: #d1d5db"],
        [data-theme="dark"] [style*="border-color:#d1d5db"] {
            border-color: var(--border-light) !important;
        }

        [data-theme="dark"] select,
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] input[type="date"],
        [data-theme="dark"] textarea {
            background-color: var(--background-white) !important;
            color: #ffffff !important; /* Pure white text for maximum contrast */
            border-color: var(--border-light) !important;
        }

        /* Error Details Header and containers - Make dark */
        [data-theme="dark"] [style*="background-color: #f8f9fa"],
        [data-theme="dark"] [style*="background-color:#f8f9fa"] {
            background-color: var(--background-white) !important;
        }

        /* Error Details table container - ensure dark background */
        [data-theme="dark"] [style*="background: #f9fafb"][style*="Error Details"],
        [data-theme="dark"] div[style*="background: #f9fafb"] {
            background: var(--background-white) !important;
            background-color: var(--background-white) !important;
        }

        /* Dividers - Reduce contrast */
        [data-theme="dark"] [style*="border-bottom"][style*="#f3f4f6"],
        [data-theme="dark"] [style*="border-bottom"][style*="#e5e7eb"] {
            border-bottom-color: var(--border-light) !important;
            opacity: 0.5;
        }

        /* Quill Editor Custom Styling */
        .quill-editor-container {
            width: 100%;
            min-width: 0;
            position: relative;
        }
        
        .quill-editor-container .ql-container {
            font-family: 'Poppins', sans-serif;
            font-size: 0.5659rem;
            line-height: 1.2;
            border: 0.0304rem solid #d1d5db;
            border-top: none;
            border-radius: 0 0 0.1617rem 0.1617rem;
            min-height: 1rem;
            max-height: 50rem;
            overflow-y: auto;
            background-color: white;
        }
        
        .quill-editor-container .ql-editor {
            padding: 0.2425rem 0.3234rem;
            min-height: 1rem;
        }
        
        .quill-editor-container .ql-editor.ql-blank::before {
            font-style: normal;
            color: #9ca3af;
            font-family: 'Poppins', sans-serif;
            font-size: 0.5659rem;
        }
        
        .quill-editor-container .ql-toolbar {
            border: 0.0304rem solid #d1d5db;
            border-bottom: none;
            border-radius: 0.1617rem 0.1617rem 0 0;
            padding: 0.0809rem 0.1213rem;
            background: #f9fafb;
            display: flex !important; /* Always visible and stable */
            position: relative;
            z-index: 1;
            flex-wrap: wrap;
            gap: 0.0404rem;
            margin-bottom: 0;
            min-height: 1.6169rem;
        }
        
        .quill-editor-container .ql-toolbar .ql-formats {
            margin-right: 0.0809rem;
            display: flex;
            align-items: center;
        }
        
        .quill-editor-container .ql-toolbar button {
            width: 1.1315rem;
            height: 1.1315rem;
            padding: 0.0404rem;
            margin: 0;
            border-radius: 0.0404rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quill-editor-container .ql-toolbar button svg {
            width: 0.6469rem;
            height: 0.6469rem;
        }
        
        .quill-editor-container .ql-toolbar .ql-stroke {
            stroke: #9ca3af;
            stroke-width: 1.2;
        }
        
        .quill-editor-container .ql-toolbar .ql-fill {
            fill: #9ca3af;
        }
        
        .quill-editor-container .ql-toolbar button:hover,
        .quill-editor-container .ql-toolbar button.ql-active {
            background-color: #e5e7eb;
            color: #1A733E;
        }
        
        .quill-editor-container .ql-toolbar button:hover .ql-stroke,
        .quill-editor-container .ql-toolbar button.ql-active .ql-stroke {
            stroke: #1A733E;
            stroke-width: 1.5;
        }
        
        .quill-editor-container .ql-toolbar button:hover .ql-fill,
        .quill-editor-container .ql-toolbar button.ql-active .ql-fill {
            fill: #1A733E;
        }
        
        /* Make color picker more compact */
        .quill-editor-container .ql-toolbar .ql-picker {
            height: 1.1315rem;
            font-size: 0.4852rem;
        }
        
        .quill-editor-container .ql-toolbar .ql-picker-label {
            padding: 0.0404rem 0.0809rem;
        }
        
        .quill-editor-container .ql-toolbar .ql-picker-options {
            padding: 0.1617rem;
            border-radius: 0.0809rem;
        }
        
        /* Dark mode support for Quill */
        [data-theme="dark"] .quill-editor-container .ql-container {
            background-color: var(--background-white) !important;
            color: #ffffff !important;
            border-color: var(--border-light) !important;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-editor {
            color: #ffffff !important;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-toolbar {
            background: var(--background-white) !important;
            border-color: var(--border-light) !important;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-toolbar .ql-stroke {
            stroke: #d1d5db;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-toolbar .ql-fill {
            fill: #d1d5db;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-toolbar button:hover .ql-stroke,
        [data-theme="dark"] .quill-editor-container .ql-toolbar button.ql-active .ql-stroke {
            stroke: #1A733E !important;
        }
        
        [data-theme="dark"] .quill-editor-container .ql-toolbar button:hover .ql-fill,
        [data-theme="dark"] .quill-editor-container .ql-toolbar button.ql-active .ql-fill {
            fill: #1A733E !important;
        }
        
    </style>
    <script>
    // Update inline styles on theme change - single unified handler
    document.addEventListener('themeChange', function(e) {
        const isDark = e.detail.theme === 'dark';
        const root = document.documentElement;
        const bgWhite = getComputedStyle(root).getPropertyValue('--background-white').trim();
        const borderLight = getComputedStyle(root).getPropertyValue('--border-light').trim();
        
        // Text colors - use pure white in dark mode, pure black in light mode for maximum contrast
        const textColorDark = '#ffffff'; // Pure white for maximum contrast
        const textColorLight = '#000000'; // Pure black for maximum contrast
        
        // Update background colors
        document.querySelectorAll('[style*="background: #f9fafb"], [style*="background:#f9fafb"], [style*="background-color: #f9fafb"], [style*="background-color:#f9fafb"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background', bgWhite, 'important');
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background', '#f9fafb', 'important');
                el.style.setProperty('background-color', '#f9fafb', 'important');
            }
        });
        
        document.querySelectorAll('[style*="background: white"], [style*="background:white"], [style*="background-color: white"], [style*="background-color:white"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background', bgWhite, 'important');
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background', 'white', 'important');
                el.style.setProperty('background-color', 'white', 'important');
            }
        });
        
        // Error details header and containers
        document.querySelectorAll('[style*="background-color: #f8f9fa"], [style*="background-color:#f8f9fa"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('background-color', bgWhite, 'important');
            } else {
                el.style.setProperty('background-color', '#f8f9fa', 'important');
            }
        });
        
        // Dividers - reduce contrast in dark mode
        document.querySelectorAll('[style*="border-bottom"][style*="#f3f4f6"], [style*="border-bottom"][style*="#e5e7eb"]').forEach(el => {
            if (isDark) {
                el.style.setProperty('border-bottom-color', borderLight, 'important');
                el.style.setProperty('opacity', '0.5', 'important');
            } else {
                el.style.setProperty('border-bottom-color', '#e5e7eb', 'important');
                el.style.setProperty('opacity', '1', 'important');
            }
        });
        
        // Update all text colors - single unified handler
        const textColorSelectors = [
            '[style*="color: #000000"]',
            '[style*="color:#000000"]',
            '[style*="color: #374151"]',
            '[style*="color:#374151"]',
            '[style*="color: #1f2937"]',
            '[style*="color:#1f2937"]'
        ];
        
        textColorSelectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(el => {
                if (isDark) {
                    el.style.setProperty('color', textColorDark, 'important');
                } else {
                    // Reset to appropriate light mode color based on original
                    const style = el.getAttribute('style') || '';
                    if (style.includes('#000000')) {
                        el.style.setProperty('color', textColorLight, 'important');
                    } else if (style.includes('#374151') || style.includes('#1f2937')) {
                        el.style.setProperty('color', textColorLight, 'important');
                    }
                }
            });
        });
    });
    </script>
</head>

<body style="margin: 0; padding: 0;">
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
<main class="main-content" role="main">
<div class="full-width-container">

    <!-- Edit Form - No reversal form needed in edit mode -->

    <!-- Audit Content Container -->
    <div id="auditContainer" style="width: 100%; box-sizing: border-box;">
        <!-- Loading indicator -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; padding: 3rem; width: 100%;">
            <div style="text-align: center;">
                <div style="border: 0.1406rem solid #f3f4f6; border-top: 0.1406rem solid #1A733E; border-radius: 50%; width: 2.25rem; height: 2.25rem; animation: spin 1s linear infinite; margin: 0 auto 0.75rem;"></div>
                <p style="color: #000000; font-family: 'Poppins', sans-serif;">Loading audit details...</p>
            </div>
        </div>

        <!-- Error message -->
        <div id="errorMessage" style="display: none; text-align: center; padding: 1.5rem; color: #ef4444; font-family: 'Poppins', sans-serif; width: 100%;">
            <p style="font-size: 0.8438rem; font-weight: 600; margin-bottom: 0.375rem;">Error Loading Audit</p>
            <p id="errorText" style="font-size: 0.6562rem;"></p>
            <button onclick="window.history.back()" style="margin-top: 0.75rem; padding: 0.375rem 1.125rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer;">Go Back</button>
        </div>

        <!-- Audit content will be dynamically loaded here -->
        <div id="auditContent"></div>
    </div>

</div>
<!-- End full-width-container -->
</main>

<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes pulse-attention {
        0%, 100% { 
            opacity: 1;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.02);
        }
    }

    @keyframes spin-slow {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes flash-text {
        0%, 100% { 
            opacity: 1;
        }
        50% { 
            opacity: 0.6;
        }
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
        20%, 40%, 60%, 80% { transform: translateX(2px); }
    }


/* Chat view scrollbar styling */
#transcriptChatView::-webkit-scrollbar {
    width: 0.3234rem;
}

#transcriptChatView::-webkit-scrollbar-track {
    background: #f0f2f5;
}

#transcriptChatView::-webkit-scrollbar-thumb {
    background: #9ca3af;
    border-radius: 0.1617rem;
}

#transcriptChatView::-webkit-scrollbar-thumb:hover {
    background: #6b7280;
    }
</style>

<script>
// Global audit data
let currentAudit = null;
const quillInstances = new Map();
let currentScorecardId = null;
let currentTableName = null;
let currentErrorFields = [];
let currentUserEmail = null;
let currentAuditScorecard = null;

// Get current logged-in user email
function getCurrentUserEmail() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            const user = JSON.parse(userInfo);
            return user?.email || null;
        }
    } catch (error) {
        console.error('Error getting current user email:', error);
    }
    return null;
}

// Get current logged-in user info
function getCurrentUserInfo() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            return JSON.parse(userInfo);
        }
    } catch (error) {
        console.error('Error getting current user info:', error);
    }
    return null;
}

// Check if current user is the audited employee
function isCurrentUserAuditedEmployee() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditEmployeeEmail = currentAudit.employeeEmail || currentAudit.employee_email || '';
    return auditEmployeeEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is a Quality Analyst or above (not an Agent/Employee)
function isCurrentUserQualityAnalyst() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    // Allow Quality Analyst and any role above (not Employee)
    return role !== 'Employee' && role !== '';
}

// Check if current user is an Agent/Employee
function isCurrentUserAgent() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    return role === 'Employee';
}

// Check if current user is a Team Lead
function isCurrentUserTeamLead() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = (userInfo.role || '').toLowerCase();
    return role.includes('team lead') || role.includes('teamlead') || role === 'team lead';
}

// ============================================================================
// FEATURE FLAG: Team Lead Approval Requirement
// ============================================================================
// Set to true to require Team Lead approval before QC review
// Set to false to skip Team Lead approval and go directly to QC review
// ============================================================================
const REQUIRE_TEAM_LEAD_APPROVAL = true; // Change this to true/false to enable/disable

// Check if team lead approval is required (feature flag)
async function checkTeamLeadApprovalRequired() {
    // Hardcoded for easy control - just change REQUIRE_TEAM_LEAD_APPROVAL constant above
    return REQUIRE_TEAM_LEAD_APPROVAL;
}

// Check if current user is the team supervisor of the audited employee
async function isCurrentUserTeamSupervisor() {
    if (!currentAudit || !currentUserEmail) {
        return false;
    }
    
    try {
        // Get employee email from audit
        const employeeEmail = (currentAudit.employeeEmail || currentAudit.employee_email || '').toLowerCase().trim();
        if (!employeeEmail) {
            return false;
        }
        
        // Get employee's team supervisor from users table
        const { data: employeeData, error } = await window.supabaseClient
            .from('users')
            .select('team_supervisor')
            .eq('email', employeeEmail)
            .maybeSingle();
        
        if (error || !employeeData || !employeeData.team_supervisor) {
            return false;
        }
        
        // Check if current user's email matches the team supervisor
        const teamSupervisorEmail = (employeeData.team_supervisor || '').toLowerCase().trim();
        const currentEmail = currentUserEmail.toLowerCase().trim();
        
        return teamSupervisorEmail === currentEmail;
    } catch (error) {
        console.error('Error checking team supervisor:', error);
        return false;
    }
}

// Check if current user is CQC (Quality Control)
function isCurrentUserCQC() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = (userInfo.role || '').toLowerCase();
    return role.includes('cqc') || role.includes('quality control');
}

// Get reversal workflow state from acknowledgement_status
function getReversalWorkflowState(audit) {
    if (!audit) return null;
    
    // First check if a reversal was actually requested
    const reversalRequestedAt = audit?.reversal_requested_at || audit?.reversalRequestedAt;
    if (!reversalRequestedAt) {
        return null; // No reversal requested, no workflow state
    }
    
    const ackStatus = (audit?.acknowledgement_status || audit?.acknowledgementStatus || '').toLowerCase();
    
    // Debug logging
    console.log('getReversalWorkflowState:', { ackStatus, auditId: audit.id });
    
    if (ackStatus.includes('team_lead_review')) return 'team_lead_review';
    if (ackStatus.includes('team_lead_rejected')) return 'team_lead_rejected';
    if (ackStatus.includes('qa_review') || ackStatus.includes('auditor_review')) return 'qa_review';
    if (ackStatus.includes('cqc_review')) return 'cqc_review';
    if (ackStatus.includes('cqc_sent_back')) return 'cqc_sent_back';
    if (ackStatus.includes('agent_re_review')) return 'agent_re_review';
    if (ackStatus.includes('reversal_approved')) return 'approved';
    if (ackStatus.includes('reversal_rejected')) return 'rejected';
    if (ackStatus === 'acknowledged' || ackStatus.includes('acknowledged')) return 'acknowledged';
    
    // Fallback to old logic - only if reversal was actually requested
    const approved = audit?.reversal_approved;
    if (approved === null || approved === undefined) return 'pending';
    if (approved === true || approved === 'true' || approved === 1 || approved === '1') return 'approved';
    if (approved === false || approved === 'false' || approved === 0 || approved === '0') return 'rejected';
    
    return 'pending';
}

// Build reversal journey map/roadmap indicator
async function buildReversalJourneyMap(workflowState, teamLeadApproved, audit) {
    // Check if this reversal actually went through Team Lead Review
    // This should be shown if:
    // 1. The workflow state includes team_lead_review or team_lead_approved/rejected
    // 2. OR team_lead_reviewed_by is populated (indicating it went through TL review)
    // 3. OR there's a team_lead_review state in reversal_workflow_states
    const hasTeamLeadReview = 
        workflowState === 'team_lead_review' || 
        workflowState === 'team_lead_approved' || 
        workflowState === 'team_lead_rejected' ||
        (audit && (audit.team_lead_reviewed_by || audit.teamLeadReviewedBy)) ||
        (audit && (audit.team_lead_approved !== null && audit.team_lead_approved !== undefined)) ||
        (audit && audit.acknowledgement_status && audit.acknowledgement_status.toLowerCase().includes('team_lead'));
    
    // Also check reversal_workflow_states if available
    let hasTeamLeadReviewInWorkflow = false;
    if (audit && audit.id && currentTableName) {
        try {
            const { data: reversalRequest, error: rrError } = await window.supabaseClient
                .from('reversal_requests')
                .select('id')
                .eq('audit_id', audit.id)
                .eq('scorecard_table_name', currentTableName)
                .order('requested_at', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!rrError && reversalRequest) {
                const { data: workflowStates, error: wsError } = await window.supabaseClient
                    .from('reversal_workflow_states')
                    .select('state')
                    .eq('reversal_request_id', reversalRequest.id)
                    .in('state', ['team_lead_review', 'team_lead_approved', 'team_lead_rejected']);
                
                if (!wsError && workflowStates && workflowStates.length > 0) {
                    hasTeamLeadReviewInWorkflow = true;
                }
            }
        } catch (err) {
            console.warn('Error checking workflow states for Team Lead Review:', err);
        }
    }
    
    // Show Team Lead Review stage if the reversal actually went through it
    const showTeamLeadReview = hasTeamLeadReview || hasTeamLeadReviewInWorkflow;
    
    // Define all stages in order - compact checkout-style
    // Include team_lead_review stage if the reversal actually went through it
    const stages = [
        { 
            key: 'submitted', 
            label: 'Submitted'
        }
    ];
    
    // Add team lead review stage if this reversal went through it
    if (showTeamLeadReview) {
        stages.push({
            key: 'team_lead_review', 
            label: 'Team Lead Review'
        });
    }
    
    stages.push(
        { 
            key: 'qa_review', 
            label: 'QC Review'
        },
        { 
            key: 'final_decision',
            label: 'Final Decision'
        }
    );
    
    // Determine current stage index (accounting for conditional team_lead_review stage)
    let currentStageIndex = 0;
    let currentStageKey = 'submitted';
    
    if (showTeamLeadReview) {
        // Team lead review stage exists - use index logic with TL review
        if (workflowState === 'team_lead_review' || workflowState === 'pending') {
            currentStageIndex = 1;
            currentStageKey = 'team_lead_review';
        } else if (workflowState === 'team_lead_rejected') {
            currentStageIndex = 1;
            currentStageKey = 'team_lead_rejected';
        } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
            currentStageIndex = 2;
            currentStageKey = 'qa_review';
        } else if (workflowState === 'approved' || workflowState === 'rejected') {
            // Final Decision is completed - mark it as completed, not current
            currentStageIndex = 4; // One past the last stage (Final Decision is at index 3)
            currentStageKey = workflowState === 'approved' ? 'approved' : 'rejected';
        } else if (workflowState === 'acknowledged') {
            // Acknowledged is after final decision - Final Decision is completed
            currentStageIndex = 4; // One past the last stage (Final Decision is at index 3)
            currentStageKey = 'acknowledged';
        }
    } else {
        // Team lead review stage doesn't exist - skip that stage
        if (workflowState === 'qa_review' || workflowState === 'cqc_review' || workflowState === 'pending') {
            currentStageIndex = 1; // qa_review is now at index 1 (after submitted)
            currentStageKey = 'qa_review';
        } else if (workflowState === 'approved' || workflowState === 'rejected') {
            // Final Decision is completed - mark it as completed, not current
            currentStageIndex = 3; // One past the last stage (Final Decision is at index 2)
            currentStageKey = workflowState === 'approved' ? 'approved' : 'rejected';
        } else if (workflowState === 'acknowledged') {
            // Acknowledged is after final decision - Final Decision is completed
            currentStageIndex = 3; // One past the last stage (Final Decision is at index 2)
            currentStageKey = 'acknowledged';
        }
    }
    
    // Build compact checkout-style journey map
    let journeyMapHtml = '<div style="display: flex; align-items: flex-start; width: 100%; position: relative; padding: 0.5rem 0;">';
    
    stages.forEach((stage, index) => {
        const isCompleted = index < currentStageIndex;
        const isCurrent = index === currentStageIndex;
        const isRejected = (stage.key === 'team_lead_review' && currentStageKey === 'team_lead_rejected') || 
                          (stage.key === 'final_decision' && currentStageKey === 'rejected');
        const isFuture = index > currentStageIndex;
        
        // Determine circle styles (like checkout progress)
        let circleBg = '#ffffff';
        let circleBorder = '#d1d5db';
        let circleContent = '';
        let labelColor = '#6b7280';
        let labelWeight = '500';
        
        if (isCompleted) {
            circleBg = '#16a34a';
            circleBorder = '#16a34a';
            circleContent = '<svg style="width: 0.75rem; height: 0.75rem; color: white;" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';
            labelColor = '#16a34a';
            labelWeight = '600';
        } else if (isCurrent) {
            circleBg = '#ffffff';
            circleBorder = '#2563eb';
            circleContent = `<span style="font-size: 0.625rem; font-weight: 700; color: #2563eb;">${index + 1}</span>`;
            labelColor = '#2563eb';
            labelWeight = '700';
        } else if (isRejected) {
            circleBg = '#dc2626';
            circleBorder = '#dc2626';
            circleContent = '<svg style="width: 0.75rem; height: 0.75rem; color: white;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>';
            labelColor = '#dc2626';
            labelWeight = '600';
        } else {
            circleContent = `<span style="font-size: 0.625rem; font-weight: 600; color: #6b7280;">${index + 1}</span>`;
        }
        
        // Connector line color (green if previous step completed, grey otherwise)
        const connectorColor = isCompleted ? '#16a34a' : '#e5e7eb';
        
        journeyMapHtml += `
            <div style="display: flex; flex-direction: column; align-items: center; flex: 1; position: relative;">
                ${index < stages.length - 1 ? `
                <div style="position: absolute; top: 0.625rem; left: calc(50% + 0.625rem); width: calc(100% - 1.25rem); height: 0.125rem; background: ${connectorColor}; z-index: 0;"></div>
                ` : ''}
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background: ${circleBg}; border: 0.125rem solid ${circleBorder}; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-bottom: 0.375rem; position: relative; z-index: 1;">
                    ${circleContent}
                </div>
                <span style="font-size: 0.5rem; font-weight: ${labelWeight}; color: ${labelColor}; text-align: center; font-family: 'Poppins', sans-serif; white-space: nowrap;">
                    ${stage.label}
                </span>
            </div>
        `;
    });
    
    journeyMapHtml += '</div>';
    
    return journeyMapHtml;
}

// Check if current user is the auditor of the current audit
function isCurrentUserAuditor() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditAuditorEmail = currentAudit.auditorEmail || currentAudit.auditor_email || '';
    return auditAuditorEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is the original auditor of a specific audit
function isCurrentUserOriginalAuditor(audit) {
    if (!currentUserEmail || !audit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditAuditorEmail = audit.auditorEmail || audit.auditor_email || '';
    return auditAuditorEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is Admin or Super Admin
function isCurrentUserAdmin() {
    if (!window.accessControl) {
        // Fallback: check userInfo directly
        const userInfo = getCurrentUserInfo();
        if (!userInfo) {
            return false;
        }
        
        const role = (userInfo.role || '').toLowerCase();
        return role === 'admin' || role === 'super admin';
    }
    
    return window.accessControl.isAdminOrAbove();
}

// Helper function to check if acknowledgement status is considered "acknowledged" (locked, no edits/comments)
function isAcknowledgedStatus(status) {
    if (!status) return false;
    const statusLower = status.toLowerCase();
    return statusLower === 'acknowledged' || 
           statusLower === 'acknowledged - after reversal approved' || 
           statusLower === 'acknowledged - after reversal rejected';
}

// Helper function to check if acknowledgement status should show acknowledge button
function shouldShowAcknowledgeButtonForStatus(status) {
    if (!status) return true; // Empty status - show button
    const statusLower = status.toLowerCase();
    
    // Show button for pending statuses (needs acknowledgment)
    return statusLower === 'pending' || 
           statusLower === 'pending - after reversal approved' || 
           statusLower === 'pending - after reversal rejected';
    
    // All acknowledged statuses return false (locked)
}

// Check if there's a pending reversal request
function hasPendingReversalRequest() {
    if (!currentAudit) {
        return false;
    }
    
    const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
    if (!reversalRequestedAt) {
        return false; // No reversal requested
    }
    
    // Check workflow state
    const workflowState = getReversalWorkflowState(currentAudit);
    
    // Pending states that allow action
    const pendingStates = [
        'pending',
        'team_lead_review',
        'cqc_review',
        'cqc_sent_back',
        'agent_re_review'
    ];
    
    if (pendingStates.includes(workflowState)) {
        return true;
    }
    
    // For agents: also show if CQC sent back (they can resubmit)
    if (isCurrentUserAgent() && (workflowState === 'cqc_sent_back' || workflowState === 'agent_re_review')) {
        return true;
    }
    
    // Fallback: check old logic
    const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
    const reversalApproved = currentAudit.reversal_approved || currentAudit.reversalApproved;
    
    // Pending if reversal was requested but not yet responded to
    if (reversalRequestedAt && !reversalRespondedAt) {
        return true;
    }
    
    // Also check if reversal_approved is null (which means pending)
    if (reversalRequestedAt && (reversalApproved === null || reversalApproved === undefined)) {
        return true;
    }
    
    return false;
}

// Check if edit button should be shown
function shouldShowEditButton() {
    // Check if audit is acknowledged - if so, lock editing for everyone
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status || '';
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        return false; // Locked - no edits allowed
    }
    
    // Auditors can edit anytime unless acknowledged
    if (isCurrentUserAuditor()) {
        return true;
    }
    
    // For Quality Analysts (non-auditors), can only edit when reversal is pending
    if (hasPendingReversalRequest() && isCurrentUserQualityAnalyst()) {
        return true;
    }
    
    return false;
}

// Check if reversal approval interface should be shown
// Shows for: Original Auditor of the audit, Admins and above, Team Leads (for team_lead_review stage only)
// Note: This function is synchronous but checks are done asynchronously in displayReversalApprovalInterface
function shouldShowReversalApprovalInterface() {
    if (!hasPendingReversalRequest()) {
        console.log('shouldShowReversalApprovalInterface: No pending reversal request');
        return false;
    }
    
    const workflowState = getReversalWorkflowState(currentAudit);
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    const userInfo = getCurrentUserInfo();
    
    console.log('shouldShowReversalApprovalInterface:', {
        workflowState,
        isOriginalAuditor,
        isAdmin,
        isTeamLead,
        userRole: userInfo?.role
    });
    
    // Only allow:
    // 1. Original auditor of the audit
    // 2. Admins and above
    if (isOriginalAuditor || isAdmin) {
        console.log('shouldShowReversalApprovalInterface: User is original auditor or admin - showing interface');
        return true;
    }
    
    // For team_lead_review state, also allow team leads (they can approve/reject before it goes to QA)
    // But they cannot process the final reversal decision
    if ((workflowState === 'team_lead_review' || workflowState === 'pending') && isTeamLead) {
        // Check if user is team supervisor (async check happens in displayReversalApprovalInterface)
        // For now, allow team leads to see the interface
        console.log('shouldShowReversalApprovalInterface: User is team lead - showing interface for team lead review');
        return true;
    }
    
    console.log('shouldShowReversalApprovalInterface: No conditions met - NOT showing interface');
    return false;
}

// Check if reversal button should be shown (hide after 48 hours from audit submission)
function checkIfReversalButtonShouldShow(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return true; // If no timestamp, show button (fallback)
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const diffMs = now - submissionDate;
    const diffHours = diffMs / (1000 * 60 * 60);
    
    // Hide after 48 hours
    return diffHours < 48;
}

// Get time remaining until 48 hours expires (in seconds)
function getTimeRemainingUntil48Hours(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return null;
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const expirationTime = new Date(submissionDate.getTime() + (48 * 60 * 60 * 1000)); // 48 hours
    const remainingMs = expirationTime - now;
    
    if (remainingMs <= 0) {
        return 0; // Already expired
    }
    
    return Math.floor(remainingMs / 1000); // Return seconds
}

// Format time remaining for display (always show seconds)
function formatTimeRemaining(seconds) {
    if (seconds <= 0) {
        return 'Expired';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}h ${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else {
        return `${secs}s`;
    }
}

// Handle closing/navigating away - check if acknowledgement is pending or comments without reversal
async function handleCloseAuditView() {
    // Check if user is the audited employee
    if (isCurrentUserAuditedEmployee() && currentAudit) {
        // Check if user has comments but hasn't submitted a reversal
        const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const hasComments = Object.keys(parameterComments).some(key => {
            const comment = parameterComments[key];
            return comment && comment.comment && comment.comment.trim();
        });
        
        // Check if reversal has been submitted (check both camelCase and snake_case)
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        const hasSubmittedReversal = !!reversalRequestedAt;
        
        // If user has comments but hasn't submitted reversal, prevent navigation
        // Only check if reversal hasn't been submitted yet
        if (hasComments && !hasSubmittedReversal) {
            // Wait for confirmation dialog to be available
            if (!window.confirmationDialog) {
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!window.confirmationDialog) {
                    alert('Warning: You have unsaved parameter comments. If you leave now, your comments will be lost. Please submit a reversal request to save them.');
                    return false; // Prevent navigation
                }
            }
            
            const result = await window.confirmationDialog.show({
                title: '⚠ Unsaved Comments',
                message: 'You have added parameter comments but haven\'t submitted a reversal request yet. If you leave now, your comments will be erased.\n\nPlease submit a reversal request to save your comments before leaving.',
                confirmText: 'Request Reversal',
                cancelText: 'Leave Anyway (Comments will be lost)'
            });
            
            if (result) {
                // User wants to submit reversal - open the reversal form
                toggleReversalForm();
                return false; // Prevent navigation
            } else {
                // User chose to leave anyway - they understand comments will be lost
                // Allow navigation but warn them one more time
                const confirmLeave = confirm('Are you sure you want to leave? Your parameter comments will be permanently erased from the database.');
                if (!confirmLeave) {
                    return false; // User changed their mind
                }
                
                // Delete comments from database before allowing navigation
                try {
                    if (currentAudit && currentTableName) {
                        await window.supabaseClient
                            .from(currentTableName)
                            .update({
                                parameter_comments: null
                            })
                            .eq('id', currentAudit.id);
                        
                        // Clear from local object
                        if (currentAudit) {
                            currentAudit.parameterComments = {};
                            currentAudit.parameter_comments = {};
                        }
                    }
                } catch (error) {
                    console.error('Error deleting comments:', error);
                    // Continue anyway - user already confirmed they want to leave
                }
                
                return true; // Allow navigation
            }
        }
        
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
        
        // Determine reversal status
        const reversalRespondedAt = currentAudit.reversalRespondedAt || currentAudit.reversal_responded_at;
        const reversalStatus = reversalRequestedAt && !reversalRespondedAt ? 'Pending' : 
                              (currentAudit.reversalApproved === true || currentAudit.reversal_approved === true) ? 'Approved' :
                              (currentAudit.reversalApproved === false || currentAudit.reversal_approved === false) ? 'Rejected' : null;
        
        // If a reversal is pending, user cannot acknowledge - allow navigation without showing modal
        if (reversalStatus === 'Pending') {
            return true; // Allow navigation
        }
        
        // If acknowledgement is pending (not acknowledged) and no reversal is pending, show the same confirmation as acknowledge button
        // Use global helper function - only show modal if status is not acknowledged (including pending statuses)
        if (!isAcknowledgedStatus(acknowledgementStatus)) {
            // Use the same confirmation dialog that appears when clicking acknowledge button
            // Create a wrapper that tracks success and shows the same confirmation
            const acknowledgeWithNavigation = async () => {
                try {
                    // Verify that current user is the audited employee
                    if (!isCurrentUserAuditedEmployee()) {
                        return false;
                    }
                    
                    // Wait for confirmation dialog to be available
                    if (!window.confirmationDialog) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.confirmationDialog) {
                            alert('Error: Confirmation dialog not available. Please refresh the page.');
                            return false;
                        }
                    }
                    
                    // Show the same confirmation dialog as the acknowledge button
                    const result = await window.confirmationDialog.show({
                        title: 'Acknowledge Audit',
                        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
                        confirmText: 'Acknowledge',
                        cancelText: 'Cancel'
                    });
                    
                    if (!result) {
                        return false; // User cancelled
                    }
                    
                    if (!currentAudit || !currentTableName) {
                        alert('Error: Audit data not available');
                        return false;
                    }
                    
                    // Record acknowledgment in the database
                    const acknowledgementTime = new Date().toISOString();
                    const { data, error } = await window.supabaseClient
                        .from(currentTableName)
                        .update({
                            acknowledgement_status: 'Acknowledged',
                            acknowledgement_status_updated_at: acknowledgementTime
                        })
                        .eq('id', currentAudit.id)
                        .select();
                    
                    if (error) throw error;
                    
                    // Show success message
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Success',
                            message: '✓ Audit acknowledged. Thank you for your confirmation.',
                            confirmText: 'OK',
                            type: 'success'
                        });
                    } else {
                        alert('✓ Audit acknowledged. Thank you for your confirmation.');
                    }
                    
                    // Update currentAudit to reflect acknowledgement
                    if (currentAudit) {
                        currentAudit.acknowledgementStatus = 'Acknowledged';
                        currentAudit.acknowledgement_status = 'Acknowledged';
                        currentAudit.acknowledgementStatusUpdatedAt = acknowledgementTime;
                        currentAudit.acknowledgement_status_updated_at = acknowledgementTime;
                    }
                    
                    return true; // Success
                    
                } catch (error) {
                    console.error('Error acknowledging audit:', error);
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to record acknowledgment. Please try again.',
                            confirmText: 'OK',
                            type: 'error'
                        });
                    } else {
                        alert('Failed to record acknowledgment. Please try again.');
                    }
                    return false;
                }
            };
            
            // Call the acknowledge function
            acknowledgementSuccessful = await acknowledgeWithNavigation();
            
            // If acknowledgement was successful, allow navigation
            // If user cancelled, prevent navigation
            return acknowledgementSuccessful;
        }
    }
    
    // If no acknowledgement pending or not the audited employee, allow navigation
    return true;
}

// Load audit on page load
document.addEventListener('DOMContentLoaded', async function() {
    try {
        // Check page access using centralized access control (basic check)
        // Resource-level check will be done after loading audit data
        if (!window.accessControl || !window.accessControl.enforcePageAccess('edit-audit.html')) {
            return; // Access denied, user will be redirected
        }
        
        // Check if user is an agent/employee - redirect to view page if so
        if (isCurrentUserAgent()) {
            // Get URL parameters to redirect to view page
            const urlParams = new URLSearchParams(window.location.search);
            const auditId = urlParams.get('id');
            const scorecardId = urlParams.get('scorecard');
            const tableName = urlParams.get('table');
            
            if (auditId && tableName) {
                // Redirect to audit-view.html with same parameters
                const viewUrl = `audit-view.html?id=${auditId}&table=${tableName}${scorecardId ? `&scorecard=${scorecardId}` : ''}`;
                window.location.href = viewUrl;
                return;
            } else {
                // If no valid parameters, redirect to home
                window.location.href = 'home.html';
                return;
            }
        }
        
        // Get current user email first
        currentUserEmail = getCurrentUserEmail();
        
        await loadAuditFromURL();
        
        // Add escape key listener - check acknowledgement before closing
        document.addEventListener('keydown', async function(event) {
            if (event.key === 'Escape') {
                event.preventDefault(); // Prevent default escape behavior
                const canNavigate = await handleCloseAuditView();
                if (canNavigate) {
                    window.location.href = 'audit-reports.html';
                }
            }
        });
        
        // Prevent browser close/refresh when user has unsaved comments
        window.addEventListener('beforeunload', function(event) {
            if (isCurrentUserAuditedEmployee() && currentAudit) {
                const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
                const hasComments = Object.keys(parameterComments).some(key => {
                    const comment = parameterComments[key];
                    return comment && comment.comment && comment.comment.trim();
                });
                
                const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                const hasSubmittedReversal = !!reversalRequestedAt;
                
                // If user has comments but hasn't submitted reversal, prevent page unload
                if (hasComments && !hasSubmittedReversal) {
                    // Modern browsers ignore custom messages, but we still need to set returnValue
                    event.preventDefault();
                    event.returnValue = 'You have unsaved parameter comments. If you leave now, your comments will be erased. Please submit a reversal request to save them.';
                    return event.returnValue;
                }
            }
        });
    } catch (error) {
        console.error('Error loading audit:', error);
        showError('Failed to load audit: ' + error.message);
    }
});

// Load audit from URL parameters
async function loadAuditFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');

    if (!auditId || !tableName) {
        showError('Invalid URL parameters. Missing audit ID or table name.');
        return;
    }

    currentTableName = tableName;

    try {
        // Wait for Supabase to initialize
        let attempts = 0;
        const maxAttempts = 50;
        while (!window.supabaseClient && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            throw new Error('Supabase client not initialized');
        }

        // Load audit data
        // Try to get the audit - if .single() fails, check if it's because no results were found
        let data, error;
        const result = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId);
        
        if (result.error) {
            error = result.error;
            data = null;
        } else if (result.data && result.data.length === 0) {
            // No results found
            error = { message: `Audit with ID "${auditId}" not found in table "${tableName}"` };
            data = null;
        } else if (result.data && result.data.length === 1) {
            // Exactly one result - success
            data = result.data[0];
            error = null;
        } else if (result.data && result.data.length > 1) {
            // Multiple results - use first one but log warning
            console.warn(`Multiple audits found with ID "${auditId}" in table "${tableName}". Using first result.`);
            data = result.data[0];
            error = null;
        } else {
            error = { message: 'Unknown error loading audit' };
            data = null;
        }

        if (error) throw error;
        if (!data) throw new Error('Audit not found');

        currentAudit = data;
        
        // Get scorecard ID from URL parameter, or try to get it from audit data or table name
        let finalScorecardId = scorecardId;
        
        // If not in URL, try to get from audit data
        if (!finalScorecardId && data.scorecard_id) {
            finalScorecardId = data.scorecard_id;
        }
        
        // If still not found, try to find scorecard by matching table name
        if (!finalScorecardId && tableName) {
            try {
                const { data: scorecards, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('id')
                    .eq('table_name', tableName)
                    .limit(1);
                
                if (!scorecardError && scorecards && scorecards.length > 0) {
                    finalScorecardId = scorecards[0].id;
                }
            } catch (err) {
                console.warn('Could not find scorecard by table name:', err);
            }
        }
        
        currentScorecardId = finalScorecardId;

        // Fetch reversal_requests and workflow_states data if reversal exists (for new structure)
        let reversalRequestData = null;
        let processedByData = null;
        let adminBypassData = false;
        
        if (data.reversal_requested_at) {
            try {
                // First get reversal_request
                const { data: reversalRequest, error: rrError } = await window.supabaseClient
                    .from('reversal_requests')
                    .select('id, final_decision_by_name, final_decision_by_email, final_decision_at, final_decision, admin_bypass, current_state_id')
                    .eq('audit_id', auditId)
                    .eq('scorecard_table_name', tableName)
                    .order('requested_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();
                
                if (!rrError && reversalRequest) {
                    reversalRequestData = reversalRequest;
                    adminBypassData = reversalRequest.admin_bypass || false;
                    
                    // Get processed_by from current workflow state
                    if (reversalRequest.current_state_id) {
                        const { data: currentState, error: wsError } = await window.supabaseClient
                            .from('reversal_workflow_states')
                            .select('entered_by_name, entered_by_email')
                            .eq('id', reversalRequest.current_state_id)
                            .eq('is_current', true)
                            .maybeSingle();
                        
                        if (!wsError && currentState) {
                            processedByData = {
                                name: currentState.entered_by_name,
                                email: currentState.entered_by_email
                            };
                        }
                    }
                }
            } catch (err) {
                console.warn('Error fetching reversal_requests data:', err);
            }
        }

        // Map snake_case to camelCase
        const audit = {
            ...data,
            id: data.id,
            submittedAt: data.submitted_at || data.audit_timestamp,
            auditTimestamp: data.submitted_at || data.audit_timestamp, // Using submitted_at for backward compatibility
            auditDuration: data.audit_duration,
            auditorEmail: data.auditor_email,
            auditorName: data.auditor_name,
            employeeName: data.employee_name,
            employeeEmail: data.employee_email,
            employeeType: data.employee_type,
            employeeDepartment: data.employee_department,
            interactionId: data.interaction_id,
            interactionDate: data.interaction_date,
            auditType: data.audit_type,
            channel: data.channel,
            quarter: data.quarter,
            week: data.week,
            countryOfEmployee: data.country_of_employee,
            clientEmail: data.client_email,
            agentPreStatus: data.agent_pre_status,
            agentPostStatus: data.agent_post_status,
            passingStatus: data.passing_status,
            validationStatus: data.validation_status,
            averageScore: data.average_score,
            criticalErrors: data.critical_errors,
            totalErrorsCount: data.total_errors_count,
            transcript: data.transcript,
            errorDescription: data.error_description,
            criticalFailError: data.critical_fail_error,
            criticalError: data.critical_error,
            significantError: data.significant_error,
            recommendations: data.recommendations,
            // Reversal tracking fields
            reversalRequestedAt: data.reversal_requested_at,
            reversalRespondedAt: data.reversal_responded_at,
            reversalStatus: data.reversal_status, // Map reversal_status
            slaInHours: data.sla_in_hours,
            reasonForReversalResponseDelay: data.response_from_auditor,
            reversalApproved: data.reversal_approved,
            withinAuditorScope: data.within_auditor_scope,
            scoreBeforeAppeal: data.score_before_appeal,
            scoreAfterAppeal: data.score_after_appeal,
            didResultInPass: data.did_result_in_pass,
            reversalType: data.reversal_type,
            reversalMetricsParameters: data.reversal_metrics_parameters,
            reversalJustificationFromAgent: data.reversal_justification_from_agent,
            reversalAttachments: data.reversal_attachments,
            reversalApprovedBy: data.reversal_approved_by,
            // reversalResolvedBy: Use final_decision_by_name from reversal_requests (new structure) with fallback to audit table (old structure)
            reversalResolvedBy: reversalRequestData?.final_decision_by_name || data.reversal_resolved_by,
            // reversalProcessedBy: Use entered_by_name from reversal_workflow_states (new structure) with fallback to audit table (old structure)
            reversalProcessedBy: processedByData?.name || data.reversal_processed_by,
            reversalProcessedByEmail: processedByData?.email || data.reversal_processed_by_email,
            // adminBypass: Use from reversal_requests (new structure) with fallback to audit table (old structure)
            adminBypass: adminBypassData !== undefined ? adminBypassData : (data.admin_bypass || false),
            // Team Lead review fields
            teamLeadApproved: data.team_lead_approved,
            team_lead_approved: data.team_lead_approved,
            teamLeadReviewedBy: data.team_lead_reviewed_by,
            team_lead_reviewed_by: data.team_lead_reviewed_by,
            teamLeadReviewedAt: data.team_lead_reviewed_at,
            team_lead_reviewed_at: data.team_lead_reviewed_at,
            // Acknowledgement tracking fields
            acknowledgementStatus: data.acknowledgement_status,
            acknowledgementStatusUpdatedAt: data.acknowledgement_status_updated_at,
            // Parameter comments
            parameterComments: data.parameter_comments || {},
            parameter_comments: data.parameter_comments || {},
            _scorecard_id: finalScorecardId,
            scorecardId: finalScorecardId,
            scorecard_id: finalScorecardId,
            _scorecard_table: tableName
        };

        // Load scorecard parameters
        let errorFields = [];
        let auditScorecard = null;

        if (finalScorecardId) {
            try {
                // Load scorecard info
                const { data: scorecardData, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('*')
                    .eq('id', finalScorecardId)
                    .single();

                if (!scorecardError && scorecardData) {
                    auditScorecard = scorecardData;
                }

                // Load parameters
                const { data: parameters, error: paramsError } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .select('*')
                    .eq('scorecard_id', finalScorecardId)
                    .eq('is_active', true)
                    .order('display_order', { ascending: true });

                if (!paramsError && parameters) {
                    errorFields = parameters.map(param => {
                        // Map error category to severity label
                        const category = param.error_category || '';
                        let severity = 'Significant'; // default
                        if (category.includes('Fail')) {
                            severity = 'Critical Fail';
                        } else if (category.includes('Critical')) {
                            severity = 'Critical';
                        } else if (category.includes('Significant')) {
                            severity = 'Significant';
                        } else if (category.includes('Major')) {
                            severity = 'Major';
                        } else if (category.includes('Minor')) {
                            severity = 'Minor';
                        }
                        
                        return {
                            key: param.field_id,
                            label: param.error_name,
                            feedback: `feedback_${param.field_id}`,
                            severity: severity,
                            field_type: param.field_type || 'counter',
                            parameter_type: param.parameter_type || 'error',
                            points: param.penalty_points || 0,
                            is_fail_all: param.is_fail_all || false,
                            error_category: param.error_category || ''
                        };
                    });
                }
            } catch (err) {
                console.error('Error loading scorecard parameters:', err);
            }
        }

        // Store errorFields globally for reversal form
        currentErrorFields = errorFields;
        
        // Store scorecard globally for score calculation
        currentAuditScorecard = auditScorecard;
        
        // Update currentAudit to the mapped version (with camelCase fields)
        currentAudit = audit;

        // Determine if editing should be disabled for auditors
        // Disable editing if:
        // 1. Audit is acknowledged, OR
        // 2. Reversal is in team_lead_review stage (for auditors, not admins/team leads)
        const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';
        const isAcknowledged = isAcknowledgedStatus(acknowledgementStatus);
        const workflowState = getReversalWorkflowState(audit);
        const isAuditor = isCurrentUserAuditor();
        const isOriginalAuditor = isCurrentUserOriginalAuditor(audit);
        const isAdmin = isCurrentUserAdmin();
        const isTeamLead = isCurrentUserTeamLead();
        const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                            (isAuditor || isOriginalAuditor) && 
                                            !isAdmin && 
                                            !isTeamLead;
        
        // For auditors: disable editing if acknowledged OR waiting for team lead review
        // Admins and team leads can always edit
        const shouldDisableEditing = (isAuditor || isOriginalAuditor) && !isAdmin && !isTeamLead && (isAcknowledged || isAuditorWaitingForTeamLead);
        const renderMode = shouldDisableEditing ? 'view' : 'edit';
        
        // Debug logging
        console.log('Audit editing mode determination:', {
            isAcknowledged,
            workflowState,
            isAuditor,
            isOriginalAuditor,
            isAdmin,
            isTeamLead,
            isAuditorWaitingForTeamLead,
            shouldDisableEditing,
            renderMode
        });

        // Render the audit
        renderAudit(audit, auditScorecard, errorFields, renderMode);

        // Hide loading indicator
        document.getElementById('loadingIndicator').style.display = 'none';

    } catch (error) {
        console.error('Error loading audit:', error);
        showError(error.message);
    }
}

// Show error message
function showError(message) {
    document.getElementById('loadingIndicator').style.display = 'none';
    document.getElementById('errorMessage').style.display = 'block';
    document.getElementById('errorText').textContent = message;
}

// Copy audit ID to clipboard
window.copyAuditId = function(auditId, element) {
    if (!auditId) return;
    
    navigator.clipboard.writeText(auditId).then(() => {
        // Visual feedback - temporarily change text
        const originalText = element.textContent;
        element.textContent = 'Copied!';
        element.style.background = 'rgba(26, 115, 62, 0.4)';
        element.style.borderColor = 'rgba(255,255,255,0.8)';
        
        // Show notification if available
        if (typeof showNotification === 'function') {
            showNotification('Audit ID copied!', 'success');
        }
        
        // Reset after 1.5 seconds
        setTimeout(() => {
            element.textContent = originalText;
            element.style.background = 'rgba(0,0,0,0.2)';
            element.style.borderColor = 'rgba(255,255,255,0.3)';
        }, 1500);
    }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = auditId;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            if (typeof showNotification === 'function') {
                showNotification('Audit ID copied!', 'success');
            }
        } catch (err) {
            if (typeof showNotification === 'function') {
                showNotification('Failed to copy Audit ID', 'error');
            }
        }
        document.body.removeChild(textArea);
    });
};

// Generate error details HTML
function generateErrorDetails(audit, errorFields, mode = 'view') {
    const isEditMode = mode === 'edit';
    // Calculate actual totals from individual error counts
    let criticalFailTotal = 0;
    let criticalTotal = 0;
    let significantTotal = 0;
    let calculatedTotalErrors = 0;
    
    errorFields.forEach(field => {
        const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
        // Only count error parameters (not achievements/bonuses) in total
        if (field.parameter_type === 'error' || !field.parameter_type) {
            calculatedTotalErrors += count;
        }
        if (count > 0) {
            if (field.severity === 'Critical Fail') {
                criticalFailTotal += count;
            } else if (field.severity === 'Critical') {
                criticalTotal += count;
            } else if (field.severity === 'Significant') {
                significantTotal += count;
            }
        }
    });
    
    // Use calculated total instead of stored total_errors_count to ensure accuracy
    const totalErrorsCount = calculatedTotalErrors;
    
    // Determine column header based on field types
    let statusColumnHeader = 'Status';
    if (errorFields.length > 0) {
        const allCounters = errorFields.every(field => field.field_type === 'counter');
        const allRadio = errorFields.every(field => field.field_type === 'radio');
        
        if (allCounters) {
            statusColumnHeader = 'Counts';
        } else if (allRadio) {
            statusColumnHeader = 'Achieved?';
        }
    }
    
    // Check if current user is the audited employee (for showing comment boxes)
    const isAuditedEmployee = isCurrentUserAuditedEmployee();
    
    // Check if reversal has been submitted (disable inputs if so)
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    const hasReversalSubmitted = !!reversalRequestedAt;
    
    // Check if audit is acknowledged - if so, lock everything (no edits, no comments)
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';
    const isAcknowledged = isAcknowledgedStatus(acknowledgementStatus);
    
    // Check if auditor is waiting for team lead review (disable parameter editing)
    const workflowState = getReversalWorkflowState(audit);
    const isAuditor = isCurrentUserAuditor();
    const isOriginalAuditor = isCurrentUserOriginalAuditor(audit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    // Note: isTeamSupervisor is async, so we'll check it separately if needed
    // Disable if it's team_lead_review and user is auditor (including original auditor) but not admin or team lead
    const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                        (isAuditor || isOriginalAuditor) && 
                                        !isAdmin && 
                                        !isTeamLead;
    
    // Load parameter comments from audit data
    const parameterComments = audit.parameterComments || audit.parameter_comments || {};
    
    // Check if any parameter has a comment (handle both single comment and comments array format)
    const hasAnyComments = errorFields.some(field => {
        const comment = parameterComments[field.key];
        if (!comment) return false;
        // Check for single comment format
        if (comment.comment && comment.comment.trim()) return true;
        // Check for comments array format
        if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
        return false;
    });
    
    // Get employee name and extract first name
    const employeeName = audit.employeeName || audit.employee_name || 'Employee';
    const firstName = employeeName.split(' ')[0] || employeeName;
    const commentColumnHeader = `${firstName}'s Comment`;
    
    // Show comments column if comments exist OR if audited employee (always show for audited employees)
    // Use a global variable to track if comment column should be shown
    if (typeof window.showCommentsColumn === 'undefined') {
        // For audited employees, always show the comment column by default
        window.showCommentsColumn = isAuditedEmployee || hasAnyComments;
    }
    const showCommentsColumn = window.showCommentsColumn;
    
    // Cache dark mode values once (outside the loop for performance)
    const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
    const root = document.documentElement;
    const dividerColor = isDarkMode ? getComputedStyle(root).getPropertyValue('--border-light').trim() : '#f3f4f6';
    const dividerOpacity = isDarkMode ? '0.5' : '1';
    
    const errorRows = errorFields.map(field => {
        const rawValue = audit[field.key];
        let displayValue = '';
        let count = 0;
        
        if (field.field_type === 'radio') {
            // For radio buttons, show YES/NO
            const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
            displayValue = isYes ? '✓ YES' : '✗ NO';
            count = isYes ? 1 : 0;
        } else {
            // For counters, show the number
            count = rawValue ? parseInt(rawValue) : 0;
            displayValue = count.toString();
        }
        
        // Removed change visibility - only show database values
        // No longer tracking unsaved changes to avoid confusion
        let hasChanged = false;
        let originalValue = null;
        let changeTooltip = '';
        
        // Handle feedback - support both old format (string) and new format (JSON array)
        const feedbackData = audit[field.feedback];
        let feedbackArray = [];
        
        if (feedbackData) {
            if (typeof feedbackData === 'string') {
                // Try to parse as JSON array, fallback to single string
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch (e) {
                    // If not valid JSON, treat as single string (backward compatibility)
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
        }
        
        // Filter out empty feedbacks
        feedbackArray = feedbackArray.filter(f => f && f.trim());
        const hasFeedback = feedbackArray.length > 0;
        const combinedFeedback = feedbackArray.join('\n\n---\n\n'); // Combine with separator
        
        // Different colors for different parameter types
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (field.parameter_type === 'error') {
            // All error severities use red shades - darker red for higher severity
            // Text color is white for all to ensure good contrast against red backgrounds
            if (field.severity === 'Critical Fail') {
                severityColor = '#ffffff'; // White text
                severityBg = '#7f1d1d'; // Darkest red background
            } else if (field.severity === 'Critical') {
                severityColor = '#ffffff'; // White text
                severityBg = '#991b1b'; // Dark red background
            } else if (field.severity === 'Significant') {
                severityColor = '#ffffff'; // White text
                severityBg = '#b91c1c'; // Medium-dark red background
            } else if (field.severity === 'Major') {
                severityColor = '#ffffff'; // White text
                severityBg = '#dc2626'; // Medium red background
            } else if (field.severity === 'Minor') {
                severityColor = '#ffffff'; // White text
                severityBg = '#ef4444'; // Light-medium red background
            } else {
                // Default for any other error severity
                severityColor = '#ffffff'; // White text
                severityBg = '#b91c1c'; // Medium-dark red background
            }
        } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Get existing comments for this parameter (can have multiple comments for multiple feedbacks)
        const existingComments = parameterComments[field.key] || {};
        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
        
        // Generate comment HTML - simple input boxes for each feedback
        let commentHtml = '';
        if (showCommentsColumn) {
            // For auditors (non-audited employees), always show comments as read-only text
            // For audited employees, show input boxes (or read-only if reversal submitted)
            if (hasFeedback) {
                // Create input boxes/display for each feedback
                commentHtml = feedbackArray.map((feedbackText, index) => {
                    const existingComment = commentsArray[index] || '';
                    const commentInputId = `comment_${field.key}_${index}`;
                    return `
                        <div style="margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">
                            ${feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                            ${!isAuditedEmployee || hasReversalSubmitted ? 
                                // For auditors or after reversal submitted, show as read-only text
                                (existingComment ? 
                                    `<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(existingComment)}</div>` :
                                    '<span style="color: #000000; font-style: italic; font-size: 0.5659rem;">-</span>'
                                ) :
                                // For audited employees - show input box if not acknowledged and not after reversal submitted
                                (isAcknowledged || hasReversalSubmitted ?
                                    `<div style="font-size: 0.5659rem; color: #000000; font-style: italic;">${existingComment ? escapeHtml(existingComment) : '-'}</div>` :
                                    `<input type="text" id="${commentInputId}" data-param-key="${field.key}" data-feedback-index="${index}" value="${escapeHtml(existingComment)}" placeholder="Enter your comment..." style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif;" onchange="saveParameterComment('${field.key}', ${index}, this.value)" onblur="saveParameterComment('${field.key}', ${index}, this.value)">`
                                )
                            }
                        </div>
                    `;
                }).join('');
            } else {
                // No feedback for this parameter - check if there are comments anyway
                // (in case comments were added but feedback was removed, or for backward compatibility)
                if (commentsArray.length > 0 && commentsArray.some(c => c && c.trim())) {
                    // Show comments even without feedback
                    commentHtml = commentsArray.map((comment, index) => {
                        if (!comment || !comment.trim()) return '';
                        return `
                            <div style="margin-bottom: ${index < commentsArray.length - 1 ? '0.6469rem' : '0'};">
                                ${commentsArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                                <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(comment)}</div>
                            </div>
                        `;
                    }).filter(html => html).join('');
                } else {
                    // No comments and no feedback - show dash
                    commentHtml = '<span style="color: #000000; font-style: italic;">-</span>';
                }
            }
        }
        
        // Generate feedback HTML - display all feedbacks (plain, no containers)
        let feedbackHtml = '-';
        if (hasFeedback) {
            // Plain display - multiple feedbacks separated by line breaks
            feedbackHtml = feedbackArray.map((feedbackText, index) => {
                const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                // Check if feedback contains HTML tags - if so, render as HTML, otherwise escape
                const trimmedFeedback = feedbackText.trim();
                const isHtml = trimmedFeedback.startsWith('<') && (trimmedFeedback.includes('</') || trimmedFeedback.endsWith('>'));
                const displayText = isHtml ? feedbackText : escapeHtml(feedbackText);
                return `${label}<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">${displayText}</div>`;
            }).join('');
        }
        
        // Build grid columns - must match header columns for proper alignment
        // Feedback column gets maximum width since it contains the most text content
        // For audited employees, always show comment column (persistent)
        const gridColumns = showCommentsColumn 
            ? '1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr' 
            : '1.5fr 0.8fr 0.8fr 0.8fr 4fr';
        
        // Highlight changed rows
        // Removed change highlighting - only show database values
        const rowBgColor = 'transparent';
        const rowBorderColor = 'transparent';
        const rowBorderWidth = '0';
        
        return `
            <div class="parameter-row" data-parameter-key="${field.key}" style="display: grid; grid-template-columns: ${gridColumns}; gap: 0.6469rem; align-items: start; padding: 0.3234rem; border-left: ${rowBorderWidth} solid ${rowBorderColor}; background: ${rowBgColor}; border-bottom: 0.0405rem solid ${dividerColor}; opacity: ${dividerOpacity}; width: 100%; min-width: 0; transition: all 0.2s ease;">
                <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden; display: flex; align-items: center; gap: 0.25rem;">
                    ${field.label}
                </div>
                <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                    ${field.points}
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${(field.parameter_type === 'achievement' || field.parameter_type === 'bonus') && field.field_type !== 'radio' ? 'ACHIEVEMENT' : field.severity}</span>
                </div>
                <div style="display: flex; justify-content: center; align-items: center; min-width: 0; gap: 0.25rem; flex-wrap: wrap;">
                    ${isEditMode ? (
                        // Lock inputs if acknowledged or if auditor is waiting for team lead review
                        (isAcknowledged || isAuditorWaitingForTeamLead) ? (
                            `<div style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: ${count > 0 ? '#ef4444' : '#1f2937'};">${field.field_type === 'radio' ? (count === 1 ? '✓ YES' : '✗ NO') : count}</div>`
                        ) : (
                            field.field_type === 'radio' ? `
                                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                                        <input type="radio" name="${field.key}" id="${field.key}_yes" value="1" ${count === 1 ? 'checked' : ''} data-penalty="${field.points}" data-category="${field.severity}" data-param-type="${field.parameter_type || 'error'}" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #10b981;">
                                        <span style="font-size: 0.4852rem; font-weight: 600; color: #10b981;">✓ YES</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                                        <input type="radio" name="${field.key}" id="${field.key}_no" value="0" ${count === 0 ? 'checked' : ''} data-penalty="${field.points}" data-category="${field.severity}" data-param-type="${field.parameter_type || 'error'}" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #ef4444;">
                                        <span style="font-size: 0.4852rem; font-weight: 600; color: #ef4444;">✗ NO</span>
                                    </label>
                                </div>
                            ` : `
                                <div style="display: flex; align-items: center; gap: 0.2425rem;">
                                    <button type="button" class="counter-btn" data-action="decrement" data-target="${field.key}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #000000; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">−</button>
                                    <span id="${field.key}_display" style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: ${count > 0 ? '#ef4444' : '#1f2937'}; min-width: 0.8086rem; text-align: center;">${count}</span>
                                    <button type="button" class="counter-btn" data-action="increment" data-target="${field.key}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #000000; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">+</button>
                                    <input type="number" id="${field.key}" name="${field.key}" min="0" max="10" value="${count}" readonly data-penalty="${field.points}" data-category="${field.severity}" data-field-type="${field.field_type || 'counter'}" data-param-type="${field.parameter_type || 'error'}" style="display: none;">
                                </div>
                            `
                        )
                    ) : (
                        `<div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>`
                    )}
                </div>
                <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                    ${isEditMode ? `
                        <div id="feedback_container_${field.key}" style="display: flex; flex-direction: column; gap: 0.3234rem; min-width: 0; width: 100%; word-wrap: break-word; overflow-wrap: break-word;">
                            <!-- Feedback boxes will be dynamically added here based on error count -->
                        </div>
                    ` : feedbackHtml}
                </div>
                ${showCommentsColumn ? `
                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                        ${commentHtml || '<span style="color: #000000; font-style: italic;">-</span>'}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    return `
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    Error Details
                </h3>
                <div style="display: flex; gap: 0.2425rem;">
                    <span id="errorDetailsCriticalFailTotal" style="background: #dc2626; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical Fail: ${criticalFailTotal}</span>
                    <span id="errorDetailsCriticalTotal" style="background: #f59e0b; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical: ${criticalTotal}</span>
                    <span id="errorDetailsSignificantTotal" style="background: #3b82f6; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Significant: ${significantTotal}</span>
                </div>
            </div>
            
            <div style="background: var(--background-white); border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                <div style="background-color: var(--background-white); padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid var(--border-light);">
                    <div style="display: grid; grid-template-columns: ${showCommentsColumn ? '1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr' : '1.5fr 0.8fr 0.8fr 0.8fr 4fr'}; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                        <div style="min-width: 0;">Error Type</div>
                        <div style="text-align: center; min-width: 0;">Points</div>
                        <div style="text-align: center; min-width: 0;">Severity</div>
                        <div style="text-align: center; min-width: 0;">${statusColumnHeader}</div>
                        <div style="min-width: 0;">Feedback</div>
                        ${showCommentsColumn ? 
                            `<div style="min-width: 0;">${escapeHtml(commentColumnHeader)}</div>` : 
                            ''
                        }
                    </div>
                </div>
                <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                    ${errorRows}
                </div>
                </div>
            </div>
            
        <!-- Avg Score & Passing Status -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                    <div id="averageScoreDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.averageScore || '0'}%</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                    <div id="passingStatusDisplay" style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.passingStatus || 'N/A'}</div>
                </div>
            </div>
        </div>

        <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                    <div id="totalErrorsCountDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${totalErrorsCount}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                    <div id="criticalFailTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalFailTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                    <div id="criticalTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #000000; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                    <div id="significantTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${significantTotal}</div>
                </div>
            </div>
        </div>
    `;
}

// Populate edit form fields with audit data
async function populateEditFormFields(audit) {
    // Populate header fields
    const employeeNameSelect = document.getElementById('employeeName');
    if (employeeNameSelect) {
        // Load employees first if needed
        if (employeeNameSelect.options.length <= 1) {
            await loadEmployeesForDropdown(employeeNameSelect, audit.employeeEmail || audit.employee_email);
        }
        
        const employeeEmail = audit.employeeEmail || audit.employee_email || '';
        const employeeName = audit.employeeName || audit.employee_name || '';
        const normalizedEmail = employeeEmail.toLowerCase().trim();
        
        // Try to find matching option by email (dataset.email or value)
        let matchingOption = null;
        const options = Array.from(employeeNameSelect.options);
        for (const option of options) {
            const optionEmail = (option.dataset.email || option.value || '').toLowerCase().trim();
            if (optionEmail === normalizedEmail) {
                matchingOption = option;
                break;
            }
        }
        
        if (matchingOption) {
            employeeNameSelect.value = matchingOption.value;
            // Trigger change event to populate other fields
            employeeNameSelect.dispatchEvent(new Event('change', { bubbles: true }));
        } else if (employeeName && employeeEmail) {
            // If no match, add the option and select it
            const newOption = document.createElement('option');
            newOption.value = employeeEmail;
            newOption.text = employeeName;
            newOption.dataset.email = employeeEmail;
            employeeNameSelect.appendChild(newOption);
            employeeNameSelect.value = employeeEmail;
        }
    }
    
    const employeeEmailInput = document.getElementById('employeeEmail');
    if (employeeEmailInput) {
        employeeEmailInput.value = audit.employeeEmail || audit.employee_email || '';
    }
    
    const employeeTypeInput = document.getElementById('employeeType');
    if (employeeTypeInput) {
        employeeTypeInput.value = audit.employeeType || audit.employee_type || '';
    }
    
    const employeeDepartmentInput = document.getElementById('employeeDepartment');
    if (employeeDepartmentInput) {
        employeeDepartmentInput.value = audit.employeeDepartment || audit.employee_department || '';
    }
    
    const countryOfEmployeeSelect = document.getElementById('countryOfEmployee');
    if (countryOfEmployeeSelect) {
        const country = audit.countryOfEmployee || audit.country_of_employee || '';
        countryOfEmployeeSelect.value = country;
    }
    
    const auditorNameInput = document.getElementById('auditorName');
    if (auditorNameInput) {
        auditorNameInput.value = audit.auditorName || audit.auditor_name || '';
    }
    
    // Populate transcript section fields
    const interactionIdInput = document.getElementById('interactionId');
    if (interactionIdInput) {
        interactionIdInput.value = audit.interactionId || audit.interaction_id || '';
    }
    
    const interactionDateInput = document.getElementById('interactionDate');
    if (interactionDateInput) {
        const interactionDate = audit.interactionDate || audit.interaction_date || '';
        if (interactionDate) {
            // Convert date to YYYY-MM-DD format for date input
            const date = new Date(interactionDate);
            if (!isNaN(date.getTime())) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                interactionDateInput.value = `${year}-${month}-${day}`;
            }
        }
    }
    
    const clientEmailInput = document.getElementById('clientEmail');
    if (clientEmailInput) {
        clientEmailInput.value = audit.clientEmail || audit.client_email || '';
    }
    
    const clientNameInput = document.getElementById('clientName');
    if (clientNameInput) {
        // Client name will be populated when conversation is loaded from Intercom
        clientNameInput.value = '';
    }
    
    const transcriptTextarea = document.getElementById('transcript');
    if (transcriptTextarea) {
        transcriptTextarea.value = audit.transcript || audit.transcript_text || '';
    }
    
    // Populate channel and audit type in metadata cards (if they exist as form fields)
    // Note: These might be read-only in the template, but we'll populate if they exist
    const channelInput = document.getElementById('channel');
    if (channelInput) {
        channelInput.value = audit.channel || '';
    }
    
    const auditTypeInput = document.getElementById('auditType');
    if (auditTypeInput) {
        auditTypeInput.value = audit.auditType || audit.audit_type || 'Routine Audit (Recorded)';
    }
    
    // Recommendations will be populated by initializeRecommendationsEditor
    // No need to populate textarea here since we're using Quill
}

// Helper function to copy conversation ID
window.copyConversationId = function() {
    const interactionId = document.getElementById('interactionId');
    if (interactionId && interactionId.value) {
        navigator.clipboard.writeText(interactionId.value).then(() => {
            showNotification('Conversation ID copied to clipboard!', 'success');
        }).catch(() => {
            showNotification('Failed to copy Conversation ID', 'error');
        });
    } else {
        showNotification('No Conversation ID available', 'error');
    }
};

// Helper function to copy client email
window.copyClientEmail = function() {
    const clientEmail = document.getElementById('clientEmail');
    if (clientEmail && clientEmail.value) {
        navigator.clipboard.writeText(clientEmail.value).then(() => {
            showNotification('Client email copied to clipboard!', 'success');
        }).catch(() => {
            showNotification('Failed to copy client email', 'error');
        });
    } else {
        showNotification('No client email available', 'error');
    }
};

// Load employees for dropdown
async function loadEmployeesForDropdown(selectElement, currentEmployeeEmail) {
    try {
        const { data: users, error } = await window.supabaseClient
            .from('users')
            .select('email, name, role, department, designation, country')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        // Clear existing options except the first one (placeholder)
        while (selectElement.options.length > 1) {
            selectElement.remove(1);
        }
        
        // Add employee options
        const normalizedCurrentEmail = (currentEmployeeEmail || '').toLowerCase().trim();
        (users || []).forEach(user => {
            // Only show employees (not auditors)
            if (user.role === 'Employee') {
                const option = document.createElement('option');
                option.value = user.email;
                option.text = user.name || user.email;
                option.dataset.email = user.email;
                option.dataset.role = user.role || '';
                option.dataset.department = user.department || '';
                option.dataset.designation = user.designation || '';
                option.dataset.country = user.country || '';
                
                // Select current employee if matches
                if (user.email && user.email.toLowerCase().trim() === normalizedCurrentEmail) {
                    option.selected = true;
                }
                
                selectElement.appendChild(option);
            }
        });
        
        // Attach change event listener to auto-populate fields when employee is selected
        selectElement.removeEventListener('change', handleEmployeeSelectionChange);
        selectElement.addEventListener('change', handleEmployeeSelectionChange);
    } catch (error) {
        console.error('Error loading employees:', error);
    }
}

// Handle employee selection change to auto-populate fields
function handleEmployeeSelectionChange() {
    const employeeSelect = this;
    const selectedOption = employeeSelect.options[employeeSelect.selectedIndex];
    
    if (selectedOption && selectedOption.value) {
        const employeeEmailInput = document.getElementById('employeeEmail');
        const employeeTypeInput = document.getElementById('employeeType');
        const employeeDepartmentInput = document.getElementById('employeeDepartment');
        const countryOfEmployeeSelect = document.getElementById('countryOfEmployee');
        
        // Auto-populate email
        const email = selectedOption.dataset.email || selectedOption.value;
        if (employeeEmailInput) {
            employeeEmailInput.value = email;
        }
        
        // Auto-populate employee type from designation
        const designation = selectedOption.dataset.designation || '';
        if (employeeTypeInput && designation) {
            employeeTypeInput.value = designation;
        }
        
        // Auto-populate department
        const department = selectedOption.dataset.department || '';
        if (employeeDepartmentInput && department) {
            employeeDepartmentInput.value = department;
        }
        
        // Auto-populate country
        const country = selectedOption.dataset.country || '';
        if (countryOfEmployeeSelect && country) {
            countryOfEmployeeSelect.value = country;
        }
    }
}

// Render audit HTML
function renderAudit(audit, auditScorecard, errorFields, mode = 'view') {
    // Helper functions are now in audit-template.js
    // Use them from the global scope (formatDate, getCountryFlag, escapeHtml)

    const isEditMode = mode === 'edit';

    // Check for passing status (handle both "Passing" and "Passed", but exclude "Not Passing")
    const passingStatus = audit.passingStatus ? audit.passingStatus.toLowerCase() : '';
    const isPassing = passingStatus && passingStatus.includes('pass') && !passingStatus.includes('not');

    const errorDetailsHtml = errorFields.length > 0 ? generateErrorDetails(audit, errorFields, mode) : '';

    // Determine header gradient based on passing status (handle both old and new values)
    const normalizedPassingStatus = passingStatus && passingStatus.includes('not') ? 'Not Passed' : 'Passed';
    const headerGradient = normalizedPassingStatus === 'Not Passed' 
        ? 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)' 
        : 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    
    // Use formatDate and getCountryFlag from audit-template.js
    const formatDate = window.formatDate || function(dateString, includeTime) {
        if (!dateString) return 'N/A';
        const date = new Date(dateString);
        const day = date.getDate();
        const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const month = months[date.getMonth()];
        const year = date.getFullYear();
        if (includeTime) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            return `${day} ${month} ${year}, ${hours}:${minutes} ${ampm}`;
        }
        return `${day} ${month} ${year}`;
    };
    const getCountryFlag = window.getCountryFlag || function(countryName) {
        if (!countryName) return '🏳️';
        const country = countryName.toLowerCase();
        const flagMap = {
            'bangladesh': '🇧🇩', 'india': '🇮🇳', 'pakistan': '🇵🇰', 'philippines': '🇵🇭',
            'indonesia': '🇮🇩', 'sri lanka': '🇱🇰', 'nepal': '🇳🇵', 'thailand': '🇹🇭',
            'vietnam': '🇻🇳', 'malaysia': '🇲🇾', 'singapore': '🇸🇬', 'usa': '🇺🇸',
            'united states': '🇺🇸', 'uk': '🇬🇧', 'united kingdom': '🇬🇧', 'canada': '🇨🇦',
            'australia': '🇦🇺', 'new zealand': '🇳🇿', 'south africa': '🇿🇦', 'egypt': '🇪🇬',
            'kenya': '🇰🇪', 'nigeria': '🇳🇬', 'ghana': '🇬🇭'
        };
        return flagMap[country] || '🏳️';
    };
    const escapeHtml = window.escapeHtml || function(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    };

    // Build interaction ID HTML (clickable link if available)
    // Get Intercom app ID from config (generated from environment variables)
    const INTERCOM_APP_ID = window.intercomConfig?.appId || '';
    let interactionIdHtml;
    if (audit.interactionId) {
        const interactionId = audit.interactionId;
        const intercomUrl = `https://app.intercom.com/a/inbox/aphmhtyj/inbox/conversation/${interactionId}?view`;
        interactionIdHtml = '<a href="' + escapeHtml(intercomUrl) + '" target="_blank" rel="noopener noreferrer" style="font-size: 0.4852rem; color: #1A733E; font-family: \'Poppins\', sans-serif; font-weight: 600; text-decoration: underline; cursor: pointer; transition: color 0.2s ease;" onmouseover="this.style.color=\'#2d9a5a\'" onmouseout="this.style.color=\'#1A733E\'">' + escapeHtml(interactionId) + '</a>';
    } else {
        interactionIdHtml = '<span style="font-size: 0.4852rem; color: #1f2937; font-family: \'Poppins\', sans-serif; font-weight: 600;">N/A</span>';
    }

    // Generate recommendations HTML
    // In edit mode, show editable Quill editor; otherwise show read-only div
    const recommendationsHtml = isEditMode
        ? `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><div class="quill-editor-container" style="margin-top: 0.3234rem;"><div id="quill_recommendations"></div></div></div>`
        : (audit.recommendations 
            ? `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><div style="background: white; padding: 0.5659rem; border-radius: 0.2425rem; border: 0.0304rem solid #e5e7eb; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif;">${audit.recommendations}</div></div>`
            : '');

    // Check if current user is the audited employee (for showing acknowledge button)
    const showAcknowledgeButton = isCurrentUserAuditedEmployee();
    
    // Check if edit button should be shown (only for Quality Analysts when reversal is pending)
    const showEditButton = shouldShowEditButton();
    
    // Check if reversal button should be shown (hide after 48 hours from audit submission)
    const auditSubmissionTime = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
    const showReversalButton = checkIfReversalButtonShouldShow(auditSubmissionTime);
    
    // Get reversal and acknowledgement status for footer styling
    // Note: reversal_status column doesn't exist - status is determined by reversal_approved
    const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
    const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
    const reversalApproved = audit.reversal_approved || audit.reversalApproved;
    // Determine status: null/undefined = pending, 'true' = approved, 'false' = rejected
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';

    // Generate action buttons HTML
    // Only show acknowledge/reversal buttons if current user is the audited employee
    let employeeButtonsHtml = '';
    if (showAcknowledgeButton) {
        // Check if reversal is pending (disables acknowledge button and reversal button)
        const isReversalPending = reversalStatus === 'Pending';
        
        // Generate reversal button HTML (always show if within 48 hours, regardless of acknowledgement status)
        // But disable if reversal is already pending
        let reversalButtonHtml = '';
        if (showReversalButton) {
            const reversalDisabled = isReversalPending;
            reversalButtonHtml = `
                <button id="reversalBtn" onclick="toggleReversalForm()" ${reversalDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: ${acknowledgementStatus === 'Acknowledged' ? '0.2425rem' : '0 0.2425rem 0.2425rem 0'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${reversalDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${reversalDisabled ? '0.5' : '1'}; ${acknowledgementStatus !== 'Acknowledged' ? 'border-left: 0.0304rem solid rgba(255,255,255,0.3);' : ''}">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        Request Reversal
                    </button>
            `;
        }
        
        // Show acknowledge button based on status (simplified)
        const shouldShowAcknowledgeButton = shouldShowAcknowledgeButtonForStatus(acknowledgementStatus);
        
        if (shouldShowAcknowledgeButton) {
            // Disable acknowledge button if reversal is pending
            const acknowledgeDisabled = isReversalPending;
            employeeButtonsHtml = `
                <!-- Split button for Acknowledge/Reversal -->
                <div style="position: relative; display: inline-flex;">
                    <button id="acknowledgeBtn" onclick="acknowledgeAudit()" ${acknowledgeDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: ${reversalButtonHtml ? '0.2425rem 0 0 0.2425rem' : '0.2425rem'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${acknowledgeDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${acknowledgeDisabled ? '0.5' : '1'};">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Acknowledge
                    </button>
                    ${reversalButtonHtml}
                </div>
            `;
        } else {
            // If acknowledged with new status (after reversal), only show reversal button (if within 48 hours)
            if (reversalButtonHtml) {
                employeeButtonsHtml = reversalButtonHtml;
            }
        }
    }
    
    // Generate edit button HTML (only if pending reversal and user is Quality Analyst)
    // BUT: Don't show edit button in edit-audit.html (we're already in edit mode)
    let editButtonHtml = '';
    if (showEditButton && mode !== 'edit') {
        editButtonHtml = `
                <button id="editAuditBtn" onclick="editCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #f59e0b; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Edit Audit
                </button>
        `;
    }
    
    // Generate delete button HTML (only if current user is the auditor AND no reversal has been submitted)
    let deleteButtonHtml = '';
    const hasReversalSubmitted = !!reversalRequestedAt;
    const showDeleteButton = isCurrentUserAuditor() && !hasReversalSubmitted;
    if (showDeleteButton) {
        deleteButtonHtml = `
                <button id="deleteAuditBtn" onclick="deleteCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Delete Audit
                </button>
        `;
    }
    
    // Generate save button HTML for edit mode
    let saveButtonHtml = '';
    if (mode === 'edit') {
        saveButtonHtml = `
                <button id="saveAuditBtn" onclick="saveAuditChanges()" style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Changes
                </button>
        `;
    }
    
    // Determine footer background color based on acknowledgement status
    // Green: Acknowledged (including new statuses) | Gray: Default (not acknowledged or pending)
    let footerBackgroundColor = '#f9fafb'; // Default gray
    let footerTextColor = '#000000'; // Default black text
    
    // Check if status is acknowledged (including new statuses) - show green footer
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Also show green footer for pending statuses after reversal (they need acknowledgment)
    const statusLower = acknowledgementStatus.toLowerCase();
    if ((statusLower === 'pending - after reversal approved' || statusLower === 'pending - after reversal rejected')) {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Generate timer HTML for footer (if reversal button is visible and within 48 hours)
    // Don't show timer if reversal is already pending
    let timerHtml = '';
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        if (timeRemaining && timeRemaining > 0) {
            // Check if time is running low (less than 2 hours remaining)
            const isLowTime = timeRemaining < 7200; // 2 hours in seconds
            // Use white for green footer, default gray text for gray footer
            const statusLowerTimer = acknowledgementStatus.toLowerCase();
            const shouldShowGreenFooter = isAcknowledgedStatus(acknowledgementStatus) || 
                                         statusLowerTimer === 'pending - after reversal approved' || 
                                         statusLowerTimer === 'pending - after reversal rejected';
            const timerTextColor = shouldShowGreenFooter ? 'white' : footerTextColor;
            timerHtml = `
                <div id="reversalTimer" style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; color: ${timerTextColor}; ${isLowTime ? 'animation: pulse-attention 2s ease-in-out infinite;' : ''}">
                    <svg id="reversalTimerIcon" style="width: 0.75rem; height: 0.75rem; opacity: 0.6; ${isLowTime ? 'animation: spin-slow 2s linear infinite;' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span id="reversalTimerText">Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${isLowTime ? '#ef4444' : timerTextColor}; ${isLowTime ? 'animation: flash-text 1s ease-in-out infinite;' : ''}">${formatTimeRemaining(timeRemaining)}</span></span>
            </div>
            `;
        }
    }
    
    // Determine if footer should show green (acknowledged or pending after reversal)
    const statusLowerFooter = acknowledgementStatus.toLowerCase();
    const shouldShowFooterStatus = isAcknowledgedStatus(acknowledgementStatus) || 
                                   statusLowerFooter === 'pending - after reversal approved' || 
                                   statusLowerFooter === 'pending - after reversal rejected';
    
    // Generate acknowledgement status HTML for footer (shown in body of footer)
    let acknowledgementStatusHtml = '';
    if (shouldShowFooterStatus) {
        // Format acknowledgement timestamp
        let timestampText = '';
        const ackTimestamp = audit.acknowledgementStatusUpdatedAt || audit.acknowledgement_status_updated_at;
        if (ackTimestamp) {
            const ackDate = new Date(ackTimestamp);
            const now = new Date();
            const diffMs = now - ackDate;
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffHours < 1) {
                const diffMins = Math.floor(diffMs / (1000 * 60));
                timestampText = diffMins <= 1 ? 'just now' : `${diffMins} minutes ago`;
            } else if (diffHours < 24) {
                timestampText = diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
            } else if (diffDays === 1) {
                timestampText = '1 day ago';
            } else {
                timestampText = formatDate(ackTimestamp, true);
            }
        }
        
        // Determine display text for acknowledgement status
        let displayText = 'Acknowledged';
        const statusLower = acknowledgementStatus.toLowerCase();
        if (statusLower === 'acknowledged - after reversal approved') {
            displayText = 'Acknowledged - After Reversal Approved';
        } else if (statusLower === 'acknowledged - after reversal rejected') {
            displayText = 'Acknowledged - After Reversal Rejected';
        } else if (statusLower === 'pending - after reversal approved') {
            displayText = 'Pending - After Reversal Approved';
        } else if (statusLower === 'pending - after reversal rejected') {
            displayText = 'Pending - After Reversal Rejected';
        }
        
        // Use checkmark icon for acknowledged, clock icon for pending
        const isAcknowledged = isAcknowledgedStatus(acknowledgementStatus);
        const iconSvg = isAcknowledged 
            ? `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`
            : `<circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/>`;
        
        acknowledgementStatusHtml = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background-color: rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                    <svg style="width: 0.875rem; height: 0.875rem;" viewBox="0 0 24 24" fill="white">
                        ${iconSvg}
                    </svg>
                </div>
                <span style="font-size: 0.75rem; font-weight: 600; color: white; font-family: 'Poppins', sans-serif;">${displayText}</span>
                <span style="font-size: 0.6562rem; color: rgba(255, 255, 255, 0.9); font-family: 'Poppins', sans-serif;">${timestampText}</span>
            </div>
        `;
    }
    
    const actionButtonsHtml = `
        <div id="footerBar" class="no-print" style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid ${shouldShowFooterStatus ? 'rgba(255,255,255,0.2)' : '#e5e7eb'}; background-color: ${footerBackgroundColor}; color: ${footerTextColor};">
            <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1;">
                ${acknowledgementStatusHtml}
            </div>
            <div style="display: flex; align-items: center; gap: 0.4852rem; margin-left: auto;">
                ${timerHtml}
                ${employeeButtonsHtml}
                ${editButtonHtml}
                ${deleteButtonHtml}
                ${saveButtonHtml}
            </div>
        </div>
    `;
    
    // Store mode for later use
    window.currentEditMode = mode;

    // Generate header actions HTML
    const headerActionsHtml = `
        <button onclick="handleCloseButtonClick()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">×</button>
    `;

    // Check if user is quality analyst or above (should see auditor name)
    const shouldShowAuditorName = isCurrentUserQualityAnalyst();
    
    // Use shared template to generate HTML (errorDetailsHtml already generated above)
    const html = window.generateAuditFormHTML({
        audit: audit,
        mode: mode, // Use the mode parameter passed to renderAudit function
        headerTitle: 'Edit Audit',
        headerGradient: headerGradient,
        headerActions: headerActionsHtml,
        interactionIdHtml: interactionIdHtml,
        errorDetailsHtml: errorDetailsHtml,
        recommendationsHtml: recommendationsHtml,
        actionButtonsHtml: actionButtonsHtml,
        showAuditorName: shouldShowAuditorName
    });

    const auditContentDiv = document.getElementById('auditContent');

    // Preserve reversal form container state before re-rendering
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    const wasFormVisible = reversalFormContainer && reversalFormContainer.style.display !== 'none';
    
    // Temporarily remove form container from DOM to preserve it during innerHTML replacement
    let formContainerParent = null;
    let formContainerNextSibling = null;
    if (reversalFormContainer && reversalFormContainer.parentElement) {
        formContainerParent = reversalFormContainer.parentElement;
        formContainerNextSibling = reversalFormContainer.nextSibling;
        reversalFormContainer.remove();
    }
    
    auditContentDiv.innerHTML = html;

    // Show background score in header
    const backgroundScoreContainer = document.getElementById('headerBackgroundScore');
    const headerScoreValue = document.getElementById('headerScoreValue');
    if (backgroundScoreContainer && headerScoreValue && auditScorecard) {
        // Get average score from audit
        const averageScore = audit.averageScore || audit.average_score || 0;
        
        // Determine score text color based on passing status
        const passingStatus = audit.passingStatus || audit.passing_status || '';
        const passingStatusLower = passingStatus.toLowerCase();
        const isPassingForScore = passingStatusLower.includes('pass') && !passingStatusLower.includes('not');
        const scoreTextColor = isPassingForScore 
            ? 'rgba(10, 50, 30, 0.4)' // Darker green for passing
            : 'rgba(100, 10, 10, 0.4)'; // Darker red for not passing
        
        // Set the score value
        headerScoreValue.textContent = Math.round(averageScore);
        
        // Update background score color
        const scoreSpan = backgroundScoreContainer.querySelector('span');
        if (scoreSpan) {
            scoreSpan.style.color = scoreTextColor;
        }
        
        // Display the background score
        backgroundScoreContainer.style.display = 'flex';
    }

    // Populate form fields in edit mode (with delay to ensure DOM is ready)
    // Also populate all fields in view mode so they display correctly
    if (mode === 'edit' || mode === 'view') {
        setTimeout(() => {
            // Populate all form fields in both edit and view modes
            populateEditFormFields(audit);
            
            // Only initialize editors and update scores in edit mode
            if (mode === 'edit') {
                
                // Initialize Quill editors for all feedback fields
                if (errorFields && errorFields.length > 0) {
                    errorFields.forEach(field => {
                        const fieldType = field.field_type || 'counter';
                        const paramType = field.parameter_type || 'error';
                        updateFeedbackBoxesForParameter(field.key, fieldType, paramType);
                    });
                }
                
                // Initialize Quill editor for recommendations field
                initializeRecommendationsEditor(audit);
                
                // Update score display after form is populated
                // This will recalculate based on current form values
                updateAverageScoreDisplay();
                
                // Also update the currentAudit object with the calculated score
                // so it matches what's displayed
                const calculatedScore = calculateNewScore();
                if (currentAudit) {
                    currentAudit.averageScore = calculatedScore;
                    currentAudit.average_score = calculatedScore;
                }
                
                // Update parameter change highlighting
                if (shouldShowReversalApprovalInterface()) {
                    setTimeout(() => {
                        updateParameterChangeHighlighting();
                    }, 150);
                }
            }
        }, 100);
    }

    // Re-insert reversal form container after rendering
    if (reversalFormContainer && auditContentDiv) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection && buttonsSection.parentElement) {
            buttonsSection.parentElement.insertBefore(reversalFormContainer, buttonsSection);
        } else {
            auditContentDiv.appendChild(reversalFormContainer);
        }
        
        // Restore visibility state
        if (wasFormVisible) {
            reversalFormContainer.style.display = 'block';
        } else {
            reversalFormContainer.style.display = 'none';
        }
    }

    // Handle reversal status UI updates
    handleReversalStatusUI(audit);
    
    // Display reversal approval interface if reversal is pending
    // The "Review & Process Reversal" section now contains all information
    // Show it to everyone (agents see read-only version, team leads/auditors/admins see editable version)
    const workflowState = getReversalWorkflowState(audit);
    const isAgent = isCurrentUserAuditedEmployee();
    
    if (reversalStatus === 'Pending' || workflowState === 'team_lead_review' || workflowState === 'qa_review') {
        // Check if there's a reversal request first
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        if (reversalRequestedAt) {
            // Show interface for everyone:
            // - Agents: read-only view of their submitted reversal
            // - Team leads/auditors/admins: editable interface for processing
            if (isAgent || workflowState === 'team_lead_review' || shouldShowReversalApprovalInterface()) {
                setTimeout(() => {
                    displayReversalApprovalInterface(audit);
                }, 200);
            }
        }
    }
    
    // Start timer countdown if reversal button is visible and reversal is not pending
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        startReversalTimer(auditSubmissionTime);
    }

    // Make splitter draggable
    initializeSplitter();
    
    // Auto-fetch conversation from Intercom if interaction ID exists
    // Show chat view by default (will show loading, then Intercom messages or fallback to text)
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
    
    if (transcriptChatView && transcriptTextView) {
        transcriptChatView.style.display = 'flex';
        transcriptTextView.style.display = 'none';
        if (toggleTranscriptViewBtn) {
            toggleTranscriptViewBtn.textContent = 'Text View';
            toggleTranscriptViewBtn.title = 'Switch to text view';
        }
        isChatViewActive = true;
    }
    
    if (audit.interactionId || audit.interaction_id) {
        const interactionId = audit.interactionId || audit.interaction_id;
        // Show loading state immediately
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        if (chatMessagesContainer) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #000000;">
                    <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                </div>
            `;
        }
        // Delay slightly to ensure DOM is ready, then fetch
        setTimeout(() => {
            loadConversationFromIntercom(interactionId);
        }, 100);
    } else {
        // No interaction ID - try to parse database transcript and show in chat view
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                if (toggleTranscriptViewBtn) {
                    toggleTranscriptViewBtn.textContent = 'Text View';
                    toggleTranscriptViewBtn.title = 'Switch to text view';
                }
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - show text view
        if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'none';
            transcriptTextView.style.display = 'flex';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Chat View';
                toggleTranscriptViewBtn.title = 'Switch to chat view';
            }
            isChatViewActive = false;
            }
        }
    }
}

// Handle reversal status UI updates
function handleReversalStatusUI(audit) {
    const acknowledgeBtn = document.getElementById('acknowledgeBtn');
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    
    // Check if acknowledge button should be visible (only for audited employee)
    if (acknowledgeBtn && !isCurrentUserAuditedEmployee()) {
        // Hide acknowledge button if user is not the audited employee
        acknowledgeBtn.style.display = 'none';
        // Also hide the reversal button if both buttons are in a split button container
        const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
        if (reversalBtn) {
            reversalBtn.style.display = 'none';
        }
    }
    
    // Get the reversal status from audit data
    // Note: reversal_status column doesn't exist - derive from reversal_approved
    const reversalRequestedAt = currentAudit?.reversal_requested_at || currentAudit?.reversalRequestedAt;
    const reversalRespondedAt = currentAudit?.reversal_responded_at || currentAudit?.reversalRespondedAt;
    const reversalApproved = currentAudit?.reversal_approved || currentAudit?.reversalApproved;
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    // Get the acknowledgement status from audit data
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status;
    
    // Ensure button is enabled by default (will be disabled if needed below)
    if (acknowledgeBtn) {
        acknowledgeBtn.disabled = false;
        acknowledgeBtn.style.opacity = '1';
        acknowledgeBtn.style.cursor = 'pointer';
    }
    
    // Check if acknowledge button should be shown based on status
    const shouldShow = shouldShowAcknowledgeButtonForStatus(acknowledgementStatus);
    
    // If button should not be shown, disable it
    if (!shouldShow && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    // If reversal is pending, disable acknowledge button (can't acknowledge while reversal is pending)
    if (reversalStatus === 'Pending' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    if (reversalStatus) {
        // Create status banner
        const statusBanner = document.createElement('div');
        statusBanner.style.cssText = `
            padding: 0.5625rem 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.2812rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.6562rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        `;
        
        if (reversalStatus === 'Pending') {
            // Don't show banner for pending reversals - the "Review & Process Reversal" section has more specific information
            // Just disable the reversal button (user can't submit another reversal while one is pending)
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = true;
                reversalBtn.style.opacity = '0.5';
                reversalBtn.style.cursor = 'not-allowed';
            }
            // Don't create/show the status banner for pending status - return early
            return;
        } else if (reversalStatus === 'Approved') {
            statusBanner.style.background = '#d1fae5';
            statusBanner.style.color = '#065f46';
            statusBanner.style.border = '0.0352rem solid #10b981';
            
            // Get auditor's response if available
            const auditorResponse = currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '';
            const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee() || isCurrentUserAuditor()) && auditorResponse && auditorResponse.trim();
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <div style="flex: 1;">
                    <div>✓ Reversal request has been approved. Score updated to ${currentAudit?.score_after_appeal || 'N/A'}%. Please review the updated audit and acknowledge or submit a new reversal if needed.</div>
                    ${shouldShowResponse ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #10b981;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">Response From Auditor:</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(auditorResponse)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            // After reversal is processed, enable acknowledge button if status requires it
            // Show acknowledge button for pending statuses or simple "Acknowledged" if reversal was processed
            if (acknowledgeBtn && shouldShowAcknowledgeButtonForStatus(acknowledgementStatus, true)) {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Rejected') {
            statusBanner.style.background = '#fee2e2';
            statusBanner.style.color = '#991b1b';
            statusBanner.style.border = '0.0352rem solid #ef4444';
            
            // Get auditor's response if available
            const auditorResponse = currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '';
            const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee() || isCurrentUserAuditor()) && auditorResponse && auditorResponse.trim();
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <div style="flex: 1;">
                    <div>Reversal request has been rejected. Please review the audit and acknowledge or submit a new reversal if needed.</div>
                    ${shouldShowResponse ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #ef4444;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">Response From Auditor:</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(auditorResponse)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            // After reversal is processed, enable acknowledge button if status requires it
            // Show acknowledge button for pending statuses or simple "Acknowledged" if reversal was processed
            if (acknowledgeBtn && shouldShowAcknowledgeButtonForStatus(acknowledgementStatus, true)) {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Acknowledged') {
            statusBanner.style.background = '#dbeafe';
            statusBanner.style.color = '#1e40af';
            statusBanner.style.border = '0.0352rem solid #3b82f6';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <span>Audit has been acknowledged by the employee.</span>
            `;
            // Hide the button container (parent div with border-top style)
            const buttonsContainer = acknowledgeBtn?.closest('.no-print[style*="border-top"]');
            if (buttonsContainer) {
                buttonsContainer.style.display = 'none';
            }
        }
        
        // Insert reversal status banner into the DOM
        if (statusBanner) {
        const auditContentDiv = document.getElementById('auditContent');
        if (auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection && buttonsSection.parentElement) {
                buttonsSection.parentElement.insertBefore(statusBanner, buttonsSection);
            } else {
                auditContentDiv.appendChild(statusBanner);
            }
        }
    }
    }
    
    // Handle acknowledgement status separately
    // Note: Acknowledgement status is now shown in the footer, not as a separate banner
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
}

// NOTE: displaySubmittedReversalForm function has been removed
// It was replaced by displayReversalApprovalInterface which shows the "Review & Process Reversal" interface
// This provides a consistent UI across all user roles (agents see read-only, team leads/auditors/admins see editable)

// Start reversal timer countdown
function startReversalTimer(auditSubmissionTime) {
    const timerElement = document.getElementById('reversalTimer');
    const timerTextElement = document.getElementById('reversalTimerText');
    const timerValueElement = document.getElementById('reversalTimerValue');
    const timerIconElement = document.getElementById('reversalTimerIcon');
    
    if (!timerElement || !timerTextElement) {
        return;
    }
    
    // Update timer every second
    const updateTimer = () => {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        
        if (timeRemaining <= 0) {
            // Timer expired - hide reversal button
            timerElement.style.display = 'none';
            const reversalBtn = document.getElementById('reversalBtn');
            if (reversalBtn) {
                reversalBtn.style.display = 'none';
                // Adjust acknowledge button border radius if reversal button is hidden
                const acknowledgeBtn = document.getElementById('acknowledgeBtn');
                if (acknowledgeBtn) {
                    acknowledgeBtn.style.borderRadius = '0.2425rem';
                }
            }
            return;
        }
        
        // Check if time is running low (less than 2 hours)
        const isLowTime = timeRemaining < 7200; // 2 hours in seconds
        const isVeryLowTime = timeRemaining < 3600; // 1 hour in seconds
        const isCriticalTime = timeRemaining < 600; // 10 minutes in seconds
        
        // Determine color and animation based on time remaining
        let timerColor = '#374151';
        let timerAnimation = 'none';
        let elementAnimation = 'none';
        let elementColor = '#000000';
        let elementFontWeight = '500';
        let iconColor = '';
        let iconAnimation = 'none';
        let iconOpacity = '0.6';
        
        if (isCriticalTime) {
            // Critical: Red color, flash animation, shake effect
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 0.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1s ease-in-out infinite, shake 0.5s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '700';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isVeryLowTime) {
            // Very low: Orange color, pulse animation
            timerColor = '#f59e0b';
            timerAnimation = 'flash-text 1s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1.5s ease-in-out infinite';
            elementColor = '#f59e0b';
            elementFontWeight = '600';
            iconColor = '#f59e0b';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isLowTime) {
            // Low: Red color, subtle pulse
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 1.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 2s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '600';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        }
        
        // Get current footer to determine text color
        const footerBar = document.getElementById('footerBar');
        let defaultTimerColor = '#374151';
        let defaultTextColor = '#000000';
        
        if (footerBar) {
            const bgColor = footerBar.style.backgroundColor || window.getComputedStyle(footerBar).backgroundColor;
            const isFooterGreen = bgColor.includes('rgb(6, 95, 70)') || bgColor.includes('#065f46');
            
            if (isFooterGreen) {
                defaultTimerColor = 'white';
                defaultTextColor = 'white';
            }
        }
        
        // For critical time, use red; otherwise use the footer-appropriate color (white for green, gray for default)
        const finalTimerColor = isCriticalTime ? '#ef4444' : defaultTimerColor;
        
        timerTextElement.innerHTML = `Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${finalTimerColor}; animation: ${timerAnimation};">${formatTimeRemaining(timeRemaining)}</span>`;
        
        // Apply styles to timer element
        timerElement.style.animation = elementAnimation;
        timerElement.style.color = defaultTextColor;
        timerElement.style.fontWeight = elementFontWeight;
        
        // Update icon animation
        const currentIconElement = document.getElementById('reversalTimerIcon');
        if (currentIconElement) {
            currentIconElement.style.color = iconColor;
            currentIconElement.style.animation = iconAnimation;
            currentIconElement.style.opacity = iconOpacity;
        }
        
        // Continue updating
        setTimeout(updateTimer, 1000);
    };
    
    // Start the timer
    updateTimer();
}

// Toggle between text view and chat view
function toggleTranscriptView() {
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleBtn = document.getElementById('toggleTranscriptViewBtn');
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    const rightColumn = document.getElementById('rightColumn');
    
    if (!transcriptChatView || !transcriptTextView || !toggleBtn) return;
    
    const isChatView = transcriptChatView.style.display !== 'none' && window.getComputedStyle(transcriptChatView).display !== 'none';
    
    if (isChatView) {
        // Switch to text view
        transcriptChatView.style.display = 'none';
        transcriptTextView.style.display = 'flex';
        toggleBtn.textContent = 'Chat View';
        toggleBtn.title = 'Switch to chat view';
        
        // Show text panel, hide chat panel
        if (textPanel) {
            textPanel.style.display = 'block';
            // Match height to transcript container (left column details)
            const transcriptContainer = transcriptTextView?.parentElement;
            if (transcriptContainer) {
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        textPanel.style.maxHeight = transcriptHeight + 'px';
                        textPanel.style.height = 'auto';
                    }
                }, 100);
            }
        }
        if (chatPanel) {
            chatPanel.style.display = 'none';
        }
    } else {
        // Switch to chat view
        transcriptTextView.style.display = 'none';
        transcriptChatView.style.display = 'flex';
        toggleBtn.textContent = 'Text View';
        toggleBtn.title = 'Switch to text view';
        
        // Show chat panel, hide text panel
        if (chatPanel) {
            chatPanel.style.display = 'block';
            // Match height to transcript container (left column details)
            const transcriptContainer = transcriptChatView?.parentElement;
            if (transcriptContainer) {
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        chatPanel.style.maxHeight = transcriptHeight + 'px';
                        chatPanel.style.height = 'auto';
                    }
                }, 100);
            }
        }
        if (textPanel) {
            textPanel.style.display = 'none';
        }
        
        // If Intercom conversation not loaded, try to parse plain text transcript
        const chatContainer = document.getElementById('chatMessagesContainer');
        if (chatContainer && (!currentConversationData && chatContainer.children.length === 0)) {
            // Read transcript directly from audit data instead of DOM
            const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
            // Check if transcript exists and is not the "No transcript available" message
            if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
                const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
                parseTranscriptToChat(transcriptText, interactionDate);
            }
        }
        
        // Scroll to bottom
        setTimeout(() => {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }, 100);
    }
}

// Make toggleTranscriptView globally accessible
window.toggleTranscriptView = toggleTranscriptView;

// Intercom API Integration
let currentConversationData = null;
let isChatViewActive = false;

// Get Intercom and Supabase config (use existing globals from config files if available)
const INTERCOM_CONFIG = window.intercomConfig || {
    baseUrl: 'https://app.intercom.com',
    appId: ''
};

// Get Supabase config from window.SupabaseConfig (set by supabase-config.js)
// Use local variables with different names to avoid conflicts
const supabaseUrl = window.SupabaseConfig?.url || '';
const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';

// Fetch conversation from Intercom API
async function loadConversationFromIntercom(conversationId) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
    
    if (!chatMessagesContainer || !transcriptChatView) return;
    
    // Show loading state
    chatMessagesContainer.innerHTML = `
        <div style="text-align: center; padding: 1.2937rem; color: #000000;">
            <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
        </div>
    `;

    try {
        // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
        // Add display_as parameter to get full conversation data including email_message_metadata
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}&display_as=plaintext`;
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const conversation = await response.json();
        currentConversationData = conversation;


        // Parse and display conversation messages
        displayConversationMessages(conversation);

        // Extract and display all conversation attributes
        displayConversationAttributes(conversation);

        // Auto-switch to chat view if not already active
        if (!isChatViewActive) {
            isChatViewActive = true;
            transcriptChatView.style.display = 'flex';
            if (transcriptTextView) transcriptTextView.style.display = 'none';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Text View';
                toggleTranscriptViewBtn.title = 'Switch to text view';
            }
        }

    } catch (error) {
        console.error('Error loading conversation from Intercom:', error);
        
        // Try to parse database transcript as fallback
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                if (toggleTranscriptViewBtn) {
                    toggleTranscriptViewBtn.textContent = 'Text View';
                    toggleTranscriptViewBtn.title = 'Switch to text view';
                }
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - fallback to text view
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
        
        if (transcriptChatView && transcriptTextView) {
            // Switch to text view
            transcriptChatView.style.display = 'none';
            transcriptTextView.style.display = 'flex';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Chat View';
                toggleTranscriptViewBtn.title = 'Switch to chat view';
            }
            isChatViewActive = false;
        }
        
        // Show error message in chat container (for debugging, but user will see text view)
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                <p style="font-size: 0.4852rem; color: #000000;">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: #000000; margin-top: 0.3234rem;">No database transcript available.</p>
            </div>
        `;
        }
    }
}

// Display conversation messages in chat interface
function displayConversationMessages(conversation) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    if (!chatMessagesContainer) return;
    
    // Helper function to generate avatar with initials
    function generateAvatar(name, type) {
        // Extract initials from name
        const getInitials = (name) => {
            if (!name || name === 'Unknown') return '?';
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        };
        
        const initials = getInitials(name);
        
        // Determine colors and gradients based on type
        let bgGradient, textColor, label, borderColor;
        if (type === 'user' || type === 'contact') {
            // Blue gradient for client
            bgGradient = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            textColor = '#ffffff';
            label = 'Client'; // Use "Client" label under avatar
            borderColor = '#2563eb';
        } else if (type === 'ai' || type === 'bot') {
            // Darker green gradient for AI
            bgGradient = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
            textColor = '#ffffff';
            label = 'AI';
            borderColor = '#166534';
        } else {
            // Green gradient for agent
            bgGradient = 'linear-gradient(135deg, #1A733E 0%, #14532d 100%)';
            textColor = '#ffffff';
            label = 'Agent';
            borderColor = '#14532d';
        }
        
        return {
            initials,
            bgGradient,
            textColor,
            label,
            borderColor
        };
    }

    const parts = conversation.conversation_parts?.conversation_parts || [];
    
    // Update conversation heading with client name
    // BUT: If there's a reversal request and user is an agent, show "Reversal Request Info" instead
    const transcriptHeading = document.querySelector('h3');
    if (transcriptHeading) {
        const isAgent = isCurrentUserAuditedEmployee();
        const hasReversal = currentAudit && (currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at);
        
        // For agents with reversal requests, show "Reversal Request Info" instead of client name
        if (isAgent && hasReversal) {
            const icon = transcriptHeading.querySelector('svg');
            if (icon) {
                transcriptHeading.innerHTML = icon.outerHTML + ' Reversal Request Info';
            } else {
                transcriptHeading.textContent = 'Reversal Request Info';
            }
        } else {
            // Extract client name from conversation
            let clientName = 'Transcript';
            // Try to get client name from source.author
            if (conversation.source?.author?.name) {
                clientName = conversation.source.author.name;
            }
            // Try contacts
            else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
                const contact = conversation.contacts.contacts[0];
                if (contact.name) {
                    clientName = contact.name;
                }
            }
            // Try to find first user/contact in conversation parts
            else if (parts.length > 0) {
                for (const part of parts) {
                    if (part.author && (part.author.type === 'user' || part.author.type === 'contact')) {
                        if (part.author.name) {
                            clientName = part.author.name;
                            break;
                        }
                    }
                }
            }
            
            // Update client name input field
            const clientNameInput = document.getElementById('clientName');
            if (clientNameInput && clientName && clientName !== 'Transcript') {
                clientNameInput.value = clientName;
            }
            
            // Update heading text (keep the icon)
            const icon = transcriptHeading.querySelector('svg');
            if (icon) {
                // Keep the SVG icon and replace "Transcript" with client name
                transcriptHeading.innerHTML = icon.outerHTML + ' ' + escapeHtml(clientName);
            } else {
                transcriptHeading.textContent = clientName;
            }
        }
    }
    
    if (parts.length === 0) {
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #000000;">
                <p>No messages found in this conversation.</p>
            </div>
        `;
        return;
    }

    // Sort parts by created_at timestamp
    const sortedParts = [...parts].sort((a, b) => {
        const timeA = typeof a.created_at === 'number' ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at) : new Date(a.created_at).getTime();
        const timeB = typeof b.created_at === 'number' ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at) : new Date(b.created_at).getTime();
        return timeA - timeB;
    });

    // Clear container and remove empty state message
    chatMessagesContainer.innerHTML = '';
    chatMessagesContainer.style.gap = '0.3234rem';
    
    // Reset images array
    allConversationImages = [];

    sortedParts.forEach(part => {
        const message = part.body || '';
        const author = part.author || {};
        const authorName = author.name || author.email || 'Unknown';
        const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
        const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
        
        // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
        let timestamp;
        if (typeof part.created_at === 'number') {
            // Unix timestamp in seconds - convert to milliseconds
            timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
        } else {
            timestamp = new Date(part.created_at);
        }
        
        // Format timestamp for display
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        // Check if this is a system comment part type (should be displayed outside chat bubbles)
        const systemCommentTypes = [
            'user_became_idle',
            'close',
            'fin_guidance_applied',
            'conversation_attribute_updated_by_admin',
            'attribute_collected'
        ];
        const isSystemComment = systemCommentTypes.includes(partType);
        
        // If this is a system comment, render it differently (outside chat bubbles)
        if (isSystemComment) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0.4043rem 0;
                padding: 0 0.8086rem;
            `;
            
            // Format the message body
            let messageData;
            try {
                messageData = formatMessageBody(message);
            } catch (e) {
                console.error('Error formatting message body for system comment:', e);
                messageData = { text: '', html: null, images: [] };
            }
            const formattedText = messageData?.text || '';
            const formattedHtml = messageData?.html || null;
            
            // Create human-readable label for the part type
            const partTypeLabels = {
                'user_became_idle': 'User became idle',
                'close': 'Conversation closed',
                'fin_guidance_applied': 'Guidance applied',
                'conversation_attribute_updated_by_admin': 'Attribute updated by admin',
                'attribute_collected': 'Attribute collected'
            };
            const partTypeLabel = partTypeLabels[partType] || partType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Build the system comment content
            let commentContent = '';
            // Use text version for system comments to avoid HTML rendering issues
            if (formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}') {
                commentContent = formattedText;
            } else if (part.body && String(part.body).trim() !== '') {
                // Fallback: strip HTML tags from body and get plain text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = String(part.body);
                commentContent = tempDiv.textContent || tempDiv.innerText || '';
            }
            
            // Escape HTML for safe display
            if (commentContent) {
                const tempEscDiv = document.createElement('div');
                tempEscDiv.textContent = commentContent;
                commentContent = tempEscDiv.innerHTML;
            }
            
            messageDiv.innerHTML = `
                <div style="
                    background: #f3f4f6;
                    border: 0.0304rem solid #e5e7eb;
                    border-radius: 0.2426rem;
                    padding: 0.3234rem 0.4852rem;
                    max-width: 80%;
                    text-align: center;
                    font-size: 0.4447rem;
                    color: #000000;
                    line-height: 1.5;
                ">
                    <div style="
                        font-weight: 600;
                        color: #000000;
                        margin-bottom: 0.1213rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0405rem;
                        font-size: 0.4043rem;
                    ">${partTypeLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}</div>
                    ${commentContent ? `<div style="margin-top: 0.1617rem; color: #000000; font-size: 0.4447rem;">${commentContent}</div>` : ''}
                    <div style="
                        margin-top: 0.1617rem;
                        font-size: 0.3639rem;
                        color: #000000;
                        opacity: 0.8;
                    ">${timeStr} • ${dateStr}</div>
                </div>
            `;
            
            chatMessagesContainer.appendChild(messageDiv);
            return; // Skip normal message rendering for system comments
        }
        
        // Continue with normal message rendering for non-system-comment parts
        const isUser = authorType === 'user' || authorType === 'contact';
        const isAdmin = authorType === 'admin' || authorType === 'team';
        // Detect AI/Bot messages - be strict: only if explicitly bot type or has AI flags
        // Don't check name for "ai" as admins might be labeled as "AI" but are actually agents
        const isAI = authorType === 'bot' || 
                    author.from_ai_agent === true || 
                    author.is_ai_answer === true ||
                    (part.from_ai_agent === true) ||
                    (part.is_ai_answer === true);
        
        // Format the message body to check if it has content
        // This extracts images from HTML img tags and text-based [Image "..."] references
        const messageData = formatMessageBody(message);
        const formattedText = messageData.text;
        const formattedHtml = messageData.html || null; // HTML with inline images
        const images = messageData.images || [];
        
        // Check if this is an email interaction
        // email_message_metadata is either null (not an email) or an object with properties (is an email)
        // Note: typeof null === 'object' in JavaScript, so we must explicitly check for null
        const isEmail = !!(part.email_message_metadata && 
            part.email_message_metadata !== null && 
            typeof part.email_message_metadata === 'object' && 
            Object.keys(part.email_message_metadata).length > 0);
        const emailMetadata = isEmail ? part.email_message_metadata : {};
        
        // Extract attachments from attachments array (separate from body images)
        const attachments = part.attachments || [];
        
        // Extract image attachments - check multiple possible structures
        const attachmentImages = [];
        attachments.forEach(att => {
            // Check if it's an image attachment
            const isImage = (
                (att.type === 'upload' || att.type === 'image' || !att.type) &&
                (
                    (att.content_type && att.content_type.startsWith('image/')) ||
                    (att.url && /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i.test(att.url))
                ) &&
                att.url
            );
            
            if (isImage && att.url) {
                attachmentImages.push(att.url);
            }
        });
        
        // Combine body images and attachment images
        // Body images come first (they appear inline in text), then attachments
        const allImages = [...images, ...attachmentImages];
        
        // Add images to global array with their index for viewer navigation
        const imageStartIndex = allConversationImages.length;
        allImages.forEach((imgSrc, idx) => {
            allConversationImages.push({
                src: imgSrc,
                partIndex: sortedParts.indexOf(part),
                localIndex: idx
            });
        });
        
        // REMOVED: No longer skipping any parts - show ALL parts in the chatbox
        // Always display parts so users can see everything, even if empty
        
        // Check what content this part has (for display purposes)
        const hasBody = !!(part.body && String(part.body).trim() !== '');
        const hasText = !!(formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}');
        const hasHtml = !!formattedHtml;
        const hasImages = allImages.length > 0;
        const hasAttachments = attachments.length > 0;
        
        // Build content info badge to show in UI what this part contains
        // Always show part_type for all parts
        let contentInfoBadge = '';
        const contentTypes = [];
        
        // Always include part_type first
        if (partType) {
            contentTypes.push(`Type: ${partType}`);
        }
        
        // Then add content types
        if (hasText || hasHtml) contentTypes.push('Text');
        if (hasImages) contentTypes.push(`${allImages.length} Image${allImages.length > 1 ? 's' : ''}`);
        if (hasAttachments) contentTypes.push(`${attachments.length} Attachment${attachments.length > 1 ? 's' : ''}`);
        if (isEmail) contentTypes.push('Email');
        
        // Always show badge if we have part_type or any content
        if (contentTypes.length > 0 || partType) {
            contentInfoBadge = `<div style="
                font-size: 0.3639rem;
                color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.7)'};
                margin-bottom: 0.1617rem;
                padding: 0.1213rem 0.2426rem;
                background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                border-radius: 0.1617rem;
                display: inline-block;
            ">
                ${contentTypes.length > 0 ? contentTypes.join(' • ') : (partType ? `Part Type: ${partType}` : 'Empty Part')}
            </div>`;
        }

        // Determine message type for avatar and styling
        // Important: Agents should be green, AI should be dark gray
        const messageType = isUser ? 'user' : (isAI ? 'ai' : 'agent');
        const avatar = generateAvatar(authorName, messageType);
        
        // Create message bubble container (avatar will be added in innerHTML)
        const messageDiv = document.createElement('div');

        // Colors: User = white, Agent = #1A733E, AI = #1d1d1d (dark gray)
        const bubbleStyle = isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 100%;
                width: fit-content;
                margin-right: auto;
                margin-left: 0;
            `
            : isAI
            ? `
                background: #1d1d1d;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `;

        // Build email header if this is an email
        let emailHeaderHTML = '';
        if (isEmail) {
            const emailHeaders = emailMetadata.email_address_headers || [];
            const fromHeader = emailHeaders.find(h => h.type === 'from') || {};
            const toHeader = emailHeaders.find(h => h.type === 'to') || {};
            const replyToHeader = emailHeaders.find(h => h.type === 'reply_to') || {};
            const subject = emailMetadata.subject || 'No Subject';
            
            // Format email addresses
            const formatEmailAddress = (header) => {
                if (!header) return '';
                const name = header.name || '';
                const email = header.email_address || '';
                if (name && email) {
                    return `${escapeHtml(name)} <${escapeHtml(email)}>`;
                } else if (email) {
                    return escapeHtml(email);
                } else if (name) {
                    return escapeHtml(name);
                }
                return '';
            };
            
            const fromStr = formatEmailAddress(fromHeader);
            const toStr = formatEmailAddress(toHeader);
            const replyToStr = formatEmailAddress(replyToHeader);
            
            // For agent emails, use a more prominent blue background that stands out from green
            // For user emails, use a light blue background
            // For AI emails, use dark gray background matching chat bubble
            const emailBgColor = isUser ? '#e0f2fe' : (isAI ? '#2d2d2d' : '#1e40af');
            const emailBorderColor = isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6');
            const emailIconColor = isUser ? '#0284c7' : (isAI ? '#ffffff' : '#93c5fd');
            const emailTextColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
            const emailLabelColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
            const emailSubjectColor = isUser ? '#0c4a6e' : (isAI ? '#ffffff' : '#dbeafe');
            const emailFieldColor = isUser ? '#075985' : (isAI ? '#e5e7eb' : '#bfdbfe');
            const emailBorderBottomColor = isUser ? 'rgba(2, 132, 199, 0.2)' : (isAI ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.2)');
            
            emailHeaderHTML = `
                <div style="
                    background: ${emailBgColor};
                    border: 0.0606rem solid ${emailBorderColor};
                    padding: 0.4852rem 0.5659rem;
                    margin-bottom: 0.4043rem;
                    border-radius: 0.3234rem;
                    font-size: 0.4447rem;
                    box-shadow: 0 0.0405rem 0.1213rem rgba(0,0,0,0.1);
                    max-width: 100%;
                    box-sizing: border-box;
                    word-wrap: break-word;
                    overflow-wrap: break-word;
                ">
                    <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.2426rem; padding-bottom: 0.1617rem; border-bottom: 0.0304rem solid ${emailBorderBottomColor};">
                        <svg style="width: 0.6064rem; height: 0.6064rem; color: ${emailIconColor}; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                            <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                        </svg>
                        <span style="font-weight: 700; color: ${emailLabelColor}; text-transform: uppercase; font-size: 0.4043rem; letter-spacing: 0.0405rem;">Email</span>
                    </div>
                    ${subject ? `<div style="color: ${emailSubjectColor}; margin-bottom: 0.2426rem; font-weight: 600; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        <span style="color: ${emailFieldColor}; font-weight: 700;">Subject:</span> ${escapeHtml(subject)}
                    </div>` : ''}
                    <div style="color: ${emailSubjectColor}; font-size: 0.4043rem; line-height: 1.6; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        ${fromStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">From:</span> ${fromStr}</div>` : ''}
                        ${toStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">To:</span> ${toStr}</div>` : ''}
                        ${replyToStr ? `<div style="margin-top: 0.1213rem; font-size: 0.3639rem; opacity: 0.9; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">Reply-To:</span> ${replyToStr}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // Build attachments HTML (non-image attachments)
        let attachmentsHTML = '';
        const nonImageAttachments = attachments.filter(att => 
            att.type === 'upload' && 
            (!att.content_type || !att.content_type.startsWith('image/'))
        );
        if (nonImageAttachments.length > 0) {
            attachmentsHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-direction: column; gap: 0.1617rem;">';
            nonImageAttachments.forEach(att => {
                attachmentsHTML += `
                    <a 
                        href="${escapeHtml(att.url)}" 
                        target="_blank"
                        rel="noopener noreferrer"
                        style="
                            display: flex;
                            align-items: center;
                            gap: 0.2426rem;
                            padding: 0.2426rem 0.3234rem;
                            background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                            border-radius: 0.2426rem;
                            text-decoration: none;
                            color: ${isUser ? '#374151' : 'white'};
                            font-size: 0.4447rem;
                            transition: background 0.2s ease;
                        "
                        onmouseover="this.style.background='${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.15)'}'"
                        onmouseout="this.style.background='${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'}'"
                    >
                        <svg style="width: 0.4852rem; height: 0.4852rem; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"/>
                        </svg>
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(att.name || 'Attachment')}</span>
                        ${att.filesize ? `<span style="color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.7)'}; font-size: 0.3639rem;">${(att.filesize / 1024).toFixed(1)} KB</span>` : ''}
                    </a>
                `;
            });
            attachmentsHTML += '</div>';
        }

        // Build images HTML (for images that aren't inline in text)
        let imagesHTML = '';
        if (allImages.length > 0 && !formattedHtml) {
            imagesHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-wrap: wrap; gap: 0.3234rem;">';
            allImages.forEach((imgSrc, idx) => {
                const globalIndex = imageStartIndex + idx;
                const escapedSrc = escapeHtmlAttribute(imgSrc);
                imagesHTML += `<img src="${escapedSrc}" alt="Attachment ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" style="max-width: 200px; max-height: 200px; border-radius: 0.3234rem; cursor: pointer; object-fit: cover; border: 0.0304rem solid ${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0.1617rem 0.4852rem rgba(0,0,0,0.2)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'" onerror="console.error('Failed to load image:', this.src);" loading="lazy" />`;
            });
            imagesHTML += '</div>';
        }

        // Compact layout: timestamp next to sender name for both user and agent messages
        // For emails, make the border more prominent
        const emailBorderStyle = isEmail ? `border: 0.0808rem solid ${isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6')} !important; box-shadow: 0 0.0606rem 0.1617rem ${isUser ? 'rgba(2, 132, 199, 0.3)' : (isAI ? 'rgba(29, 29, 29, 0.3)' : 'rgba(59, 130, 246, 0.3)')} !important;` : '';
        
        // Avatar alignment: Client on left, Agent/AI on right
        const avatarAlign = isUser ? 'flex-start' : 'flex-end';
        const avatarMargin = isUser ? 'margin-right: 0.3234rem;' : 'margin-left: 0.3234rem;';
        const avatarOrder = isUser ? '1' : '3';
        
        // Avatar HTML - Client left, Agent/AI right
        // For AI, use the image avatar; for others, use gradient with initials
        const avatarHTML = isAI ? `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#000000' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        ` : `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    color: ${avatar.textColor};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.5257rem;
                    font-weight: 700;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1), inset 0 0.0203rem 0 rgba(255,255,255,0.2);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <span style="position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2);">${avatar.initials}</span>
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#000000' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        `;
        
        // Message container: Client avatar left, Agent/AI avatar right
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            margin-bottom: 0;
            width: 100%;
            justify-content: ${isUser ? 'flex-start' : 'flex-end'};
            gap: 0.3234rem;
        `;
        
        messageDiv.innerHTML = `
            ${isUser ? avatarHTML : ''}
            <div style="flex: 1; display: flex; flex-direction: column; align-items: ${isUser ? 'flex-start' : 'flex-end'}; order: ${isUser ? '2' : '1'}; min-width: 0; max-width: calc(100% - 3.5rem);">
                <div style="${bubbleStyle} padding: 0.4043rem 0.5659rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08); ${emailBorderStyle} word-wrap: break-word; overflow-wrap: break-word;">
                ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #000000;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #000000; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                ${emailHeaderHTML}
                ${contentInfoBadge}
                ${formattedHtml ? renderMessageWithInlineImages(formattedHtml, images, imageStartIndex, part.id, isUser) : 
                  (hasText ? 
                    `<div class="message-text-content" data-original-text="${escapeHtml(formattedText.replace(/"/g, '&quot;'))}" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#374151' : 'white'};">${formattedText}</div>` : 
                    (partType && partType.trim() !== '' ? 
                        `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                            <span style="text-transform: uppercase; font-weight: 600; letter-spacing: 0.0405rem; font-size: 0.4447rem; opacity: 0.8;">${escapeHtml(partType)}</span>
                            ${hasBody ? '<span style="margin-left: 0.2426rem; font-size: 0.4043rem; opacity: 0.6;">(body exists but no displayable content)</span>' : ''}
                        </div>` : 
                        (hasBody || hasImages || hasAttachments || isEmail ? 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                <span style="opacity: 0.7;">Part ID: ${part.id}</span>
                                ${hasBody ? '<span style="margin-left: 0.2426rem;">• Has body (no displayable text)</span>' : ''}
                            </div>` : 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.5)'}; font-style: italic;">
                                <span style="opacity: 0.6;">Empty part (ID: ${part.id})</span>
                            </div>`
                        )
                    )
                )}
                ${!formattedHtml && imagesHTML ? imagesHTML : ''}
                ${attachmentsHTML}
                </div>
            </div>
            ${!isUser ? avatarHTML : ''}
        `;

        chatMessagesContainer.appendChild(messageDiv);
    });

    // Scroll to bottom after a brief delay to ensure DOM is updated
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Language detection function - simple heuristic to detect non-English text
function detectLanguage(text) {
    if (!text || text.trim().length === 0) return 'en';
    
    // Remove HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';
    
    // Simple heuristic: check for common English patterns
    // Count English letters vs non-English characters
    const englishPattern = /[a-zA-Z]/g;
    const nonEnglishPattern = /[^\x00-\x7F]/g;
    
    const englishChars = (plainText.match(englishPattern) || []).length;
    const nonEnglishChars = (plainText.match(nonEnglishPattern) || []).length;
    const totalChars = plainText.replace(/\s/g, '').length;
    
    // If more than 30% non-ASCII characters, likely not English
    if (totalChars > 0 && (nonEnglishChars / totalChars) > 0.3) {
        return 'auto'; // Needs translation
    }
    
    // Check for common non-English language patterns
    const commonNonEnglishPatterns = [
        /[\u0600-\u06FF]/g, // Arabic
        /[\u4E00-\u9FFF]/g, // Chinese
        /[\u3040-\u309F\u30A0-\u30FF]/g, // Japanese
        /[\u0400-\u04FF]/g, // Cyrillic
        /[\u0590-\u05FF]/g, // Hebrew
        /[\u0E00-\u0E7F]/g, // Thai
    ];
    
    for (const pattern of commonNonEnglishPatterns) {
        if (pattern.test(plainText)) {
            return 'auto'; // Needs translation
        }
    }
    
    return 'en'; // Likely English
}

// Translate text using LibreTranslate API with retry logic
async function translateText(text, targetLang = 'en', retryCount = 0) {
    if (!text || text.trim().length === 0) return text;
    
    const maxRetries = 3;
    const baseDelay = 1000; // Start with 1 second delay
    
    try {
        // Use LibreTranslate public API
        const response = await fetch('https://libretranslate.com/translate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                q: text,
                source: 'auto',
                target: targetLang,
                format: 'text'
            })
        });
        
        // Handle rate limiting with exponential backoff
        if (response.status === 429) {
            if (retryCount < maxRetries) {
                const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 1s, 2s, 4s
                await new Promise(resolve => setTimeout(resolve, delay));
                return translateText(text, targetLang, retryCount + 1);
            } else {
                throw new Error('Rate limit exceeded. Please try again later.');
            }
        }
        
        // Handle bad requests (400) - skip this message
        if (response.status === 400) {
            console.warn('Bad request for translation, skipping:', text.substring(0, 50));
            return text; // Return original text
        }
        
        if (!response.ok) {
            throw new Error(`Translation API error: ${response.status}`);
        }
        
        const data = await response.json();
        return data.translatedText || text;
    } catch (error) {
        // If it's a rate limit error and we've exhausted retries, try fallback
        if (error.message && error.message.includes('Rate limit') && retryCount >= maxRetries) {
            // Fallback: try MyMemory Translation API
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=auto|en`);
                const data = await response.json();
                if (data.responseData && data.responseData.translatedText) {
                    return data.responseData.translatedText;
                }
            } catch (fallbackError) {
                console.error('Fallback translation error:', fallbackError);
            }
        }
        
        // If error doesn't mention rate limit, log it but return original text
        if (!error.message || !error.message.includes('Rate limit')) {
            console.error('Translation error:', error);
        }
        
        return text; // Return original if translation fails
    }
}

// Main translation function
async function translateChatMessages() {
    // Feature is currently disabled
    const translateBtn = document.getElementById('translateChatBtn');
    if (translateBtn && translateBtn.disabled) {
        return;
    }
    
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    
    if (!chatMessagesContainer) {
        showNotification('Chat messages container not found', 'error');
        return;
    }
    
    // Get all message text elements
    const messageTextElements = chatMessagesContainer.querySelectorAll('.message-text-content');
    
    if (messageTextElements.length === 0) {
        showNotification('No messages to translate', 'info');
        return;
    }
    
    let translatedCount = 0;
    let skippedCount = 0;
    
    // Process messages sequentially to avoid rate limiting
    // Use longer delays for public API (500ms between requests)
    const delayBetweenRequests = 500;
    
    for (let i = 0; i < messageTextElements.length; i++) {
        const element = messageTextElements[i];
        const originalText = element.getAttribute('data-original-text');
        if (!originalText) continue;
        
        // Decode HTML entities to get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = originalText;
        const plainText = tempDiv.textContent || tempDiv.innerText || '';
        
        // Skip if text is too short or empty
        if (plainText.trim().length < 3) {
            skippedCount++;
            continue;
        }
        
        // Detect language
        const detectedLang = detectLanguage(plainText);
        
        if (detectedLang === 'en') {
            skippedCount++;
            continue; // Skip English messages
        }
        
        // Translate the text
        try {
            const translatedText = await translateText(plainText, 'en');
            
            // Only update if translation is different from original
            if (translatedText && translatedText.trim() !== plainText.trim() && translatedText !== plainText) {
                // Update the element with translated text (escape HTML for safety)
                element.innerHTML = escapeHtml(translatedText);
                translatedCount++;
            } else {
                skippedCount++;
            }
            
            // Delay between requests to avoid rate limiting (500ms)
            // Skip delay for last message
            if (i < messageTextElements.length - 1) {
                await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
            }
        } catch (error) {
            console.error('Error translating message:', error);
            skippedCount++;
            // If rate limited, add extra delay
            if (error.message && error.message.includes('Rate limit')) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
    
    // Show completion notification
    if (translatedCount > 0) {
        showNotification(`Translated ${translatedCount} message(s) to English`, 'success');
    } else if (skippedCount > 0) {
        showNotification('All messages are already in English', 'info');
    } else {
        showNotification('No messages found to translate', 'info');
    }
}

// Make translation function globally accessible
window.translateChatMessages = translateChatMessages;

// Format message body (handle HTML/plain text and extract images)
function formatMessageBody(body) {
    if (!body) return { text: '', images: [], html: null };
    
    // If body is an object, extract text
    if (typeof body === 'object') {
        // Handle empty objects
        if (Object.keys(body).length === 0) return { text: '', images: [], html: null };
        
        // Check for text content in various possible fields
        if (body.plaintext) {
            const text = String(body.plaintext).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.text) {
            const text = String(body.text).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.body) {
            return parseHtmlBody(String(body.body));
        }
        
        // Check for HTML content
        if (body.html) {
            return parseHtmlBody(String(body.html));
        }
        
        // If object has no text content, return empty
        // Don't stringify as that would just show "{}"
        return { text: '', images: [], html: null };
    }
    
    // Handle string body (which may contain HTML)
    return parseHtmlBody(String(body));
}

// Parse HTML body to extract text and images (preserve inline images)
// Handles both HTML <img> tags and text-based [Image "..."] references
function parseHtmlBody(htmlBody) {
    if (!htmlBody) return { text: '', images: [], html: '' };
    
    const htmlString = String(htmlBody);
    const images = [];
    let processedHtml = htmlString;
    
    // Step 1: Extract images from HTML <img> tags
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;
    
    const imgTags = tempDiv.querySelectorAll('img');
    let imageIndex = 0;
    
    imgTags.forEach((img) => {
        const src = img.getAttribute('src') || '';
        if (src) {
            // Decode HTML entities in URL (but preserve the original URL structure)
            let decodedSrc = src;
            // Only decode if it's clearly an HTML entity, not part of URL encoding
            if (src.includes('&amp;') && !src.includes('?')) {
                decodedSrc = src.replace(/&amp;/g, '&');
            }
            images.push(decodedSrc);
            
            // Replace img tag with a placeholder
            const placeholder = document.createTextNode(`__IMAGE_PLACEHOLDER_${imageIndex}__`);
            if (img.parentNode) {
                img.parentNode.replaceChild(placeholder, img);
            }
            imageIndex++;
        }
    });
    
    // Get HTML with placeholders from img tags
    processedHtml = tempDiv.innerHTML;
    
    // Step 2: Extract images from text-based [Image "..."] references
    // Pattern: [Image "URL"] or [Image 'URL'] or [Image URL]
    // Need to handle URLs with query parameters that might contain quotes
    // More robust pattern: [Image "..."], [Image '...'], or [Image ...]
    const imageReferencePattern = /\[Image\s+(?:"([^"]+)"|'([^']+)'|([^\]]+))\]/gi;
    let match;
    const textImageMatches = [];
    
    // Find all matches and their positions
    while ((match = imageReferencePattern.exec(htmlString)) !== null) {
        // match[1] = double-quoted URL, match[2] = single-quoted URL, match[3] = unquoted URL
        const imageUrl = match[1] || match[2] || match[3];
        const fullMatch = match[0];
        const matchIndex = match.index;
        
        if (imageUrl && imageUrl.trim() && !images.includes(imageUrl.trim())) {
            const trimmedUrl = imageUrl.trim();
            // Only add if not already found in HTML img tags
            textImageMatches.push({
                url: trimmedUrl,
                fullMatch: fullMatch,
                index: matchIndex,
                placeholderIndex: imageIndex
            });
            images.push(trimmedUrl);
            imageIndex++;
        }
    }
    
    // Replace text-based image references with placeholders (in reverse order to preserve indices)
    textImageMatches.reverse().forEach(match => {
        const placeholder = `__IMAGE_PLACEHOLDER_${match.placeholderIndex}__`;
        processedHtml = processedHtml.substring(0, match.index) + 
                      placeholder + 
                      processedHtml.substring(match.index + match.fullMatch.length);
    });
    
    // Step 3: Sanitize HTML using DOMPurify (security + clean HTML)
    if (typeof DOMPurify !== 'undefined') {
        processedHtml = DOMPurify.sanitize(processedHtml, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'b', 'i', 'u', 'a', 'ul', 'ol', 'li', 'code', 'pre', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
            ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
            ALLOW_DATA_ATTR: false,
            KEEP_CONTENT: true,
            RETURN_DOM: false,
            RETURN_DOM_FRAGMENT: false
        });
    }
    
    // Step 4: Extract plain text for fallback (remove placeholders)
    const tempDiv2 = document.createElement('div');
    tempDiv2.innerHTML = processedHtml;
    const plainText = tempDiv2.textContent || tempDiv2.innerText || '';
    const cleanedText = plainText.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '').trim();
    
    // Return HTML with placeholders, plain text, and images array
    return { 
        text: cleanedText, 
        images: images, 
        html: processedHtml // HTML with image placeholders, sanitized and preserving formatting
    };
}

// Escape HTML attribute value (for src attributes, preserve URL structure)
// Important: Only escape characters that would break HTML attributes
// Don't double-encode URL parameters (they're already properly encoded)
function escapeHtmlAttribute(value) {
    if (!value) return '';
    const str = String(value);
    
    // Only escape characters that would break the HTML attribute
    // Preserve URL structure including query parameters
    return str
        .replace(/&/g, '&amp;')  // Must escape & first
        .replace(/"/g, '&quot;')  // Escape quotes
        .replace(/'/g, '&#x27;')  // Escape single quotes
        .replace(/</g, '&lt;')    // Escape <
        .replace(/>/g, '&gt;');   // Escape >
    
    // Note: We don't escape spaces, slashes, or other URL characters
    // as they're already properly encoded in the URL
}

// Render message with inline images (replace placeholders with actual image elements)
function renderMessageWithInlineImages(htmlWithPlaceholders, images, imageStartIndex, messageId, isUser) {
    if (!htmlWithPlaceholders) return '';
    
    let renderedHtml = htmlWithPlaceholders;
    let replacedCount = 0;
    
    // Replace each image placeholder with an actual image element
    images.forEach((imgSrc, idx) => {
        const globalIndex = imageStartIndex + idx;
        const placeholder = `__IMAGE_PLACEHOLDER_${idx}__`;
        
        // Escape the image src for HTML attribute (preserve URL structure)
        // Only escape characters that would break the HTML attribute, preserve URL structure
        const escapedSrc = escapeHtmlAttribute(imgSrc);
        
        // Create image HTML with proper styling and click handler
        // Use proper attribute escaping for src, but don't double-encode URL parameters
        const imageHtml = `<img src="${escapedSrc}" alt="Image ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" onerror="console.error('Failed to load image:', this.src); this.style.display='none';" style="max-width: 100%; max-height: 20rem; border-radius: 0.3234rem; margin: 0.3234rem 0; cursor: pointer; display: block; box-shadow: 0 0.1213rem 0.2426rem rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0.2426rem 0.4852rem rgba(0,0,0,0.15)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0.1213rem 0.2426rem rgba(0,0,0,0.1)';" loading="lazy" />`;
        
        if (renderedHtml.includes(placeholder)) {
            renderedHtml = renderedHtml.replace(placeholder, imageHtml);
            replacedCount++;
        } else {
            console.warn(`⚠️ Image placeholder ${placeholder} not found in HTML for message ${messageId}`);
        }
    });
    
    // Clean up any remaining placeholders (shouldn't happen, but just in case)
    const remainingPlaceholders = (renderedHtml.match(/__IMAGE_PLACEHOLDER_\d+__/g) || []).length;
    if (remainingPlaceholders > 0) {
        console.warn(`⚠️ ${remainingPlaceholders} image placeholders not replaced in message ${messageId}`);
        renderedHtml = renderedHtml.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '');
    }
    
    // Add CSS class based on message type for styling
    const messageClass = isUser ? '' : 'agent-message';
    const textColor = isUser ? '#374151' : 'white';
    
    return `<div class="message-text-content ${messageClass}" data-message-id="${messageId}" style="font-size: 0.5257rem; line-height: 1.6; word-wrap: break-word; margin-top: 0; margin-bottom: 0; color: ${textColor};">
        ${renderedHtml}
    </div>`;
}

// Store all images from conversation for image viewer
let allConversationImages = [];
let currentImageIndex = 0;

// Open image viewer modal
window.openImageViewer = function(index) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    currentImageIndex = Math.max(0, Math.min(index, allConversationImages.length - 1));
    const modal = document.getElementById('imageViewerModal');
    const img = document.getElementById('imageViewerImg');
    const prevBtn = document.getElementById('imageViewerPrev');
    const nextBtn = document.getElementById('imageViewerNext');
    const counter = document.getElementById('imageViewerCounter');
    const closeBtn = document.getElementById('imageViewerClose');
    
    if (modal && img) {
        img.src = allConversationImages[currentImageIndex].src;
        img.style.display = 'block';
        
        // Update counter
        if (counter) {
            counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
        }
        
        // Show/hide navigation buttons
        if (prevBtn) {
            prevBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        if (nextBtn) {
            nextBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Focus on modal for keyboard navigation
        modal.focus();
    }
};

// Close image viewer modal
function closeImageViewer() {
    const modal = document.getElementById('imageViewerModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
}

// Navigate to previous image
function navigateImage(direction) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    if (direction === 'prev') {
        currentImageIndex = (currentImageIndex - 1 + allConversationImages.length) % allConversationImages.length;
    } else if (direction === 'next') {
        currentImageIndex = (currentImageIndex + 1) % allConversationImages.length;
    }
    
    const img = document.getElementById('imageViewerImg');
    const counter = document.getElementById('imageViewerCounter');
    
    if (img) {
        img.style.display = 'none';
        setTimeout(() => {
            img.src = allConversationImages[currentImageIndex].src;
            img.style.display = 'block';
        }, 150);
    }
    
    if (counter) {
        counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
    }
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Toggle conversation info grid
function toggleConversationInfoGrid() {
    const content = document.getElementById('conversationInfoGridContent');
    const icon = document.getElementById('toggleInfoGridIcon');
    if (!content || !icon) return;
    
    const isHidden = content.style.display === 'none';
    content.style.display = isHidden ? 'grid' : 'none';
    icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
}

// Make toggle function globally accessible
window.toggleConversationInfoGrid = toggleConversationInfoGrid;

// Display all conversation attributes in UI-friendly format
function displayConversationAttributes(conversation) {
    // Hide the old panels
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    if (chatPanel) chatPanel.style.display = 'none';
    if (textPanel) textPanel.style.display = 'none';
    
    // Show and populate the expanded info grid
    const infoGrid = document.getElementById('conversationInfoGrid');
    if (!infoGrid) return;
    
    const attributes = extractConversationAttributes(conversation);
    infoGrid.style.display = 'block';
    
    // Helper function to format value
    const formatValue = (key, value) => {
        if (value === null || value === undefined) return null;
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        
        // Handle URLs (for Web Link)
        if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
            const url = String(value);
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom →</a>`;
            }
        }
        
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (value.length === 0) return null;
                return value.map(item => {
                    if (typeof item === 'object') {
                        return Object.values(item).filter(v => v).join(' - ');
                    }
                    return String(item);
                }).join(', ');
            }
            return JSON.stringify(value, null, 2);
        }
        return String(value);
    };
    
    // Helper function to get icon and color for a key
    const getIconAndColor = (key) => {
        const iconMap = {
            'State': { icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z', color: '#1A733E' },
            'Priority': { icon: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z', color: '#f59e0b' },
            'Total Messages': { icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z', color: '#3b82f6' },
            'Time to Admin Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Assignment': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to First Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Last Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Median Time to Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Author Email': { icon: 'M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z', color: '#ec4899' },
            'Assigned To': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#10b981' },
            'Created At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Updated At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Rating': { icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z', color: '#f97316' },
            'Tags': { icon: 'M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z', color: '#06b6d4' },
            'User Messages': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#3b82f6' },
            'Admin Messages': { icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z', color: '#10b981' },
            'Reopens Count': { icon: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15', color: '#f59e0b' },
            'Assignments Count': { icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2', color: '#8b5cf6' }
        };
        
        return iconMap[key] || { icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', color: '#6b7280' };
    };
    
    // Helper function to create copy button
    const createCopyButton = (value, fieldName) => {
        if (!value) return '';
        return `
            <button onclick="event.stopPropagation(); navigator.clipboard.writeText('${escapeHtml(String(value))}').then(() => showNotification('${fieldName} copied!', 'success')).catch(() => showNotification('Failed to copy', 'error')); return false;" 
                style="padding: 0.0808rem; background: rgba(26, 115, 62, 0.1); border: none; border-radius: 0.1617rem; cursor: pointer; transition: all 0.2s; margin-left: 0.1617rem;"
                onmouseover="this.style.background='rgba(26, 115, 62, 0.2)';" onmouseout="this.style.background='rgba(26, 115, 62, 0.1)';"
                title="Copy ${fieldName}">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.3234rem; height: 0.3234rem; color: #1A733E;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
            </button>
        `;
    };
    
    let html = '';
    const gridContainer = document.getElementById('conversationInfoGridContent');
    if (!gridContainer) return;
    
    // Display ALL attributes
    Object.keys(attributes).forEach(key => {
        const value = formatValue(key, attributes[key]);
        if (!value) return;
        
        const label = formatLabelForAttribute(key);
        const { icon, color } = getIconAndColor(key);
        const needsCopyButton = key === 'Author Email' || key === 'Custom: Account Number (MT4/MT5)' || key === 'Conversation ID';
        const copyBtn = needsCopyButton ? createCopyButton(attributes[key], label) : '';
        
        html += `
            <div style="background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; padding: 0.3234rem; box-shadow: 0 0.0203rem 0.0606rem rgba(0,0,0,0.05); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 0.0405rem 0.1213rem rgba(0,0,0,0.1)'; this.style.borderColor='#1A733E';" onmouseout="this.style.boxShadow='0 0.0203rem 0.0606rem rgba(0,0,0,0.05)'; this.style.borderColor='#e5e7eb';">
                <div style="display: flex; align-items: center; gap: 0.2425rem; margin-bottom: 0.1617rem;">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; color: ${color}; flex-shrink: 0;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}"></path>
                    </svg>
                    <span style="font-size: 0.3639rem; font-weight: 600; color: #000000; text-transform: uppercase; letter-spacing: 0.0092rem;">${escapeHtml(label)}</span>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <span style="font-size: 0.4447rem; font-weight: 600; color: #1f2937; word-break: break-word; flex: 1;">${key.toLowerCase().includes('link') ? value : escapeHtml(String(value))}</span>
                    ${copyBtn}
                </div>
            </div>
        `;
    });
    
    gridContainer.innerHTML = html;
}

// Helper function to format label (used in both functions)
function formatLabelForAttribute(label) {
    return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Extract all relevant conversation attributes from Intercom API response
function extractConversationAttributes(conversation) {
    const attributes = {};
    
    // Helper function to convert Unix timestamp to readable date
    const formatTimestamp = (timestamp) => {
        if (!timestamp) return null;
        const date = typeof timestamp === 'number' 
            ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
            : new Date(timestamp);
        if (isNaN(date.getTime())) return null;
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    };
    
    // Basic Information
    if (conversation.id) attributes['Conversation ID'] = conversation.id;
    if (conversation.type) attributes['Type'] = conversation.type;
    if (conversation.state) attributes['State'] = conversation.state;
    if (conversation.read !== undefined) attributes['Read'] = conversation.read;
    if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
    if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
    if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
    
    // Source Information
    if (conversation.source) {
        if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
        if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
        if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
        if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
        
        // Author (who initiated)
        if (conversation.source.author) {
            const author = conversation.source.author;
            if (author.type) attributes['Author Type'] = author.type;
            if (author.id) attributes['Author ID'] = author.id;
            if (author.name) attributes['Author Name'] = author.name;
            if (author.email) attributes['Author Email'] = author.email;
        }
        
        // Owner (assigned to)
        if (conversation.source.owner) {
            const owner = conversation.source.owner;
            if (owner.type) attributes['Owner Type'] = owner.type;
            if (owner.id) attributes['Owner ID'] = owner.id;
            if (owner.name) attributes['Assigned To'] = owner.name;
            if (owner.email) attributes['Owner Email'] = owner.email;
        }
    }
    
    // Statistics
    if (conversation.statistics) {
        const stats = conversation.statistics;
        if (stats.time_to_assignment) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
        if (stats.time_to_admin_reply) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
        if (stats.time_to_first_close) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
        if (stats.time_to_last_close) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
        if (stats.median_time_to_reply) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
        if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
        if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
        if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
        if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
        if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
        if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
    }
    
    // Tags
    if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
        attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
    }
    
    // Teammates (participating admins)
    if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
        attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
            teammate.name || teammate.email || teammate.id
        ).join(', ');
    }
    
    // Contacts (users involved)
    if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
        const contacts = conversation.contacts.contacts.map(contact => {
            const parts = [];
            if (contact.name) parts.push(contact.name);
            if (contact.email) parts.push(contact.email);
            return parts.length > 0 ? parts.join(' - ') : contact.id;
        });
        attributes['Contacts'] = contacts.join(', ');
    }
    
    // Conversation Parts Summary
    if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
        const parts = conversation.conversation_parts.conversation_parts;
        attributes['Total Messages'] = parts.length;
    }
    
    // Custom Attributes (if present)
    if (conversation.source && conversation.source.custom && conversation.source.custom.length > 0) {
        conversation.source.custom.forEach(attr => {
            if (attr.value !== null && attr.value !== undefined && attr.value !== '') {
                attributes[attr.name || 'Custom Attribute'] = attr.value;
            }
        });
    }
    
    return attributes;
}

// Parse plain text transcript and render as chat bubbles (fallback if Intercom fetch fails)
function parseTranscriptToChat(transcriptText, interactionDate) {
    const chatContainer = document.getElementById('chatMessagesContainer');
    if (!chatContainer) return;
    
    if (!transcriptText || !transcriptText.trim()) {
        chatContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #000000; font-size: 0.5659rem;">
                <p>No transcript available</p>
            </div>
        `;
        return;
    }
    
    // Clear container
    chatContainer.innerHTML = '';
    
    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Parse transcript - try to detect user/agent messages
    // Common patterns:
    // - "User:" or "Customer:" at start of line
    // - "Agent:" or employee name at start of line
    // - Lines with timestamps
    // - Blank lines as separators
    
    const lines = transcriptText.split('\n').filter(line => line.trim());
    const messages = [];
    let currentMessage = null;
    
    // Use interaction date as base for timestamps
    const baseDate = interactionDate ? new Date(interactionDate) : new Date();
    
    // Build agent pattern with employee name if available
    const employeeName = currentAudit?.employeeName || '';
    const agentPatternStr = employeeName 
        ? `^(?:Agent|Support|Representative|${employeeName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}):\\s*(.*)`
        : '^(?:Agent|Support|Representative):\\s*(.*)';
    const agentPattern = new RegExp(agentPatternStr, 'i');
    
    lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
            // Empty line - end current message if exists
            if (currentMessage) {
                messages.push(currentMessage);
                currentMessage = null;
            }
            return;
        }
        
        // Try to detect message patterns
        const userPattern = /^(?:User|Customer|Client):\s*(.*)/i;
        const timestampPattern = /^(\d{1,2}[:\.]\d{2}(?:\s*[AP]M)?|\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/i;
        
        const userMatch = trimmedLine.match(userPattern);
        const agentMatch = trimmedLine.match(agentPattern);
        const timestampMatch = trimmedLine.match(timestampPattern);
        
        if (userMatch) {
            // Start new user message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: userMatch[1].trim(),
                isUser: true,
                author: 'User',
                timestamp: baseDate
            };
        } else if (agentMatch) {
            // Start new agent message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: agentMatch[1].trim(),
                isUser: false,
                author: currentAudit?.employeeName || 'Agent',
                timestamp: baseDate
            };
        } else if (timestampMatch && currentMessage) {
            // Timestamp found at start of line - could be new message or continuation
            // If timestamp is followed by text, it might be a new message
            const afterTimestamp = trimmedLine.substring(timestampMatch[0].length).trim();
            if (afterTimestamp && afterTimestamp.length > 5) {
                // Has substantial content after timestamp - likely new message
                if (currentMessage) messages.push(currentMessage);
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: afterTimestamp,
                    isUser: lastMessage ? !lastMessage.isUser : true,
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            } else {
                // Just timestamp, continue current message
                currentMessage.text += ' ' + trimmedLine;
            }
        } else {
            // Continue current message or start new one if none exists
            if (currentMessage) {
                // Check if line looks like a new speaker (common patterns)
                const looksLikeNewSpeaker = /^[-–—]\s/.test(trimmedLine) || 
                                           /^\[/.test(trimmedLine) ||
                                           trimmedLine.length < 20 && /^[A-Z][a-z]+:/.test(trimmedLine);
                
                if (looksLikeNewSpeaker && currentMessage.text.length > 50) {
                    // End current message and start new one
                    messages.push(currentMessage);
                    const lastMessage = messages[messages.length - 1];
                    currentMessage = {
                        text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                        isUser: lastMessage ? !lastMessage.isUser : true,
                        author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                        timestamp: baseDate
                    };
                } else {
                    currentMessage.text += (currentMessage.text ? '\n' : '') + trimmedLine;
                }
            } else {
                // Try to guess based on context - if previous message was user, this might be agent
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                    isUser: lastMessage ? !lastMessage.isUser : true, // Alternate or default to user
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            }
        }
        
        // Set timestamp for new messages
        if (currentMessage && (!currentMessage.timestamp || currentMessage.timestamp.getTime() === baseDate.getTime())) {
            currentMessage.timestamp = new Date(baseDate.getTime() + messages.length * 60000);
        }
    });
    
    // Add last message
    if (currentMessage) {
        messages.push(currentMessage);
    }
    
    // If no structured messages found, treat entire transcript as single message
    if (messages.length === 0) {
        messages.push({
            text: transcriptText,
            isUser: true,
            author: 'User',
            timestamp: baseDate
        });
    }
    
    // Render messages as chat bubbles
    messages.forEach((msg, index) => {
        const timeStr = msg.timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = msg.timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-bottom: 0.3234rem;
            align-items: ${msg.isUser ? 'flex-start' : 'flex-end'};
            width: 100%;
            min-width: 0;
            box-sizing: border-box;
        `;
        
        const bubbleStyle = msg.isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 75%;
                margin-right: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 75%;
                margin-left: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `;
        
        messageDiv.innerHTML = `
            <div style="${bubbleStyle} padding: 0.3234rem 0.4852rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08);">
                ${msg.isUser 
                    ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #000000;">User</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #000000; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` 
                    : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(msg.author)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                <div style="font-size: 0.5257rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%; box-sizing: border-box;">${escapeHtml(msg.text)}</div>
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
    });
    
    // Scroll to bottom
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Initialize resizable splitter
function initializeSplitter() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditMainContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        let startX = 0;
        let startLeftWidth = 0;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startLeftWidth = leftColumn.offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const containerWidth = containerRect.width;
            
            // Calculate new width based on delta
            let newLeftWidth = startLeftWidth + deltaX;
            
            // Convert to percentage with constraints
            let leftPercentage = (newLeftWidth / containerWidth) * 100;
            leftPercentage = Math.max(25, Math.min(75, leftPercentage));
            
            // Apply width and update right column
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('auditViewSplitterPosition', leftPercentage.toString());
            } catch (err) {
                // Ignore localStorage errors
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Restore saved position from localStorage
        try {
            const savedPosition = localStorage.getItem('auditViewSplitterPosition');
            if (savedPosition) {
                const percentage = parseFloat(savedPosition);
                if (!isNaN(percentage) && percentage >= 25 && percentage <= 75) {
                    leftColumn.style.width = percentage + '%';
                    leftColumn.style.flex = '0 0 ' + percentage + '%';
                }
            }
        } catch (err) {
            // Ignore localStorage errors
        }
    }
}

// Refresh audit data from database to get latest comments
async function refreshAuditData() {
    if (!currentAudit || !currentTableName) {
        return;
    }
    
    try {
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .select('parameter_comments')
            .eq('id', currentAudit.id)
            .single();
        
        if (error) throw error;
        
        if (data && data.parameter_comments) {
            // Update parameter comments in currentAudit
            currentAudit.parameterComments = data.parameter_comments;
            currentAudit.parameter_comments = data.parameter_comments;
        }
    } catch (error) {
        console.error('Error refreshing audit data:', error);
        // Don't throw - just log the error
    }
}

// Toggle reversal form visibility
function toggleReversalForm() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only submit reversal requests for audits assigned to you.');
        return;
    }
    
    const formContainer = document.getElementById('reversalFormContainer');
    const auditContentDiv = document.getElementById('auditContent');
    
    if (!formContainer) {
        console.error('Reversal form container not found');
        return;
    }
    
    if (!auditContentDiv) {
        console.error('Audit content div not found');
        return;
    }
    
    // Ensure form container is in the DOM (might have been removed during re-render)
    if (!formContainer.parentElement) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection) {
            buttonsSection.parentElement.insertBefore(formContainer, buttonsSection);
        } else {
            auditContentDiv.appendChild(formContainer);
        }
    }
    
    if (formContainer.style.display === 'none' || !formContainer.style.display) {
        formContainer.style.display = 'block';
        
        // Move form container to be before the action buttons if not already in auditContent
        if (auditContentDiv && formContainer.parentElement !== auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection) {
                buttonsSection.parentElement.insertBefore(formContainer, buttonsSection);
            } else {
                auditContentDiv.appendChild(formContainer);
            }
        }
        
        // Refresh audit data to get latest comments before populating
        refreshAuditData().then(() => {
            // Populate parameters with comments after refresh
        populateParametersWithComments();
        }).catch(err => {
            console.error('Error refreshing audit data:', err);
            // Still try to populate with existing data
            populateParametersWithComments();
        });
        
        formContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } else {
        formContainer.style.display = 'none';
    }
}

// Make toggleReversalForm globally accessible
window.toggleReversalForm = toggleReversalForm;

// Populate parameters with comments (compact display)
function populateParametersWithComments() {
    const container = document.getElementById('parametersWithCommentsContainer');
    const noCommentsMsg = document.getElementById('noCommentsMessage');
    
    if (!container) return;
    
    if (currentErrorFields.length === 0) {
        container.innerHTML = '<p style="margin: 0; font-size: 0.5625rem; color: #000000; font-family: \'Poppins\', sans-serif;">No parameters available</p>';
        return;
    }
    
    // Get parameter comments from database (from currentAudit - which is updated in real-time)
    let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    
    // Also check inline comment inputs in the DOM (real-time fallback - takes precedence)
    const inlineComments = {};
    currentErrorFields.forEach(field => {
        const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
        const comments = [];
        commentInputs.forEach(input => {
            if (input.value && input.value.trim()) {
                comments.push(input.value.trim());
            }
        });
        if (comments.length > 0) {
            // Always use inline comments if they exist (most up-to-date)
            inlineComments[field.key] = { comments: comments };
        }
    });
    
    // Merge: Start with database comments, then override with inline comments (which are more up-to-date)
    parameterComments = { ...parameterComments };
    // Override with inline comments if they exist (they're more current)
    Object.keys(inlineComments).forEach(key => {
        parameterComments[key] = inlineComments[key];
    });
    
    // Filter only parameters that have comments (check both formats)
    const parametersWithComments = currentErrorFields.filter(field => {
        const fieldComment = parameterComments[field.key];
        if (!fieldComment) return false;
        
        // Check for single comment format: {comment: "text"}
        if (fieldComment.comment && fieldComment.comment.trim()) {
            return true;
        }
        
        // Check for array format: {comments: ["text1", "text2"]}
        if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            return fieldComment.comments.some(c => c && c.trim());
        }
        
        return false;
    });
    
    if (parametersWithComments.length === 0) {
        container.style.display = 'none';
        if (noCommentsMsg) {
            noCommentsMsg.style.display = 'block';
        }
        return;
    }
    
    if (noCommentsMsg) {
        noCommentsMsg.style.display = 'none';
    }
    container.style.display = 'block';
    
    // Create compact list of parameters with comments
    const commentsHtml = parametersWithComments.map(field => {
        const fieldComment = parameterComments[field.key];
        let commentText = '';
        
        // Get comment text (handle both formats)
        if (fieldComment.comment && fieldComment.comment.trim()) {
            commentText = fieldComment.comment.trim();
        } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            // Join all comments with newlines, filter out empty ones, trim each comment, then trim the result
            commentText = fieldComment.comments
                .filter(c => c && c.trim())
                .map(c => c.trim())
                .join('\n')
                .trim();
        }
        
        // Ensure commentText is trimmed to remove leading/trailing whitespace
        commentText = commentText ? commentText.trim() : '';
        
        return `
            <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.6094rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(field.label)}
        </div>
                <div style="font-size: 0.5625rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(commentText)}
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = commentsHtml;
}

// Handle close button click - check acknowledgement before closing
async function handleCloseButtonClick() {
    const canNavigate = await handleCloseAuditView();
    if (canNavigate) {
        window.location.href = 'audit-reports.html';
    }
}

// Make handleCloseButtonClick globally accessible
window.handleCloseButtonClick = handleCloseButtonClick;

// Show parameter comment modal
function showParameterCommentModal(fieldId, fieldLabel, auditorFeedback) {
    if (!isCurrentUserAuditedEmployee()) {
        alert('Only the audited employee can add comments.');
        return;
    }
    
    // Get existing comment for this parameter
    const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    const existingComment = parameterComments[fieldId] || null;
    const hasComment = existingComment && existingComment.comment && existingComment.comment.trim();
    
    // Create modal overlay
    const modal = document.createElement('div');
    modal.id = 'parameterCommentModal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 1.125rem;';
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 0.375rem; padding: 1.125rem; max-width: 37.5rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.25rem 0.375rem rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <h3 style="font-size: 0.8438rem; font-weight: 700; color: #1f2937; margin: 0; font-family: 'Poppins', sans-serif;">
                    Add Your Comment - ${escapeHtml(fieldLabel)}
                </h3>
                <button onclick="closeParameterCommentModal()" style="background: none; border: none; font-size: 1.5rem; color: #000000; cursor: pointer; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
            </div>
            
            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9fafb; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.5625rem; font-weight: 600; color: #000000; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                    Auditor Feedback
                </div>
                <div style="font-size: 0.6562rem; color: #374151; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(auditorFeedback)}
                </div>
            </div>
            
            ${hasComment ? `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 0.2812rem; border: 0.0352rem solid #bae6fd;">
                    <div style="font-size: 0.5625rem; font-weight: 600; color: #0369a1; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Your Previous Comment
                    </div>
                    <div style="font-size: 0.6562rem; color: #075985; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: 0.375rem;">
                        ${escapeHtml(existingComment.comment)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #0284c7; font-family: 'Poppins', sans-serif;">
                        ${existingComment.commented_at ? new Date(existingComment.commented_at).toLocaleString() : ''}
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 0.75rem;">
                <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    Your Comment / Justification
                </label>
                <textarea 
                    id="modalCommentInput_${fieldId}" 
                    placeholder="Provide your justification or response to the auditor's feedback..." 
                    rows="6"
                    style="width: 100%; padding: 0.75rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; background: white; box-sizing: border-box;"
                >${hasComment ? escapeHtml(existingComment.comment) : ''}</textarea>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem;">
                <button 
                    onclick="closeParameterCommentModal()" 
                    style="padding: 0.5625rem 1.125rem; background: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    Cancel
                </button>
                <button 
                    onclick="saveParameterCommentFromModal('${fieldId}')" 
                    style="padding: 0.5625rem 1.125rem; background: #1A733E; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    ${hasComment ? 'Update' : 'Save'} Comment
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus the textarea
    setTimeout(() => {
        const textarea = document.getElementById(`modalCommentInput_${fieldId}`);
        if (textarea) {
            textarea.focus();
        }
    }, 100);
    
    // Close on overlay click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeParameterCommentModal();
        }
    });
}

// Close parameter comment modal
function closeParameterCommentModal() {
    const modal = document.getElementById('parameterCommentModal');
    if (modal) {
        modal.remove();
    }
}

// Save parameter comment from modal
async function saveParameterCommentFromModal(fieldId) {
    try {
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if audit is acknowledged - lock everything
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('Comments cannot be edited after the audit has been acknowledged.');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        const commentInput = document.getElementById(`modalCommentInput_${fieldId}`);
        if (!commentInput) {
            alert('Error: Comment input not found');
            return;
        }
        
        const commentText = commentInput.value.trim();
        if (!commentText) {
            alert('Please enter a comment before saving.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Update comment for this parameter
        const updatedComments = {
            ...currentComments,
            [fieldId]: {
                comment: commentText,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Save to database
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update({
                parameter_comments: updatedComments
            })
            .eq('id', currentAudit.id)
            .select();
        
        if (error) throw error;
        
        // Update local audit object
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Close modal
        closeParameterCommentModal();
        
        // Reload audit to refresh the error details table with comments column
        await loadAuditFromURL();
        
        // Update reversal form if it's open (after reload)
        const reversalFormContainer = document.getElementById('reversalFormContainer');
        if (reversalFormContainer && reversalFormContainer.style.display !== 'none') {
            populateParametersWithComments();
        }
        
    } catch (error) {
        console.error('Error saving parameter comment:', error);
        alert('Failed to save comment. Please try again.');
    }
}

// Toggle comments column visibility
function toggleCommentsColumn() {
    if (typeof window.showCommentsColumn === 'undefined') {
        window.showCommentsColumn = false;
    }
    window.showCommentsColumn = !window.showCommentsColumn;
    
    // Update the existing table header and rows without recreating the container
    if (currentAudit && currentErrorFields) {
        // Find the table header row within the Error Details section
        const errorDetailsSection = Array.from(document.querySelectorAll('div')).find(div => {
            const h3 = div.querySelector('h3');
            return h3 && h3.textContent && h3.textContent.includes('Error Details');
        });
        
        if (!errorDetailsSection) return;
        
        // Find header row within the error details section
        const headerRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            const text = div.textContent || '';
            return text.includes('Error Type') && text.includes('Points') && text.includes('Severity');
        });
        
        if (headerRows.length === 0) return;
        
        const header = headerRows[0];
        const showComments = window.showCommentsColumn;
        
        // Get employee first name for column header
        const employeeName = currentAudit.employeeName || currentAudit.employee_name || 'Employee';
        const firstName = employeeName.split(' ')[0] || employeeName;
        const commentColumnHeader = `${firstName}'s Comment`;
        
        // Check if user is audited employee
        const isAuditedEmployee = isCurrentUserAuditedEmployee();
        
        // Update grid columns
        if (showComments) {
            header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
            // Find the "+ Comment" header cell (last child) and replace with actual column header
            const lastHeader = header.lastElementChild;
            if (lastHeader) {
                lastHeader.innerHTML = escapeHtml(commentColumnHeader);
                lastHeader.style.cursor = 'default';
                lastHeader.style.color = '#1f2937';
                lastHeader.style.textDecoration = 'none';
                lastHeader.removeAttribute('onclick');
            } else if (header.children.length === 5) {
                // Add new header cell if it doesn't exist
                const commentHeaderCell = document.createElement('div');
                commentHeaderCell.textContent = commentColumnHeader;
                commentHeaderCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;';
                header.appendChild(commentHeaderCell);
            }
        } else {
            // When hiding comments, keep 6 columns if audited employee (to show + Comment button)
            if (isAuditedEmployee) {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                // Find the comment column header and replace with "+ Comment" button
                const lastHeader = header.lastElementChild;
                if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment"))) {
                    lastHeader.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    lastHeader.style.cursor = 'pointer';
                } else if (header.children.length === 5) {
                    // Add "+ Comment" button if it doesn't exist
                    const commentButtonCell = document.createElement('div');
                    commentButtonCell.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    commentButtonCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1A733E; text-transform: uppercase; letter-spacing: 0.05em;';
                    header.appendChild(commentButtonCell);
                }
            } else {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                // Remove comment column if not audited employee
                if (header.children.length === 6) {
                    const lastHeader = header.lastElementChild;
                    if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment") || lastHeader.textContent.includes("+ Comment"))) {
                        lastHeader.remove();
                    }
                }
            }
        }
        
        // Update all data rows within the error details section
        const dataRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            return div !== header && div.style.display === 'grid' && !div.textContent.includes('Error Type');
        });
        
        dataRows.forEach(row => {
            if (showComments) {
                // Add comment column if not present
                if (row.children.length === 5 || row.children.length === 6) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
                    // Remove existing comment column if present (to refresh it)
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.remove();
                        }
                    }
                    
                    // Get the field key from the row (first child text)
                    const firstCell = row.children[0];
                    const fieldLabel = firstCell.textContent.trim();
                    
                    // Find matching field
                    const field = currentErrorFields.find(f => f.label === fieldLabel);
                    if (field) {
                        // Get feedback data
                        const feedbackData = currentAudit[field.feedback];
                        let feedbackArray = [];
                        
                        if (feedbackData) {
                            if (typeof feedbackData === 'string') {
                                try {
                                    const parsed = JSON.parse(feedbackData);
                                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                } catch (e) {
                                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                }
                            } else if (Array.isArray(feedbackData)) {
                                feedbackArray = feedbackData;
                            }
                        }
                        feedbackArray = feedbackArray.filter(f => f && f.trim());
                        
                        // Get existing comments
                        const parameterComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
                        const existingComments = parameterComments[field.key] || {};
                        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
                        const isAuditedEmployee = isCurrentUserAuditedEmployee();
                        
                        // Check if reversal has been submitted (disable inputs if so)
                        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                        const hasReversalSubmitted = !!reversalRequestedAt;
                        
                        // Create comment column
                        const commentCell = document.createElement('div');
                        commentCell.style.cssText = 'font-size: 0.5659rem; color: #000000; font-family: Poppins, sans-serif; min-width: 0; overflow: hidden;';
                        
                        if (feedbackArray.length > 0) {
                            feedbackArray.forEach((feedbackText, index) => {
                                const existingComment = commentsArray[index] || '';
                                const commentInputId = `comment_${field.key}_${index}`;
                                const commentDiv = document.createElement('div');
                                commentDiv.style.marginBottom = index < feedbackArray.length - 1 ? '0.6469rem' : '0';
                                
                                if (feedbackArray.length > 1) {
                                    const label = document.createElement('div');
                                    label.textContent = `Comment ${index + 1}:`;
                                    label.style.cssText = 'font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: Poppins, sans-serif;';
                                    commentDiv.appendChild(label);
                                }
                                
                                // For auditors (non-audited employees) or after reversal submitted, show as read-only text
                                if (!isAuditedEmployee || hasReversalSubmitted) {
                                    if (existingComment && existingComment.trim()) {
                                        const textDiv = document.createElement('div');
                                        textDiv.textContent = existingComment;
                                        textDiv.style.cssText = 'font-size: 0.5659rem; color: #000000; font-family: Poppins, sans-serif; white-space: pre-wrap; line-height: 1.6;';
                                        commentDiv.appendChild(textDiv);
                                    } else {
                                        const dash = document.createElement('span');
                                        dash.textContent = '-';
                                        dash.style.cssText = 'color: #000000; font-style: italic; font-size: 0.5659rem;';
                                        commentDiv.appendChild(dash);
                                    }
                                } else {
                                    // For audited employees (before reversal), show input box
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.id = commentInputId;
                                    input.setAttribute('data-param-key', field.key);
                                    input.setAttribute('data-feedback-index', index);
                                    input.value = existingComment;
                                    input.placeholder = 'Enter your comment...';
                                    input.style.cssText = 'width: 100%; max-width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: Poppins, sans-serif; box-sizing: border-box;';
                                    // Save on both change and blur for real-time saving
                                    input.addEventListener('change', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    input.addEventListener('blur', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    commentDiv.appendChild(input);
                                }
                                
                                commentCell.appendChild(commentDiv);
                            });
                        } else {
                            const dash = document.createElement('span');
                            dash.textContent = '-';
                            dash.style.cssText = 'color: #000000; font-style: italic;';
                            commentCell.appendChild(dash);
                        }
                        
                        row.appendChild(commentCell);
                    }
                }
            } else {
                // When hiding comments, keep 6 columns if audited employee (to match header with + Comment button)
                // Remove comment inputs but keep empty 6th column for alignment
                if (isAuditedEmployee) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.innerHTML = '';
                        }
                    } else if (row.children.length === 5) {
                        // Add empty column for alignment with header
                        const emptyCell = document.createElement('div');
                        row.appendChild(emptyCell);
                    }
                } else {
                    // Remove comment column if not audited employee
                    if (row.children.length === 6) {
                        row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                        const lastCell = row.lastElementChild;
                        if (lastCell) {
                            lastCell.remove();
                        }
                    }
                }
            }
        });
    }
}

// Save parameter comment from input box
async function saveParameterComment(paramKey, feedbackIndex, commentText) {
    try {
        // Ensure currentUserEmail is available
        if (!currentUserEmail) {
            currentUserEmail = getCurrentUserEmail();
        }
        
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if audit is acknowledged - lock everything
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('Comments cannot be edited after the audit has been acknowledged.');
            return;
        }
        
        // Check if reversal has been submitted
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        const workflowState = getReversalWorkflowState(currentAudit);
        
        if (!currentUserEmail) {
            alert('Error: User email not available. Please refresh the page.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Get existing comments array for this parameter or create new structure
        const paramComments = currentComments[paramKey] || {};
        const commentsArray = paramComments.comments || (paramComments.comment ? [paramComments.comment] : []);
        
        // For second reversal: allow adding NEW comments, but preserve old ones as history
        // Check if this is a second reversal scenario
        const isSecondReversal = workflowState === 'team_lead_rejected' || workflowState === 'cqc_sent_back' || workflowState === 'agent_re_review';
        const isFinalState = workflowState === 'approved' || workflowState === 'rejected' || workflowState === 'acknowledged';
        
        if (reversalRequestedAt) {
            // If editing an existing comment (not adding a new one)
            if (feedbackIndex < commentsArray.length && commentsArray[feedbackIndex] && commentsArray[feedbackIndex].trim()) {
                // Editing existing comment - only allow if it's a second reversal
                if (!isSecondReversal) {
                    alert('Existing comments cannot be edited after a reversal request has been submitted. For a second reversal, you can add new comments (they will be different from previous ones).');
                    return;
                }
            }
            // If adding a new comment (at end of array or new index), allow it for second reversal
            // But prevent if it's a final state (approved/rejected/acknowledged)
            if (isFinalState && !isSecondReversal) {
                alert('Comments cannot be added after a reversal request has been processed.');
                return;
            }
        }
        
        // Ensure array is large enough
        while (commentsArray.length <= feedbackIndex) {
            commentsArray.push('');
        }
        
        // For second reversal: append new comment instead of replacing
        // This keeps old comments as historical record
        if (isSecondReversal && feedbackIndex >= commentsArray.length - 1 && commentText.trim()) {
            // Adding a new comment - append it
            commentsArray.push(commentText.trim());
        } else {
            // Update the comment at the specific index (normal flow or editing in second reversal)
        commentsArray[feedbackIndex] = commentText.trim();
        }
        
        // Update comment for this parameter
        const updatedComments = {
            ...currentComments,
            [paramKey]: {
                comments: commentsArray,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Save to database
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update({
                parameter_comments: updatedComments
            })
            .eq('id', currentAudit.id)
            .select();
        
        if (error) {
            console.error('Supabase error:', error);
            throw error;
        }
        
        // Update local audit object immediately (for real-time validation)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Optional: Show a subtle success indicator (non-intrusive)
        const input = document.getElementById(`comment_${paramKey}_${feedbackIndex}`);
        if (input) {
            const originalBorder = input.style.borderColor;
            input.style.borderColor = '#10b981';
            setTimeout(() => {
                input.style.borderColor = originalBorder || '#d1d5db';
            }, 500);
        }
        
        // Immediately update the reversal form display if it's open
        const reversalFormContainer = document.getElementById('reversalFormContainer');
        if (reversalFormContainer && reversalFormContainer.style.display !== 'none') {
            populateParametersWithComments();
        }
        
    } catch (error) {
        console.error('Error saving parameter comment:', error);
        // Don't show alert for every failed save - just log it
        // User can try again if needed
        console.warn('Comment save failed, will retry on next change');
    }
}

// Make functions globally accessible
window.showParameterCommentModal = showParameterCommentModal;
window.closeParameterCommentModal = closeParameterCommentModal;
window.saveParameterCommentFromModal = saveParameterCommentFromModal;
window.toggleCommentsColumn = toggleCommentsColumn;
window.saveParameterComment = saveParameterComment;

// Acknowledge audit
async function acknowledgeAudit() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only acknowledge audits assigned to you.');
        return;
    }
    
    // Wait for confirmation dialog to be available
    if (!window.confirmationDialog) {
        // Wait a bit for it to initialize
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!window.confirmationDialog) {
            alert('Error: Confirmation dialog not available. Please refresh the page.');
            return;
        }
    }
    
    const result = await window.confirmationDialog.show({
        title: 'Acknowledge Audit',
        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
        confirmText: 'Acknowledge',
        cancelText: 'Cancel'
    });
    
    if (result) {
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        try {
            // Get current acknowledgement status
            const currentAcknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
            const currentStatusLower = currentAcknowledgementStatus.toLowerCase();
            
            // Check if reversal was processed (approved or rejected)
            const reversalApproved = currentAudit.reversal_approved;
            const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
            const hasReversalBeenProcessed = reversalRespondedAt && (reversalApproved === true || reversalApproved === false);
            
            // Determine acknowledgement status based on current status
            let acknowledgementStatus = 'Acknowledged';
            
            // If current status is "pending - after reversal approved/rejected", change to acknowledged version
            if (currentStatusLower === 'pending - after reversal approved') {
                acknowledgementStatus = 'acknowledged - after reversal approved';
            } else if (currentStatusLower === 'pending - after reversal rejected') {
                acknowledgementStatus = 'acknowledged - after reversal rejected';
            }
            // If no reversal was processed, status remains "Acknowledged"
            
            // Record acknowledgment in the database with correct fields
            const acknowledgementTime = new Date().toISOString();
            const { data, error } = await window.supabaseClient
                .from(currentTableName)
                .update({
                    acknowledgement_status: acknowledgementStatus,
                    acknowledgement_status_updated_at: acknowledgementTime
                })
                .eq('id', currentAudit.id)
                .select();
            
            if (error) throw error;
            
            // Show success message
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Success',
                    message: '✓ Audit acknowledged. Thank you for your confirmation.',
                    confirmText: 'OK',
                    type: 'success'
                });
            } else {
            alert('✓ Audit acknowledged. Thank you for your confirmation.');
            }
            
            // Reload audit data to reflect changes
            loadAuditFromURL();
            
        } catch (error) {
            console.error('Error acknowledging audit:', error);
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Error',
                    message: 'Failed to record acknowledgment. Please try again.',
                    confirmText: 'OK',
                    type: 'error'
                });
            } else {
            alert('Failed to record acknowledgment. Please try again.');
            }
        }
    }
}

// Highlight empty comment fields and provide visual guidance
function highlightEmptyCommentFields() {
    // Find all comment input fields
    const allCommentInputs = document.querySelectorAll('input[data-param-key]');
    const emptyInputs = [];
    
    // Check which inputs are empty
    allCommentInputs.forEach(input => {
        if (!input.value || !input.value.trim()) {
            emptyInputs.push(input);
            // Highlight with red border and background
            input.style.borderColor = '#ef4444';
            input.style.borderWidth = '2px';
            input.style.backgroundColor = '#fef2f2';
            input.style.boxShadow = '0 0 0 3px rgba(239, 68, 68, 0.1)';
            
            // Add focus event to remove highlighting when user starts typing
            const removeHighlight = () => {
                input.style.borderColor = '#d1d5db';
                input.style.borderWidth = '1px';
                input.style.backgroundColor = '';
                input.style.boxShadow = '';
                input.removeEventListener('input', removeHighlight);
                input.removeEventListener('focus', removeHighlight);
            };
            input.addEventListener('input', removeHighlight);
            input.addEventListener('focus', removeHighlight);
        }
    });
    
    // Scroll to the first empty field
    if (emptyInputs.length > 0) {
        const firstEmptyInput = emptyInputs[0];
        firstEmptyInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Focus the first empty input after a short delay
        setTimeout(() => {
            firstEmptyInput.focus();
        }, 300);
    }
    
    // Show a message in the reversal form area
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    if (reversalFormContainer) {
        // Remove any existing validation message
        const existingMessage = reversalFormContainer.querySelector('.validation-message');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        // Create and show validation message
        const messageDiv = document.createElement('div');
        messageDiv.className = 'validation-message';
        messageDiv.style.cssText = `
            background-color: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 0.2812rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            color: #991b1b;
            font-size: 0.6094rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        `;
        messageDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <svg style="width: 1rem; height: 1rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="8" x2="12" y2="12"/>
                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                </svg>
                <span>At least one parameter comment is required. Please add comments to the highlighted fields in the Error Details section above.</span>
            </div>
        `;
        
        // Insert message at the top of the form
        const form = document.getElementById('reversalForm');
        if (form) {
            reversalFormContainer.insertBefore(messageDiv, form);
        } else {
            reversalFormContainer.insertBefore(messageDiv, reversalFormContainer.firstChild);
        }
        
        // Scroll to the message
        messageDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

// Handle reversal form submission
document.addEventListener('DOMContentLoaded', function() {
    const reversalForm = document.getElementById('reversalForm');
    if (reversalForm) {
        reversalForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Verify that current user is the audited employee
            if (!isCurrentUserAuditedEmployee()) {
                alert('Error: You can only submit reversal requests for audits assigned to you.');
                return;
            }
            
            if (!currentAudit || !currentTableName) {
                alert('Error: Audit data not available');
                return;
            }
            
            // Check if Supabase client is initialized
            if (!window.supabaseClient) {
                alert('Error: Database connection not available. Please refresh the page and try again.');
                return;
            }
            
            // Validate required fields
            const reversalType = document.getElementById('reversalType').value;
            const reversalReason = document.getElementById('reversalReasonDropdown').value;
            
            if (!reversalType || !reversalReason) {
                alert('Please fill in all required fields (marked with *)');
                return;
            }
            
            // Get all parameters with comments (automatically included)
            // First, check database comments (from currentAudit - which is updated in real-time)
            let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
            
            // Also check inline comment inputs in the DOM (real-time fallback - takes precedence)
            const inlineComments = {};
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    if (input.value && input.value.trim()) {
                        comments.push(input.value.trim());
                    }
                });
                if (comments.length > 0) {
                    // Always use inline comments if they exist (most up-to-date)
                    inlineComments[field.key] = { comments: comments };
                }
            });
            
            // Merge: Start with database comments, then override with inline comments (which are more up-to-date)
            parameterComments = { ...parameterComments };
            // Override with inline comments if they exist (they're more current)
            Object.keys(inlineComments).forEach(key => {
                parameterComments[key] = inlineComments[key];
            });
            
            // Find all parameters that have comments (check both formats)
            const parametersWithComments = currentErrorFields.filter(field => {
                const fieldComment = parameterComments[field.key];
                if (!fieldComment) return false;
                
                // Check for single comment format: {comment: "text"}
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    return true;
                }
                
                // Check for array format: {comments: ["text1", "text2"]}
                if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    return fieldComment.comments.some(c => c && c.trim());
                }
                
                return false;
            });
            
            if (parametersWithComments.length === 0) {
                // Highlight all empty comment fields and scroll to the first one
                highlightEmptyCommentFields();
                e.preventDefault(); // Explicitly prevent form submission
                return false;
            }
            
            // Build justification from parameter comments
            const selectedParameters = [];
            const justificationParts = [];
            
            parametersWithComments.forEach(field => {
                const fieldComment = parameterComments[field.key];
                let commentText = '';
                
                // Get comment text (handle both formats)
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    commentText = fieldComment.comment.trim();
                } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    // Join all comments with newlines
                    commentText = fieldComment.comments.filter(c => c && c.trim()).join('\n');
                }
                
                if (commentText) {
                selectedParameters.push(field.label);
                    justificationParts.push(`${field.label}: ${commentText}`);
                }
            });
            
            const detailedJustification = justificationParts.join('\n\n');
            
            // Capture FULL audit state BEFORE updating (for activity log)
            const fullAuditState = {
                parameters: {},
                feedback: {},
                score: currentAudit.average_score || currentAudit.averageScore || 0,
                passing_status: currentAudit.passing_status || currentAudit.passingStatus || '',
                acknowledgement_status: currentAudit.acknowledgement_status || currentAudit.acknowledgementStatus || '',
                // Capture all other relevant audit fields
                audited_employee_email: currentAudit.audited_employee_email || currentAudit.auditedEmployeeEmail || null,
                auditor_email: currentAudit.auditor_email || currentAudit.auditorEmail || null,
                conversation_id: currentAudit.conversation_id || currentAudit.conversationId || null
            };
            
            // Capture all parameter values
            if (currentErrorFields && currentErrorFields.length > 0) {
                currentErrorFields.forEach(field => {
                    const fieldKey = field.key;
                    const value = currentAudit[fieldKey] || 0;
                    fullAuditState.parameters[fieldKey] = value;
                    
                    // Capture feedback
                    const feedbackKey = `feedback_${fieldKey}`;
                    const feedbackValue = currentAudit[feedbackKey] || null;
                    fullAuditState.feedback[fieldKey] = feedbackValue;
                });
            }
            
            // Get user info for activity log
            const userInfo = getCurrentUserInfo();
            const logUserEmail = userInfo?.email || '';
            const logUserName = userInfo?.name || userInfo?.email || 'Unknown';
            
            // Gather form data - use column names that match the database schema
            // Based on actual schema: fnchat_cfd table does NOT have reversal_status column
            // Status is tracked via reversal_approved and reversal_responded_at fields
            // Check if team lead approval is required (feature flag)
            const requireTeamLeadApproval = await checkTeamLeadApprovalRequired();
            
            // New workflow: Set initial state based on feature flag
            // Check if this is a resubmission after CQC send-back
            const currentWorkflowState = getReversalWorkflowState(currentAudit);
            const isResubmission = currentWorkflowState === 'cqc_sent_back' || currentWorkflowState === 'agent_re_review';
            
            // Determine initial workflow state based on feature flag
            const initialWorkflowState = requireTeamLeadApproval 
                ? 'pending - team_lead_review'  // Go through Team Lead first
                : 'pending - qa_review';        // Skip Team Lead, go directly to QC
            
            const reversalData = {
                reversal_requested_at: isResubmission ? currentAudit.reversal_requested_at : new Date().toISOString(), // Keep original timestamp on resubmission
                reversal_type: reversalType,
                // Combine reversal reason and detailed justification from parameter comments
                reversal_justification_from_agent: `${reversalReason}: ${detailedJustification}`,
                reversal_metrics_parameters: selectedParameters.join(', ') || null,
                // within_auditor_scope is now set by auditor during processing, not by agent
                score_before_appeal: currentAudit.average_score || currentAudit.averageScore || null,
                // Save parameter comments to database when reversal is submitted
                parameter_comments: parameterComments,
                // Set workflow state: Based on feature flag (team lead approval required or not)
                acknowledgement_status: initialWorkflowState,
                acknowledgement_status_updated_at: new Date().toISOString(),
                // Clear previous review data on resubmission
                reversal_approved_by: null,
                // reversal_resolved_by is deprecated - cleared in reversal_requests instead
                reversal_responded_at: null,
                reversal_approved: null
                // Note: reversal_status column doesn't exist in the schema
                // Status is determined by acknowledgement_status workflow state
                // reversal_responded_at is null until final decision
            };
            
            // Don't set reversal_approved and reversal_responded_at to null explicitly
            // They will remain null by default if not set
            
            // Helper function to retry database operations on schema cache errors
            async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    if (attempt > 0) {
                        // Wait longer on each retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const result = await operation();
                    
                    // If no error, return success
                    if (!result.error) {
                        return result;
                    }
                    
                    // If it's a schema cache error, retry
                    if (result.error.message && (
                        result.error.message.includes('schema cache') ||
                        result.error.message.includes('Could not find') ||
                        result.error.message.includes('column') && result.error.message.includes('schema cache')
                    )) {
                        continue;
                    }
                    
                    // If it's not a schema cache error, return immediately
                    return result;
                }
                
                // Return last result after all retries exhausted
                return await operation();
            }
            
            try {
                // FIRST: Log the original state to activity log BEFORE updating
                try {
                    const activityLogData = {
                        audit_id: currentAudit.id,
                        scorecard_table_name: currentTableName,
                        activity_type: 'reversal_requested',
                        activity_timestamp: new Date().toISOString(),
                        performed_by_email: logUserEmail,
                        performed_by_name: logUserName,
                        audit_state_snapshot: fullAuditState,
                        parameters_snapshot: fullAuditState.parameters,
                        feedback_snapshot: fullAuditState.feedback,
                        score_snapshot: fullAuditState.score,
                        passing_status_snapshot: fullAuditState.passing_status,
                        reversal_type: reversalType,
                        reversal_justification: `${reversalReason}: ${detailedJustification}`,
                        change_reason: 'Reversal requested by audited employee',
                        metadata: {
                            reversal_metrics_parameters: selectedParameters,
                            within_auditor_scope: document.getElementById('withinAuditorScope').checked,
                            parameter_comments: parameterComments
                        }
                    };
                    
                    const { error: logError } = await window.supabaseClient
                        .from('audit_activity_log')
                        .insert(activityLogData);
                    
                    if (logError) {
                        console.error('Error logging reversal request to activity log:', logError);
                        // Don't throw - continue with reversal submission even if logging fails
                    } else {
                        console.log('Successfully logged reversal request to activity log');
                    }
                } catch (logErr) {
                    console.error('Error creating activity log entry:', logErr);
                    // Don't throw - continue with reversal submission
                }
                
                // ALSO: Create reversal_requests record (new structure)
                try {
                    // Check if reversal_requests record already exists (for resubmissions)
                    const { data: existingReversalRequest } = await window.supabaseClient
                        .from('reversal_requests')
                        .select('id')
                        .eq('audit_id', currentAudit.id)
                        .eq('scorecard_table_name', currentTableName)
                        .maybeSingle();
                    
                    if (!existingReversalRequest) {
                        // Create new reversal_requests record
                        const reversalRequestData = {
                            audit_id: currentAudit.id,
                            scorecard_table_name: currentTableName,
                            requested_at: isResubmission ? currentAudit.reversal_requested_at : new Date().toISOString(),
                            requested_by_email: logUserEmail,
                            requested_by_name: logUserName,
                            reversal_type: reversalType,
                            justification: `${reversalReason}: ${detailedJustification}`,
                            metrics_parameters: selectedParameters.join(', ') || null,
                            attachments: null, // Can be added later if needed
                            original_score: currentAudit.average_score || currentAudit.averageScore || 0,
                            original_passing_status: currentAudit.passing_status || currentAudit.passingStatus || 'Not Passing',
                            original_parameters: fullAuditState.parameters, // Store actual parameter values, not parameter_comments!
                            original_feedback: fullAuditState.feedback,
                            within_auditor_scope: document.getElementById('withinAuditorScope')?.checked || false,
                            sla_hours: null // Will be calculated during processing
                        };
                        
                        const { data: newReversalRequest, error: rrError } = await window.supabaseClient
                            .from('reversal_requests')
                            .insert(reversalRequestData)
                            .select()
                            .single();
                        
                        if (rrError) {
                            console.error('Error creating reversal_requests record:', rrError);
                            // Don't throw - continue with reversal submission
                        } else {
                            console.log('Successfully created reversal_requests record:', newReversalRequest.id);
                            
                            // Create initial workflow state based on feature flag
                            const initialState = requireTeamLeadApproval ? 'submitted' : 'qa_review';
                            const { data: workflowState, error: wsError } = await window.supabaseClient
                                .from('reversal_workflow_states')
                                .insert({
                                    reversal_request_id: newReversalRequest.id,
                                    state: initialState,
                                    entered_at: newReversalRequest.requested_at,
                                    entered_by_email: logUserEmail,
                                    entered_by_name: logUserName,
                                    notes: requireTeamLeadApproval 
                                        ? 'Reversal requested by agent - awaiting Team Lead review'
                                        : 'Reversal requested by agent - sent directly to QC review',
                                    is_current: true
                                })
                                .select()
                                .single();
                            
                            if (!wsError && workflowState) {
                                // Update reversal_request to point to current state
                                await window.supabaseClient
                                    .from('reversal_requests')
                                    .update({ current_state_id: workflowState.id })
                                    .eq('id', newReversalRequest.id);
                            }
                        }
                    } else {
                        console.log('Reversal_requests record already exists, skipping creation');
                    }
                } catch (rrErr) {
                    console.error('Error creating reversal_requests record:', rrErr);
                    // Don't throw - continue with reversal submission
                }
                
                // THEN: Update the audit record with reversal data
                // First, try with parameter_comments included
                let result = await retryOnSchemaCacheError(async () => {
                    return await window.supabaseClient
                        .from(currentTableName)
                        .update(reversalData)
                        .eq('id', currentAudit.id)
                        .select();
                });
                
                let data = result.data;
                let error = result.error;
                
                // If error is specifically about parameter_comments column not existing, retry without it
                if (error && error.message && (
                    error.message.includes('parameter_comments') && 
                    (error.message.includes('Could not find') || error.message.includes('does not exist') || error.message.includes('column'))
                )) {
                    console.warn('parameter_comments column not found, retrying without it...');
                    
                    // Create a copy without parameter_comments
                    const reversalDataWithoutComments = { ...reversalData };
                    delete reversalDataWithoutComments.parameter_comments;
                    
                    result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentTableName)
                            .update(reversalDataWithoutComments)
                            .eq('id', currentAudit.id)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    // Successfully submitted without parameter_comments column
                }
                
                if (error) throw error;
                
                // Update currentAudit object immediately to reflect reversal submission
                if (currentAudit && data && data.length > 0) {
                    const updatedAudit = data[0];
                    currentAudit.reversalRequestedAt = updatedAudit.reversal_requested_at;
                    currentAudit.reversal_requested_at = updatedAudit.reversal_requested_at;
                    currentAudit.reversalType = updatedAudit.reversal_type;
                    currentAudit.reversal_type = updatedAudit.reversal_type;
                    currentAudit.reversalJustificationFromAgent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversal_justification_from_agent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversalMetricsParameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.reversal_metrics_parameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.withinAuditorScope = updatedAudit.within_auditor_scope;
                    currentAudit.within_auditor_scope = updatedAudit.within_auditor_scope;
                }
                
                // Show pending dialog (not success - reversal is under review)
                const reviewMessage = requireTeamLeadApproval
                    ? '⏳ Your reversal request has been submitted and is now under Team Lead review.\n\nYou will be notified once a decision has been made.'
                    : '⏳ Your reversal request has been submitted and is now under QC review.\n\nYou will be notified once a decision has been made.';
                
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Reversal Request Submitted',
                        message: reviewMessage,
                        confirmText: 'OK',
                        type: 'info'
                    });
                } else {
                    alert(reviewMessage);
                }
                
                // Hide form and reload audit data
                toggleReversalForm();
                location.reload();
                
            } catch (error) {
                console.error('Error submitting reversal request:', error);
                console.error('Error details:', error.message, error);
                
                // Check if this is a schema cache or column error
                let errorMessage = error.message || 'Unknown error occurred';
                if (error.message && (
                    error.message.includes('schema cache') ||
                    error.message.includes('Could not find') ||
                    (error.message.includes('column') && error.message.includes('schema cache'))
                )) {
                    errorMessage = 'The database schema cache is being updated. Please wait a moment and try again. If the issue persists, the column may need to be added to the database table.';
                }
                
                // Provide more helpful error message
                let errorMsg = 'Failed to submit reversal request.\n\n';
                errorMsg += 'Error: ' + errorMessage + '\n\n';
                errorMsg += 'Please try again or contact support if the issue persists.';
                
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Error',
                        message: errorMsg,
                        confirmText: 'OK',
                        type: 'error'
                    });
                } else {
                    alert(errorMsg);
                }
            }
        });
    }
});
// Update feedback boxes for a parameter based on error count (max 10)
function updateFeedbackBoxesForParameter(fieldId, fieldType, paramType) {
    const feedbackContainer = document.getElementById(`feedback_container_${fieldId}`);
    if (!feedbackContainer) return;
    
    // Get current error count
    let errorCount = 0;
    if (fieldType === 'radio') {
        const selectedRadio = document.querySelector(`input[name="${fieldId}"]:checked`);
        if (selectedRadio) {
            const value = parseInt(selectedRadio.value) || 0;
            // For additive/achievement: NO (0) = not achieved = error
            // For error parameters: YES (1) = error occurred = error
            if (paramType === 'achievement' || paramType === 'bonus') {
                errorCount = value === 0 ? 1 : 0;
            } else {
                errorCount = value;
            }
        }
    } else {
        const field = document.getElementById(fieldId);
        errorCount = field ? (parseInt(field.value) || 0) : 0;
    }
    
    // Show feedback boxes based on error count
    // If errorCount is 0, show 1 box (optional)
    // If errorCount > 0, show exactly errorCount boxes (max 10), all required
    const feedbackCount = errorCount === 0 ? 1 : Math.min(errorCount, 10);
    const isRequired = errorCount > 0;
    
    // Get existing feedback values (if loading from saved audit)
    // Check both Quill editors, textareas, and audit data for backward compatibility
    const existingFeedbacks = [];
    
    // First, check currentAudit for existing feedback data
    if (currentAudit) {
        const feedbackKey = `feedback_${fieldId}`;
        const feedbackData = currentAudit[feedbackKey];
        if (feedbackData) {
            let feedbackArray = [];
            if (typeof feedbackData === 'string') {
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch {
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
            feedbackArray.forEach((feedback, index) => {
                if (feedback && feedback.trim()) {
                    // Check if it's HTML or plain text
                    if (feedback.trim().startsWith('<')) {
                        existingFeedbacks[index] = feedback;
                    } else {
                        // Convert plain text to HTML
                        const htmlText = feedback.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
                        existingFeedbacks[index] = htmlText || '';
                    }
                }
            });
        }
    }
    
    // Check for Quill editors (if they exist)
    const existingQuillEditors = feedbackContainer.querySelectorAll(`.quill-editor-container`);
    existingQuillEditors.forEach((editorContainer) => {
        const quillDiv = editorContainer.querySelector('[id^="quill_"]');
        if (quillDiv) {
            const editorId = quillDiv.id.replace('quill_', '');
            if (quillInstances.has(editorId)) {
                const quill = quillInstances.get(editorId);
                const content = quill.root.innerHTML;
                // Check if it's HTML or plain text
                if (content && content.trim() && content !== '<p><br></p>') {
                    const index = parseInt(editorId.split('_').pop()) || 0;
                    existingFeedbacks[index] = content;
                }
            }
        }
    });
    
    // Fallback to textareas for backward compatibility
    const existingTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${fieldId}_"]`);
    existingTextareas.forEach(textarea => {
        const index = parseInt(textarea.id.split('_').pop()) || 0;
        if (!existingFeedbacks[index] && textarea.value) {
            // Convert plain text to HTML (preserve line breaks)
            const plainText = textarea.value;
            const htmlText = plainText.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
            existingFeedbacks[index] = htmlText || '';
        }
    });
    
    // Clear container and destroy existing Quill instances
    feedbackContainer.querySelectorAll('.quill-editor-container').forEach(container => {
        const quillDiv = container.querySelector('[id^="quill_"]');
        if (quillDiv) {
            const editorId = quillDiv.id.replace('quill_', '');
            if (quillInstances.has(editorId)) {
                const quillInstance = quillInstances.get(editorId);
                // Check if instance exists and has destroy method before calling it
                if (quillInstance && typeof quillInstance.destroy === 'function') {
                    try {
                        quillInstance.destroy();
                    } catch (e) {
                        console.warn('Error destroying Quill instance:', e);
                    }
                }
                quillInstances.delete(editorId);
            }
        }
    });
    feedbackContainer.innerHTML = '';
    
    // Create feedback boxes with Quill editors
    for (let i = 0; i < feedbackCount; i++) {
        const feedbackDiv = document.createElement('div');
        feedbackDiv.className = 'quill-editor-container';
        feedbackDiv.style.cssText = 'width: 100%; min-width: 0;';
        const feedbackId = `feedback_${fieldId}_${i}`;
        const quillContainerId = `quill_${feedbackId}`;
        
        // Make required if errorCount > 0, otherwise optional
        const placeholder = errorCount === 0 
            ? 'Enter feedback (optional)...' 
            : (feedbackCount === 1 
                ? 'Enter feedback (required)...' 
                : `Feedback ${i + 1} of ${feedbackCount} (required)...`);
        
        // Create container for Quill
        const quillContainer = document.createElement('div');
        quillContainer.id = quillContainerId;
        feedbackDiv.appendChild(quillContainer);
        feedbackContainer.appendChild(feedbackDiv);
        
        // Initialize Quill editor (check if Quill is available)
        if (typeof Quill === 'undefined') {
            console.error('Quill.js is not loaded. Please check the CDN link.');
            // Fallback to textarea if Quill is not available
            const fallbackTextarea = document.createElement('textarea');
            fallbackTextarea.id = feedbackId;
            fallbackTextarea.name = feedbackId;
            fallbackTextarea.placeholder = placeholder;
            fallbackTextarea.style.cssText = 'font-family: Poppins, sans-serif; font-size: 0.5659rem; line-height: 1.2; min-height: 1rem; max-height: 50rem; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem; width: 100%; box-sizing: border-box;';
            if (existingFeedbacks[i]) {
                fallbackTextarea.value = existingFeedbacks[i].replace(/<[^>]*>/g, ''); // Strip HTML tags
            }
            quillContainer.replaceWith(fallbackTextarea);
            continue;
        }
        
        const quill = new Quill(quillContainer, {
            theme: 'snow',
            placeholder: placeholder,
            modules: {
                toolbar: [
                    ['bold', 'italic'],
                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                    ['link'],
                    ['clean']
                ]
            }
        });
        
        // Set existing content (HTML or convert plain text)
        const existingContent = existingFeedbacks[i];
        if (existingContent) {
            // Check if it's already HTML (contains tags) or plain text
            if (existingContent.trim().startsWith('<')) {
                // It's HTML, set directly
                quill.root.innerHTML = existingContent;
            } else {
                // It's plain text, convert to HTML
                const htmlContent = existingContent.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
                quill.root.innerHTML = htmlContent;
            }
        }
        
        // Store Quill instance
        quillInstances.set(feedbackId, quill);
        
        // Add validation on blur for required fields
        if (isRequired) {
            quill.root.setAttribute('data-required', 'true');
            quill.on('text-change', function() {
                const content = quill.root.innerHTML;
                const isEmpty = !content || content.trim() === '' || content === '<p><br></p>';
                const container = quill.root.closest('.quill-editor-container');
                if (container) {
                    const qlContainer = container.querySelector('.ql-container');
                    if (qlContainer) {
                        if (isEmpty) {
                            qlContainer.style.borderColor = '#ef4444';
                        } else {
                            qlContainer.style.borderColor = '#10b981';
                        }
                    }
                }
            });
        }
    }
}

// Initialize Quill editor for recommendations field
function initializeRecommendationsEditor(audit) {
    const recommendationsContainer = document.getElementById('quill_recommendations');
    if (!recommendationsContainer) {
        console.warn('Recommendations Quill container not found');
        return;
    }
    
    // Check if Quill is available
    if (typeof Quill === 'undefined') {
        console.error('Quill.js is not loaded. Please check the CDN link.');
        // Fallback to textarea if Quill is not available
        const fallbackTextarea = document.createElement('textarea');
        fallbackTextarea.id = 'recommendations';
        fallbackTextarea.name = 'recommendations';
        fallbackTextarea.rows = 4;
        fallbackTextarea.placeholder = 'Enter recommendations and next steps for the employee...';
        fallbackTextarea.style.cssText = 'width: 100%; padding: 0.5659rem; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: "Poppins", sans-serif; background-color: white; resize: vertical; box-sizing: border-box;';
        recommendationsContainer.replaceWith(fallbackTextarea);
        if (audit && audit.recommendations) {
            fallbackTextarea.value = audit.recommendations;
        }
        return;
    }
    
    // Initialize Quill editor
    const quill = new Quill(recommendationsContainer, {
        theme: 'snow',
        placeholder: 'Enter recommendations and next steps for the employee...',
        modules: {
            toolbar: [
                ['bold', 'italic'],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                ['link'],
                ['clean']
            ]
        }
    });
    
    // Store Quill instance
    quillInstances.set('recommendations', quill);
    
    // Populate with existing content if available
    if (audit && audit.recommendations) {
        // Check if it's already HTML (contains tags) or plain text
        if (audit.recommendations.trim().startsWith('<')) {
            // It's HTML, set directly
            quill.root.innerHTML = audit.recommendations;
        } else {
            // It's plain text, convert to HTML
            const htmlContent = audit.recommendations.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
            quill.root.innerHTML = htmlContent;
        }
    }
    
    console.log('✅ Recommendations Quill editor initialized');
}

// Counter Button Functionality for Edit Mode
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('counter-btn') || e.target.closest('.counter-btn')) {
        const btn = e.target.classList.contains('counter-btn') ? e.target : e.target.closest('.counter-btn');
        const action = btn.getAttribute('data-action');
        const targetId = btn.getAttribute('data-target');
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            let currentValue = parseInt(targetInput.value) || 0;
            
            if (action === 'increment') {
                currentValue = Math.min(currentValue + 1, 10);
            } else if (action === 'decrement') {
                currentValue = Math.max(0, currentValue - 1);
            }
            
            targetInput.value = currentValue;
            
            // Update display
            const displayElement = document.getElementById(`${targetId}_display`);
            if (displayElement) {
                displayElement.textContent = currentValue;
                displayElement.style.color = currentValue > 0 ? '#ef4444' : '#1f2937';
            }
            
            // Update feedback boxes based on new error count
            // Get field type and param type from the input's data attributes
            const fieldType = targetInput.dataset.fieldType || 'counter';
            const paramType = targetInput.dataset.paramType || 'error';
            updateFeedbackBoxesForParameter(targetId, fieldType, paramType);
            
            // If count is 0, clear the error count field
            if (currentValue === 0) {
                targetInput.value = 0;
            }
            
            // Update score calculation whenever error count changes
            // Use setTimeout to ensure DOM is updated first
            setTimeout(() => {
                updateAverageScoreDisplay();
                updateParameterChangeHighlighting(); // Update highlighting for changed parameters
            }, 10);
            
            // Also update calculated score if in reversal approval interface
            if (shouldShowReversalApprovalInterface()) {
                setTimeout(() => {
                    updateCalculatedScore();
                }, 100);
            }
        }
    }
});

// Radio Button Change Handler for Edit Mode
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio' && e.target.dataset.category && e.target.name) {
        const fieldName = e.target.name;
        const fieldType = 'radio';
        const paramType = e.target.dataset.paramType || 'error';
        
        // Update feedback boxes based on new selection
        updateFeedbackBoxesForParameter(fieldName, fieldType, paramType);
        
        // Update score calculation whenever error count changes
        // Use setTimeout to ensure DOM is updated first
        setTimeout(() => {
            updateAverageScoreDisplay();
            updateParameterChangeHighlighting(); // Update highlighting for changed parameters
        }, 10);
        
        // Also update calculated score if in edit mode with pending reversal
        if (shouldShowReversalApprovalInterface()) {
            setTimeout(() => {
                updateCalculatedScore();
            }, 100);
        }
    }
});

// Store original audit state for change tracking
let originalAuditState = null;

// Capture original audit state when page loads in edit mode with pending reversal
// IMPORTANT: This should use the state from when reversal was requested, not current state
// This ensures changes are compared against the true original state before any modifications
async function captureOriginalAuditState() {
    if (!currentAudit || !shouldShowReversalApprovalInterface()) {
        return;
    }
    
    // PRIORITY 1: Try to retrieve from reversal_requests table (new structure)
    let reversalRequestState = null;
    try {
        const { data: reversalRequest, error: rrError } = await window.supabaseClient
            .from('reversal_requests')
            .select('original_parameters, original_feedback, original_score, original_passing_status')
            .eq('audit_id', currentAudit.id)
            .eq('scorecard_table_name', currentTableName)
            .order('requested_at', { ascending: false })
            .limit(1)
            .maybeSingle();
        
        if (!rrError && reversalRequest && reversalRequest.original_parameters) {
            // Check if original_parameters has actual parameter values (not parameter_comments structure)
            const firstKey = Object.keys(reversalRequest.original_parameters)[0];
            const firstValue = reversalRequest.original_parameters[firstKey];
            const isParameterValues = typeof firstValue === 'number' || 
                                     (typeof firstValue === 'object' && firstValue !== null && !firstValue.comments);
            
            if (isParameterValues) {
                reversalRequestState = {
                    parameters: reversalRequest.original_parameters || {},
                    feedback: reversalRequest.original_feedback || {},
                    score: reversalRequest.original_score || 0,
                    passingStatus: reversalRequest.original_passing_status || ''
                };
                console.log('✅ Retrieved original state from reversal_requests table:', reversalRequestState);
            }
        } else if (rrError) {
            console.warn('⚠️ Could not retrieve from reversal_requests:', rrError);
        }
    } catch (rrErr) {
        console.warn('⚠️ Error retrieving from reversal_requests:', rrErr);
    }
    
    // PRIORITY 2: Fallback to activity log (when reversal was requested)
    let loggedOriginalState = null;
    if (!reversalRequestState) {
        try {
            const { data: reversalRequestLog, error: logFetchError } = await window.supabaseClient
                .from('audit_activity_log')
                .select('*')
                .eq('audit_id', currentAudit.id)
                .eq('activity_type', 'reversal_requested')
                .order('activity_timestamp', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!logFetchError && reversalRequestLog) {
                loggedOriginalState = {
                    parameters: reversalRequestLog.parameters_snapshot || {},
                    feedback: reversalRequestLog.feedback_snapshot || {},
                    score: reversalRequestLog.score_snapshot || 0,
                    passingStatus: reversalRequestLog.passing_status_snapshot || ''
                };
                console.log('✅ Retrieved original state from activity log for change tracking:', loggedOriginalState);
            } else if (logFetchError) {
                console.warn('⚠️ Could not retrieve original state from activity log:', logFetchError);
            }
        } catch (logErr) {
            console.warn('⚠️ Error retrieving original state from activity log:', logErr);
        }
    }
    
    // Use the best available source
    if (reversalRequestState) {
        originalAuditState = reversalRequestState;
    } else if (loggedOriginalState) {
        originalAuditState = loggedOriginalState;
    } else {
        // Fallback: Use current audit state (for backwards compatibility)
        // Note: This may not be accurate if audit has been modified since reversal request
        console.warn('⚠️ Using current audit state as baseline (no snapshot found). This may show incorrect changes if audit was modified.');
        originalAuditState = {
            parameters: {},
            feedback: {},
            score: currentAudit.averageScore || currentAudit.average_score || 0,
            passingStatus: currentAudit.passingStatus || currentAudit.passing_status || ''
        };
        
        // Capture all parameter values from current audit
        currentErrorFields.forEach(field => {
            const value = currentAudit[field.key] || 0;
            originalAuditState.parameters[field.key] = value;
            
            // Capture feedback
            const feedbackKey = `feedback_${field.key}`;
            const feedbackValue = currentAudit[feedbackKey] || null;
            originalAuditState.feedback[field.key] = feedbackValue;
        });
    }
}

// Calculate new score based on current parameter values
// Uses the same logic as create-audit.html to support deductive, additive, and hybrid scoring
function calculateNewScore() {
    if (!currentErrorFields || currentErrorFields.length === 0 || !currentAuditScorecard) {
        return currentAudit?.averageScore || currentAudit?.average_score || 0;
    }
    
    const scorecard = currentAuditScorecard;
    const scoringType = scorecard.scoring_type || 'deductive';
    
    let score = 0;
    
    switch(scoringType) {
        case 'deductive':
            score = calculateDeductiveScoreForEdit();
            break;
        case 'additive':
            score = calculateAdditiveScoreForEdit();
            break;
        case 'hybrid':
            score = calculateHybridScoreForEdit();
            break;
        default:
            score = calculateDeductiveScoreForEdit();
    }
    
    return Math.round(score * 100) / 100; // Round to 2 decimal places
}

// Deductive scoring: Start at 100, subtract for errors
function calculateDeductiveScoreForEdit() {
    let totalDeduction = 0;
    
    currentErrorFields.forEach(field => {
        // Default to 'error' if parameter_type is null/undefined/empty
        // Skip only if it's explicitly an achievement or bonus type
        const paramType = field.parameter_type || 'error';
        if (paramType === 'achievement' || paramType === 'bonus') {
            return;
        }
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const penalty = parseFloat(field.points) || 0;
        totalDeduction += value * penalty;
    });
    
    return Math.max(0, 100 - totalDeduction);
}

// Additive scoring: Start at 0, add for achievements
function calculateAdditiveScoreForEdit() {
    let totalPoints = 0;
    
    currentErrorFields.forEach(field => {
        if (field.parameter_type !== 'achievement' && field.parameter_type !== 'bonus') return;
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        totalPoints += value * points;
    });
    
    return Math.min(100, totalPoints);
}

// Hybrid scoring: Deduct for errors, add for achievements
function calculateHybridScoreForEdit() {
    let baseScore = 100;
    let bonusPoints = 0;
    
    currentErrorFields.forEach(field => {
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        
        // Default to 'error' if parameter_type is null/undefined/empty
        const paramType = field.parameter_type || 'error';
        
        if (paramType === 'error') {
            // Subtract from base score
            baseScore -= value * points;
        } else if (paramType === 'achievement' || paramType === 'bonus') {
            // Add to bonus
            bonusPoints += value * points;
        }
        // If parameter doesn't match any condition, it's skipped (no deduction or bonus)
    });
    
    // Apply max bonus cap if set
    const maxBonus = parseFloat(currentAuditScorecard.max_bonus_points) || 0;
    if (maxBonus > 0) {
        bonusPoints = Math.min(bonusPoints, maxBonus);
    }
    
    // Calculate final score
    let finalScore = baseScore + bonusPoints;
    
    // Apply over 100% cap if not allowed
    const allowOver100 = currentAuditScorecard.allow_over_100 || false;
    if (!allowOver100) {
        finalScore = Math.min(100, finalScore);
    }
    
    // Ensure minimum of 0
    finalScore = Math.max(0, finalScore);
    
    return finalScore;
}

// Update calculated score display
function updateCalculatedScore() {
    const newScore = calculateNewScore();
    const scoreDisplay = document.getElementById('calculatedNewScore');
    const passingStatusDisplay = document.getElementById('calculatedPassingStatus');
    
    if (scoreDisplay) {
        scoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    if (passingStatusDisplay) {
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        passingStatusDisplay.textContent = isPassing ? 'Passing' : 'Not Passing';
        passingStatusDisplay.className = isPassing 
            ? 'text-green-600 font-semibold' 
            : 'text-red-600 font-semibold';
    }
}

// Update average score display in the main form (similar to create-audit.html)
function updateAverageScoreDisplay() {
    if (!currentErrorFields || currentErrorFields.length === 0 || !currentAuditScorecard) {
        return;
    }
    
    const newScore = calculateNewScore();
    
    // Update average score field if it exists (hidden input for form submission)
    const averageScoreField = document.getElementById('averageScore');
    if (averageScoreField) {
        averageScoreField.value = newScore.toFixed(2);
    }
    
    // Update average score display element - try multiple ways to find it
    let averageScoreDisplay = document.getElementById('averageScoreDisplay');
    
    // If not found by ID, try to find it by looking for the element containing "Avg Score" label
    if (!averageScoreDisplay) {
        // Find the label "Avg Score" and get the next sibling div
        const labels = Array.from(document.querySelectorAll('p'));
        const avgScoreLabel = labels.find(p => p.textContent && p.textContent.trim().toUpperCase().includes('AVG SCORE'));
        if (avgScoreLabel && avgScoreLabel.nextElementSibling) {
            averageScoreDisplay = avgScoreLabel.nextElementSibling;
        }
    }
    
    // If still not found, try querySelector for any element with averageScore in id
    if (!averageScoreDisplay) {
        averageScoreDisplay = document.querySelector('[id*="averageScore" i]');
    }
    
    if (averageScoreDisplay) {
        averageScoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    // Update header score display
    const headerScoreDisplay = document.getElementById('headerScoreDisplay');
    if (headerScoreDisplay) {
        headerScoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    // Update background score in header
    const backgroundScoreContainer = document.getElementById('headerBackgroundScore');
    const headerScoreValue = document.getElementById('headerScoreValue');
    if (backgroundScoreContainer && headerScoreValue) {
        // Set the score value (rounded)
        headerScoreValue.textContent = Math.round(newScore);
        
        // Determine score text color based on passing status
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = parseFloat(scorecard.passing_threshold) || 85;
        const isPassingForScore = newScore >= passingThreshold;
        const scoreTextColor = isPassingForScore 
            ? 'rgba(10, 50, 30, 0.4)' // Darker green for passing
            : 'rgba(100, 10, 10, 0.4)'; // Darker red for not passing
        
        // Update background score color
        const scoreSpan = backgroundScoreContainer.querySelector('span');
        if (scoreSpan) {
            scoreSpan.style.color = scoreTextColor;
        }
        
        // Ensure it's displayed
        backgroundScoreContainer.style.display = 'flex';
    }
    
    // Update passing status
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = parseFloat(scorecard.passing_threshold) || 85;
    const passingStatusField = document.getElementById('passingStatus');
    const passingStatusDisplay = document.getElementById('passingStatusDisplay');
    const headerStatusDisplay = document.getElementById('headerStatusDisplay');
    const headerElement = document.getElementById('auditFormHeader');
    
    // Check if any "fail all" parameters have errors
    let hasFailAllError = false;
    if (currentErrorFields) {
        currentErrorFields.forEach(field => {
            // Check if this field has is_fail_all flag
            if (field.is_fail_all) {
                let errorCount = 0;
                
                if (field.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                    const value = selectedRadio ? parseInt(selectedRadio.value) : 0;
                    // For error parameters: YES (1) = error
                    // For achievement/bonus: NO (0) = error
                    if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                } else {
                    const fieldInput = document.getElementById(field.key);
                    errorCount = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
                }
                
                if (errorCount > 0) {
                    hasFailAllError = true;
                }
            }
        });
    }
    
    // Determine passing status
    let passingStatus = 'Not Passing';
    if (hasFailAllError) {
        passingStatus = 'Not Passing';
    } else if (newScore >= passingThreshold) {
        passingStatus = 'Pass';
    } else {
        passingStatus = 'Not Passing';
    }
    
    if (passingStatusField) {
        passingStatusField.value = passingStatus;
    }
    
    // Update passing status display element if it exists
    if (passingStatusDisplay) {
        // Normalize status for display
        const displayStatus = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed' 
            ? 'Pass' 
            : (passingStatus === 'Not Passing' || passingStatus === 'Not Passed' 
                ? 'Not Passed' 
                : passingStatus);
        passingStatusDisplay.textContent = displayStatus;
    }
    
    // Update header status display
    if (headerStatusDisplay) {
        // Determine status icon
        const isPassing = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed';
        const statusIcon = isPassing ? '✓ ' : '✗ ';
        // Normalize status for display
        const displayStatus = isPassing 
            ? 'Pass' 
            : (passingStatus === 'Not Passing' || passingStatus === 'Not Passed' 
                ? 'Not Passed' 
                : passingStatus);
        headerStatusDisplay.textContent = `${statusIcon}${displayStatus}`;
    }
    
    // Update header background color based on passing status
    if (headerElement) {
        const isPassing = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed';
        if (isPassing) {
            headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
        } else {
            headerElement.style.background = 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)';
        }
    }
    
    // Recalculate and update error counts based on current form values
    if (currentErrorFields && currentErrorFields.length > 0) {
        let totalErrors = 0;
        let criticalFailTotal = 0;
        let criticalTotal = 0;
        let significantTotal = 0;
        
        currentErrorFields.forEach(field => {
            let errorCount = 0;
            
            // Get current value from form
            if (field.field_type === 'radio') {
                const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                if (selectedRadio) {
                    const value = parseInt(selectedRadio.value) || 0;
                    // For error parameters: YES (1) = error
                    // For achievement/bonus: NO (0) = error
                    if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                }
            } else {
                // Counter field
                const fieldInput = document.getElementById(field.key);
                if (fieldInput) {
                    errorCount = parseInt(fieldInput.value) || 0;
                }
            }
            
            // Only count errors (not achievements/bonuses) in total
            if (field.parameter_type === 'error' || !field.parameter_type) {
                totalErrors += errorCount;
            }
            
            // Count by severity
            if (errorCount > 0) {
                if (field.severity === 'Critical Fail') {
                    criticalFailTotal += errorCount;
                } else if (field.severity === 'Critical') {
                    criticalTotal += errorCount;
                } else if (field.severity === 'Significant') {
                    significantTotal += errorCount;
                }
            }
        });
        
        // Update total errors count display
        const totalErrorsDisplay = document.getElementById('totalErrorsCountDisplay');
        if (totalErrorsDisplay) {
            totalErrorsDisplay.textContent = totalErrors.toString();
        }
        
        // Update critical fail total displays
        const criticalFailDisplay = document.getElementById('criticalFailTotalDisplay');
        if (criticalFailDisplay) {
            criticalFailDisplay.textContent = criticalFailTotal.toString();
        }
        const errorDetailsCriticalFail = document.getElementById('errorDetailsCriticalFailTotal');
        if (errorDetailsCriticalFail) {
            errorDetailsCriticalFail.textContent = `Critical Fail: ${criticalFailTotal}`;
        }
        
        // Update critical total displays
        const criticalDisplay = document.getElementById('criticalTotalDisplay');
        if (criticalDisplay) {
            criticalDisplay.textContent = criticalTotal.toString();
        }
        const errorDetailsCritical = document.getElementById('errorDetailsCriticalTotal');
        if (errorDetailsCritical) {
            errorDetailsCritical.textContent = `Critical: ${criticalTotal}`;
        }
        
        // Update significant total displays
        const significantDisplay = document.getElementById('significantTotalDisplay');
        if (significantDisplay) {
            significantDisplay.textContent = significantTotal.toString();
        }
        const errorDetailsSignificant = document.getElementById('errorDetailsSignificantTotal');
        if (errorDetailsSignificant) {
            errorDetailsSignificant.textContent = `Significant: ${significantTotal}`;
        }
    }
}

// Check if any changes were made
function hasParameterChanges() {
    if (!originalAuditState || !currentErrorFields) {
        return false;
    }
    
    for (const field of currentErrorFields) {
        const fieldKey = field.key;
        let currentValue = 0;
        
        // Get current value from form
        if (field.field_type === 'radio') {
            const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
            if (radioInput) {
                currentValue = parseInt(radioInput.value) || 0;
            }
        } else {
            const numberInput = document.getElementById(fieldKey);
            if (numberInput) {
                currentValue = parseInt(numberInput.value) || 0;
            }
        }
        
        const originalValue = originalAuditState.parameters[fieldKey] || 0;
        
        if (currentValue !== originalValue) {
            return true;
        }
        
        // Also check feedback changes
        const feedbackKey = `feedback_${fieldKey}`;
        const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
        const currentFeedbacks = Array.from(feedbackTextareas)
            .map(ta => ta.value.trim())
            .filter(v => v);
        
        const originalFeedback = originalAuditState.feedback[fieldKey];
        let originalFeedbacks = [];
        if (originalFeedback) {
            if (Array.isArray(originalFeedback)) {
                originalFeedbacks = originalFeedback.filter(f => f && f.trim());
            } else if (typeof originalFeedback === 'string') {
                try {
                    const parsed = JSON.parse(originalFeedback);
                    originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                } catch {
                    originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                }
            }
        }
        
        if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
            return true;
        }
    }
    
    return false;
}

// Display reversal approval interface
async function displayReversalApprovalInterface(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) return;
    
    // Get current user info
    const userInfo = getCurrentUserInfo();
    const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
    const currentUserEmailFromInfo = userInfo?.email || getCurrentUserEmail() || '';
    
    // Check workflow state and user role
    const workflowState = getReversalWorkflowState(currentAudit);
    const isTeamLead = isCurrentUserTeamLead();
    const isCQC = isCurrentUserCQC();
    const isAuditor = isCurrentUserAuditor();
    
    // Check if user is team supervisor (async)
    const isTeamSupervisor = await isCurrentUserTeamSupervisor();
    const isAgent = isCurrentUserAuditedEmployee();
    const isTeamLeadReview = (workflowState === 'team_lead_review' || workflowState === 'pending') && (isTeamLead || isTeamSupervisor) && !isAgent;
    
    // Check if user is original auditor or admin
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    
    // Check if auditor is waiting for team lead review (all auditors except admins should be disabled during team_lead_review)
    // Original auditors can also review, but only after team lead approval (qa_review stage)
    const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                        (isAuditor || isOriginalAuditor) && 
                                        !isAdmin && 
                                        !isTeamLead && 
                                        !isTeamSupervisor;
    
    // If this is a team lead review stage, show interface for:
    // 1. Team supervisors/leads (can review)
    // 2. Original auditor (can review, but will see disabled view)
    // 3. Admins (can review)
    // 4. Other auditors (will see disabled view with explanation)
    if ((workflowState === 'team_lead_review' || workflowState === 'pending')) {
        if (!isTeamSupervisor && !isTeamLead && !isOriginalAuditor && !isAdmin && !isAuditor) {
            console.log('User is not authorized to review this reversal. Hiding review interface.', {
                workflowState,
                isTeamSupervisor,
                isTeamLead,
                isOriginalAuditor,
                isAdmin,
                isAuditor
            });
            return;
        } else {
            console.log('Team lead review interface will be shown.', {
                workflowState,
                isTeamSupervisor,
                isTeamLead,
                isOriginalAuditor,
                isAdmin,
                isAuditor,
                isAuditorWaitingForTeamLead,
                isTeamLeadReview
            });
        }
    }
    
    // For qa_review stage, show if user is original auditor, admin, or agent (read-only)
    if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
        if (!isOriginalAuditor && !isAdmin && !isAgent) {
            console.log('User is not authorized to view this reversal. Hiding review interface.', {
                workflowState,
                isOriginalAuditor,
                isAdmin,
                isAgent
            });
            return;
        }
    }
    
    // Debug logging
    console.log('Display reversal approval interface:', {
        workflowState,
        isTeamLead,
        isTeamSupervisor,
        isTeamLeadReview,
        isAuditor,
        isCQC
    });
    
    // Get scorecard for passing threshold
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = scorecard.passing_threshold || 85;
    
        // Store passing threshold for use in team lead interface
        window.currentPassingThreshold = passingThreshold;
    
    // Calculate initial score (only for auditors/CQC, not team leads)
    const newScore = isTeamLeadReview ? (currentAudit?.averageScore || currentAudit?.average_score || 0) : calculateNewScore();
    const isPassing = newScore >= passingThreshold;
    
    // Calculate SLA hours
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    let slaHours = 0;
    if (reversalRequestedAt) {
        const requestedAt = new Date(reversalRequestedAt);
        const now = new Date();
        slaHours = ((now - requestedAt) / (1000 * 60 * 60));
    }
    
    // Get reversal justification from agent and parse it
    const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || 'No justification provided.';
    
    // Parse reversal justification to extract reason and details
    // Format is typically: "Reason: Parameter1: comment1\n\nParameter2: comment2"
    let reversalReason = '';
    let detailedJustification = reversalJustification;
    if (reversalJustification && reversalJustification.includes(':')) {
        const parts = reversalJustification.split(':');
        if (parts.length >= 2) {
            reversalReason = parts[0].trim();
            detailedJustification = parts.slice(1).join(':').trim();
        }
    }
    
    // Rejection reason options for team leads
    const rejectionReasons = [
        'Insufficient justification',
        'Request does not meet criteria',
        'Incorrect information provided',
        'Missing required documentation',
        'Other (specify in comments)'
    ];
    
    // Build interface HTML based on user role
    let decisionSectionHtml = '';
    let titleText = 'Review & Process Reversal';
    let titleIcon = `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`;
    
    if (isTeamLeadReview) {
        // Team Lead/Supervisor Review Interface
        titleText = 'Team Lead Review - Reversal Request';
        titleIcon = `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`;
        
        // Calculate error counts
        let totalErrorsCount = 0;
        let criticalFailCount = 0;
        let criticalCount = 0;
        let significantCount = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    totalErrorsCount += count;
                }
                if (count > 0) {
                    if (field.severity === 'Critical Fail') {
                        criticalFailCount += count;
                    } else if (field.severity === 'Critical') {
                        criticalCount += count;
                    } else if (field.severity === 'Significant') {
                        significantCount += count;
                    }
                }
            });
        }
        
        // Get audit information
        const currentScore = audit.averageScore || audit.average_score || 0;
        const passingStatus = audit.passingStatus || audit.passing_status || '';
        const employeeName = audit.employeeName || audit.employee_name || 'N/A';
        const auditorName = audit.auditorName || audit.auditor_name || 'N/A';
        const auditDate = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
        const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
        const scoreBeforeAppeal = audit.scoreBeforeAppeal || audit.score_before_appeal || currentScore;
        
        // Format audit date
        let formattedDate = 'N/A';
        if (auditDate) {
            try {
                const date = new Date(auditDate);
                formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedDate = auditDate;
            }
        }
        
        // Get parameter comments for team leader to review/edit
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        decisionSectionHtml = `
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            ${parametersWithComments.length > 0 ? `
            <!-- Parameter Comments (Editable for Team Lead) - Table Format -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                    <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
                        Agent's Comments on Parameters
                    </h3>
                    <span style="font-size: 0.4852rem; color: #6b7280; font-weight: 500; font-family: 'Poppins', sans-serif;">(You can modify these before approving)</span>
                </div>
                
                <div style="background: var(--background-white); border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                    <div style="background-color: var(--background-white); padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid var(--border-light);">
                        <div style="display: grid; grid-template-columns: 1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                            <div style="min-width: 0;">Error Type</div>
                            <div style="text-align: center; min-width: 0;">Points</div>
                            <div style="text-align: center; min-width: 0;">Severity</div>
                            <div style="text-align: center; min-width: 0;">Count</div>
                            <div style="min-width: 0;">Feedback</div>
                            <div style="min-width: 0;">Agent's Comment</div>
                        </div>
                    </div>
                    <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                        ${parametersWithComments.map(field => {
                            const fieldComment = parameterComments[field.key];
                            let commentText = '';
                            if (fieldComment.comment && fieldComment.comment.trim()) {
                                commentText = fieldComment.comment.trim();
                            } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                                commentText = fieldComment.comments.filter(c => c && c.trim()).map(c => c.trim()).join('\n');
                            }
                            
                            // Get field value and display
                            const rawValue = audit[field.key];
                            let displayValue = '';
                            let count = 0;
                            
                            if (field.field_type === 'radio') {
                                const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
                                displayValue = isYes ? '✓ YES' : '✗ NO';
                                count = isYes ? 1 : 0;
                            } else {
                                count = rawValue ? parseInt(rawValue) : 0;
                                displayValue = count.toString();
                            }
                            
                            // Severity colors
                            let severityColor = '#3b82f6';
                            let severityBg = '#eff6ff';
                            
                            if (field.parameter_type === 'error') {
                                // All error severities use red shades - darker red for higher severity
                                // Text color is white for all to ensure good contrast against red backgrounds
                                if (field.severity === 'Critical Fail') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#7f1d1d'; // Darkest red background
                                } else if (field.severity === 'Critical') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#991b1b'; // Dark red background
                                } else if (field.severity === 'Significant') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#b91c1c'; // Medium-dark red background
                                } else if (field.severity === 'Major') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#dc2626'; // Medium red background
                                } else if (field.severity === 'Minor') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#ef4444'; // Light-medium red background
                                } else {
                                    // Default for any other error severity
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#b91c1c'; // Medium-dark red background
                                }
                            } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                                severityColor = '#10b981';
                                severityBg = '#d1fae5';
                            }
                            
                            // Get feedback data (same as Error Details section)
                            const feedbackData = audit[field.feedback];
                            let feedbackArray = [];
                            
                            if (feedbackData) {
                                if (typeof feedbackData === 'string') {
                                    try {
                                        const parsed = JSON.parse(feedbackData);
                                        feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                    } catch (e) {
                                        feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                    }
                                } else if (Array.isArray(feedbackData)) {
                                    feedbackArray = feedbackData;
                                } else {
                                    feedbackArray = feedbackData ? [feedbackData] : [];
                                }
                            }
                            
                            feedbackArray = feedbackArray.filter(f => f && f.trim());
                            const hasFeedback = feedbackArray.length > 0;
                            
                            // Generate feedback HTML (same as Error Details section)
                            let feedbackHtml = '-';
                            if (hasFeedback) {
                                feedbackHtml = feedbackArray.map((feedbackText, index) => {
                                    const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                                    // Check if feedback contains HTML tags - if so, render as HTML, otherwise escape
                                    const trimmedFeedback = feedbackText.trim();
                                    const isHtml = trimmedFeedback.startsWith('<') && (trimmedFeedback.includes('</') || trimmedFeedback.endsWith('>'));
                                    const displayText = isHtml ? feedbackText : escapeHtml(feedbackText);
                                    return `${label}<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">${displayText}</div>`;
                                }).join('');
                            }
                            
                            return `
                                <div style="display: grid; grid-template-columns: 1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr; gap: 0.6469rem; align-items: start; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6; width: 100%; min-width: 0;">
                                    <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                                        ${escapeHtml(field.label)}
                                    </div>
                                    <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                                        ${field.points || 0}
                                    </div>
                                    <div style="display: flex; justify-content: center; min-width: 0;">
                                        <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${escapeHtml(field.severity || 'N/A')}</span>
                                    </div>
                                    <div style="display: flex; justify-content: center; min-width: 0;">
                                        <div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>
                                    </div>
                                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                                        ${feedbackHtml}
                                    </div>
                                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                                        <textarea id="teamLeadParamComment_${field.key}" rows="2" placeholder="Enter your comment..." style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box;">${escapeHtml(commentText)}</textarea>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
            ` : ''}
            
            <!-- Decision Section for Team Lead -->
            <div style="border-top: 0.0625rem solid #e5e7eb; padding-top: 0.75rem;">
                <!-- Action Buttons (shown first) -->
                <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; margin-bottom: 0.75rem;">
                    <button onclick="teamLeadRejectReversal()" id="teamLeadRejectBtn" style="padding: 0.375rem 0.75rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Reject Reversal Request
                    </button>
                    <button onclick="teamLeadApproveReversal()" id="teamLeadApproveBtn" style="padding: 0.375rem 0.75rem; background: #16a34a; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Approve Reversal Request
                    </button>
                </div>
                
                <!-- Rejection Reason Section (hidden by default, shown when reject is clicked) -->
                <div id="teamLeadRejectionSection" style="display: none; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 0.0625rem solid #e5e7eb;">
                    <div style="margin-bottom: 0.5625rem;">
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Rejection Reason <span style="color: #ef4444;">*</span>
                        </label>
                        <select id="teamLeadRejectionReason" required style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; background: white;">
                            <option value="">Select reason...</option>
                            ${rejectionReasons.map(reason => `<option value="${escapeHtml(reason)}">${escapeHtml(reason)}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 0.5625rem;">
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Additional Comments (Optional)
                        </label>
                        <textarea id="teamLeadComments" rows="3" placeholder="Add any additional comments..." style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box;"></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 0.5625rem; justify-content: flex-end;">
                        <button onclick="teamLeadCancelRejection()" style="padding: 0.375rem 0.75rem; background: #f3f4f6; color: #374151; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                            Cancel
                        </button>
                        <button onclick="teamLeadConfirmRejectReversal()" style="padding: 0.375rem 0.75rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                            Confirm Rejection
                        </button>
                    </div>
                </div>
            </div>
        `;
    } else if (isAgent) {
        // Agent Read-Only View - Show same information as team leads/auditors but read-only
        // Calculate error counts (same as team lead view)
        let totalErrorsCount = 0;
        let criticalFailCount = 0;
        let criticalCount = 0;
        let significantCount = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    totalErrorsCount += count;
                }
                if (count > 0) {
                    if (field.severity === 'Critical Fail') {
                        criticalFailCount += count;
                    } else if (field.severity === 'Critical') {
                        criticalCount += count;
                    } else if (field.severity === 'Significant') {
                        significantCount += count;
                    }
                }
            });
        }
        
        // Get audit information (same as team lead view)
        const currentScore = audit.averageScore || audit.average_score || 0;
        const passingStatus = audit.passingStatus || audit.passing_status || '';
        const employeeName = audit.employeeName || audit.employee_name || 'N/A';
        const auditorName = audit.auditorName || audit.auditor_name || 'N/A';
        const auditDate = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
        const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
        const scoreBeforeAppeal = audit.scoreBeforeAppeal || audit.score_before_appeal || currentScore;
        
        // Format audit date
        let formattedDate = 'N/A';
        if (auditDate) {
            try {
                const date = new Date(auditDate);
                formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedDate = auditDate;
            }
        }
        
        // Get parameter comments for agent to view
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Get reversal reason (same parsing as team lead view)
        const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
        let reversalReason = '';
        if (reversalJustification && reversalJustification.includes(':')) {
            const parts = reversalJustification.split(':');
            if (parts.length >= 2) {
                reversalReason = parts[0].trim();
            }
        }
        
        // Check if Team Lead has approved
        const teamLeadApproved = audit.team_lead_approved;
        const teamLeadReviewedBy = audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '';
        const teamLeadReviewedAt = audit.team_lead_reviewed_at || audit.teamLeadReviewedAt;
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        // Format team lead review date
        let formattedReviewDate = '';
        if (teamLeadReviewedAt) {
            try {
                const date = new Date(teamLeadReviewedAt);
                formattedReviewDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedReviewDate = teamLeadReviewedAt;
            }
        }
        
        // Get auditor response if available
        const auditorResponse = audit.response_from_auditor || audit.reasonForReversalResponseDelay || '';
        const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
        
        decisionSectionHtml = `
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only, for context) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            <!-- Reversal Request Details -->
            <div style="background: #f9fafb; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5625rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif;">
                    ${reversalRequestedAt ? (() => {
                        const date = new Date(reversalRequestedAt);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);
                        
                        let requestedDateText = '';
                        if (diffMins < 1) {
                            requestedDateText = 'just now';
                        } else if (diffMins < 60) {
                            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                        } else if (diffHours < 24) {
                            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
                        } else if (diffDays === 1) {
                            requestedDateText = '1 day ago';
                        } else {
                            requestedDateText = date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Submitted:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem;">${escapeHtml(requestedDateText)}</span>
                            </div>
                        `;
                    })() : ''}
                    ${(() => {
                        return `
                            <div>
                                <span style="color: #6b7280; font-weight: 500;">Within Auditor Scope:</span>
                                <span style="color: #1f2937; font-weight: 600; margin-left: 0.2812rem; display: inline-flex; align-items: center; gap: 0.1875rem;">
                                    ${withinAuditorScope === 'true' || withinAuditorScope === true ? `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #10b981;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                                        </svg>
                                        <span>Yes</span>
                                    ` : `
                                        <svg style="width: 0.75rem; height: 0.75rem; color: #6b7280;" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                        </svg>
                                        <span>No</span>
                                    `}
                                </span>
                            </div>
                        `;
                    })()}
                </div>
            </div>
            
            ${parametersWithComments.length > 0 ? `
            <!-- Agent's Parameter Comments (Read-only for Agent) - Table Format -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                    <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>
                        Agent's Comments on Parameters
                    </h3>
                </div>
                
                <div style="background: var(--background-white); border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                    <div style="background-color: var(--background-white); padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid var(--border-light);">
                        <div style="display: grid; grid-template-columns: 1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                            <div style="min-width: 0;">Error Type</div>
                            <div style="text-align: center; min-width: 0;">Points</div>
                            <div style="text-align: center; min-width: 0;">Severity</div>
                            <div style="text-align: center; min-width: 0;">Count</div>
                            <div style="min-width: 0;">Feedback</div>
                            <div style="min-width: 0;">Agent's Comment</div>
                        </div>
                    </div>
                    <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                        ${parametersWithComments.map(field => {
                            const fieldComment = parameterComments[field.key];
                            let commentText = '';
                            if (fieldComment.comment && fieldComment.comment.trim()) {
                                commentText = fieldComment.comment.trim();
                            } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                                commentText = fieldComment.comments.filter(c => c && c.trim()).map(c => c.trim()).join('\n');
                            }
                            
                            // Get field value and display
                            const rawValue = audit[field.key];
                            let displayValue = '';
                            let count = 0;
                            
                            if (field.field_type === 'radio') {
                                const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
                                displayValue = isYes ? '✓ YES' : '✗ NO';
                                count = isYes ? 1 : 0;
                            } else {
                                count = rawValue ? parseInt(rawValue) : 0;
                                displayValue = count.toString();
                            }
                            
                            // Severity colors
                            let severityColor = '#3b82f6';
                            let severityBg = '#eff6ff';
                            
                            if (field.parameter_type === 'error') {
                                // All error severities use red shades - darker red for higher severity
                                // Text color is white for all to ensure good contrast against red backgrounds
                                if (field.severity === 'Critical Fail') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#7f1d1d'; // Darkest red background
                                } else if (field.severity === 'Critical') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#991b1b'; // Dark red background
                                } else if (field.severity === 'Significant') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#b91c1c'; // Medium-dark red background
                                } else if (field.severity === 'Major') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#dc2626'; // Medium red background
                                } else if (field.severity === 'Minor') {
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#ef4444'; // Light-medium red background
                                } else {
                                    // Default for any other error severity
                                    severityColor = '#ffffff'; // White text
                                    severityBg = '#b91c1c'; // Medium-dark red background
                                }
                            } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                                severityColor = '#10b981';
                                severityBg = '#d1fae5';
                            }
                            
                            // Get feedback data (same as Error Details section)
                            // Try multiple possible feedback field names for compatibility
                            const feedbackKey = field.feedback || `feedback_${field.key}`;
                            let feedbackData = audit[field.feedback] || audit[feedbackKey] || audit[`feedback_${field.key}`];
                            
                            // If still not found, try checking all possible feedback field variations
                            if (!feedbackData && field.feedback) {
                                // Try common variations
                                const possibleKeys = [
                                    field.feedback,
                                    `feedback_${field.key}`,
                                    `feedback${field.key}`,
                                    `${field.key}_feedback`
                                ].filter(k => k);
                                
                                for (const key of possibleKeys) {
                                    if (audit[key]) {
                                        feedbackData = audit[key];
                                        break;
                                    }
                                }
                            }
                            
                            let feedbackArray = [];
                            
                            if (feedbackData) {
                                if (typeof feedbackData === 'string') {
                                    try {
                                        const parsed = JSON.parse(feedbackData);
                                        feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                    } catch (e) {
                                        feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                    }
                                } else if (Array.isArray(feedbackData)) {
                                    feedbackArray = feedbackData;
                                } else {
                                    feedbackArray = feedbackData ? [feedbackData] : [];
                                }
                            }
                            
                            feedbackArray = feedbackArray.filter(f => f && f.trim());
                            const hasFeedback = feedbackArray.length > 0;
                            
                            // Generate feedback HTML (same as Error Details section)
                            let feedbackHtml = '-';
                            if (hasFeedback) {
                                feedbackHtml = feedbackArray.map((feedbackText, index) => {
                                    const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #000000; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                                    // Check if feedback contains HTML tags - if so, render as HTML, otherwise escape
                                    const trimmedFeedback = feedbackText.trim();
                                    const isHtml = trimmedFeedback.startsWith('<') && (trimmedFeedback.includes('</') || trimmedFeedback.endsWith('>'));
                                    const displayText = isHtml ? feedbackText : escapeHtml(feedbackText);
                                    return `${label}<div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">${displayText}</div>`;
                                }).join('');
                            }
                            
                            return `
                                <div style="display: grid; grid-template-columns: 1.5fr 0.8fr 0.8fr 0.8fr 4fr 2fr; gap: 0.6469rem; align-items: start; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6; width: 100%; min-width: 0;">
                                    <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                                        ${escapeHtml(field.label)}
                                    </div>
                                    <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                                        ${field.points || 0}
                                    </div>
                                    <div style="display: flex; justify-content: center; min-width: 0;">
                                        <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${escapeHtml(field.severity || 'N/A')}</span>
                                    </div>
                                    <div style="display: flex; justify-content: center; min-width: 0;">
                                        <div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>
                                    </div>
                                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                                        ${feedbackHtml}
                                    </div>
                                    <div style="font-size: 0.5659rem; color: #000000; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                                        ${escapeHtml(commentText) || '<span style="color: #9ca3af; font-style: italic;">No comment</span>'}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
            ` : ''}
            
            ${reversalReason ? `
            <!-- Reversal Reason (Read-only) -->
            <div style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Reversal Reason</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe;">${escapeHtml(reversalReason)}</p>
            </div>
            ` : ''}
            
            ${teamLeadApproved && teamLeadReviewedBy ? `
            <!-- Team Lead Approval Status -->
            <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #16a34a; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; color: #16a34a;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Approved by Team Lead
                </p>
                <p style="font-size: 0.6094rem; color: #166534; margin: 0; font-family: 'Poppins', sans-serif;">
                    <span class="user-profile-hover" data-user-name="${escapeHtml(teamLeadReviewedBy)}" style="cursor: pointer; text-decoration: underline; font-weight: 600;">${escapeHtml(teamLeadReviewedBy)}</span>
                    ${formattedReviewDate ? ` on ${escapeHtml(formattedReviewDate)}` : ''}
                    </p>
                </div>
            ` : ''}
            
            ${auditorResponse && reversalRespondedAt ? `
            <!-- Auditor Response (Read-only) -->
            <div style="background: #f0f9ff; border: 0.0625rem solid #bae6fd; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.2812rem 0; font-family: 'Poppins', sans-serif;">Response From Auditor</p>
                <p style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif; background: white; padding: 0.5625rem; border-radius: 0.2812rem; border: 0.0625rem solid #bfdbfe; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(auditorResponse)}</p>
            </div>
            ` : ''}
        `;
    } else {
        // Auditor/CQC Review Interface
        // Get parameter comments for auditor to review
        const parameterComments = audit.parameterComments || audit.parameter_comments || {};
        const parametersWithComments = currentErrorFields.filter(field => {
            const fieldComment = parameterComments[field.key];
            if (!fieldComment) return false;
            const commentText = fieldComment.comment || (Array.isArray(fieldComment.comments) ? fieldComment.comments.filter(c => c && c.trim()).join('\n') : '');
            return commentText && commentText.trim();
        });
        
        // Check if Team Lead has approved
        const teamLeadApproved = audit.team_lead_approved;
        const teamLeadReviewedBy = audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '';
        const teamLeadReviewedAt = audit.team_lead_reviewed_at || audit.teamLeadReviewedAt;
        
        // Get reversal request details
        const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
        const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
        
        // Format team lead review date
        let formattedReviewDate = '';
        if (teamLeadReviewedAt) {
            try {
                const date = new Date(teamLeadReviewedAt);
                formattedReviewDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                formattedReviewDate = teamLeadReviewedAt;
            }
        }
        
        decisionSectionHtml = `
            
            ${!isAgent && !isAuditorWaitingForTeamLead ? `
            <!-- Decision Section (only for auditors/admins, not agents, and only when not waiting for team lead) -->
            <div style="border-top: 0.0625rem solid #e5e7eb; padding-top: 0.75rem;">
                <div style="margin-bottom: 0.5625rem;">
                    <div>
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Response From Auditor <span style="color: #ef4444;">*</span>
                        </label>
                        <textarea id="reversalDelayReason" required rows="3" placeholder="Please provide your response or comments..." style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box; background: white; cursor: text;"></textarea>
                    </div>
                </div>
                
                <!-- Hidden Approved By field (still used for data storage) -->
                <input type="hidden" id="reversalApprovedBy" value="${escapeHtml(currentUserName)}">
                
                <!-- Within Auditor Scope (for auditor to select) -->
                <div style="margin-bottom: 0.5625rem;">
                    <label style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.6562rem; font-weight: 600; color: #374151; font-family: 'Poppins', sans-serif; cursor: pointer;">
                        <input type="checkbox" id="withinAuditorScope" ${(audit.withinAuditorScope === 'true' || audit.withinAuditorScope === true || audit.within_auditor_scope === 'true' || audit.within_auditor_scope === true) ? 'checked' : ''} style="width: 0.75rem; height: 0.75rem; cursor: pointer;">
                        <span>Within Auditor Scope</span>
                    </label>
                    <p style="font-size: 0.5625rem; color: #6b7280; margin: 0.2812rem 0 0 1.125rem; font-family: 'Poppins', sans-serif;">Check if this reversal can be resolved by the original auditor</p>
                </div>
                
                <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; padding-top: 0.5625rem; border-top: 0.0625rem solid #e5e7eb;">
                    <button onclick="rejectReversal()" style="padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Reject Reversal
                    </button>
                    <button onclick="approveReversal()" style="padding: 0.5rem 1rem; background: #16a34a; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Approve Reversal
                    </button>
                </div>
            </div>
            ` : ''}
        `;
    }
    
    // Check if Team Lead has approved (for auditor view)
    const teamLeadApproved = !isTeamLeadReview ? (audit.team_lead_approved === true || audit.team_lead_approved === 'true') : false;
    const teamLeadReviewedBy = !isTeamLeadReview ? (audit.team_lead_reviewed_by || audit.teamLeadReviewedBy || '') : '';
    
    // Build journey map/roadmap indicator
    const journeyMapHtml = await buildReversalJourneyMap(workflowState, teamLeadApproved, audit);
    
    // Debug logging for isAuditorWaitingForTeamLead
    console.log('displayReversalApprovalInterface - isAuditorWaitingForTeamLead check:', {
        workflowState,
        isAuditor,
        isOriginalAuditor,
        isAdmin,
        isTeamLead,
        isTeamSupervisor,
        isAuditorWaitingForTeamLead
    });
    
    // Determine if we should show the "Awaiting Team Lead Review" banner
    // Show for: agents, auditors (waiting), team leads/admins (when in team_lead_review state)
    const shouldShowBanner = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                              (isAgent || isAuditorWaitingForTeamLead || isTeamLeadReview || (isAdmin && (workflowState === 'team_lead_review' || workflowState === 'pending')));
    
    // Determine heading text based on user role
    let headingText = '';
    if (isAgent) {
        headingText = 'Reversal Request Info';
    } else if (isTeamLeadReview) {
        headingText = 'Team Lead Review - Reversal Request';
    } else {
        headingText = 'Review & Process Reversal';
    }
    
    const approvalInterfaceHtml = `
        <div id="reversalApprovalInterface" class="no-print" style="background: white; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(0,0,0,0.1); margin-top: 0.5625rem;">
            <!-- Heading -->
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; padding-bottom: 0.5625rem; border-bottom: 0.0625rem solid #e5e7eb;">
                <svg style="width: 1rem; height: 1rem; color: #1A733E;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <h3 style="font-size: 0.75rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(headingText)}
                </h3>
            </div>
            
            ${shouldShowBanner ? `
            <!-- Waiting for Team Lead Review Banner (at top of interface) -->
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 0.1875rem solid #f59e0b; border-radius: 0.2812rem; padding: 0.5625rem 0.75rem; margin-bottom: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(245, 158, 11, 0.1);">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="display: flex; align-items: center; justify-content: center; width: 1.5rem; height: 1.5rem; background: #f59e0b; border-radius: 50%; flex-shrink: 0;">
                        <svg style="width: 0.875rem; height: 0.875rem; color: white;" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <p style="font-size: 0.6875rem; font-weight: 700; color: #92400e; margin: 0 0 0.1875rem 0; font-family: 'Poppins', sans-serif; letter-spacing: 0.01em;">
                            Awaiting Team Lead Review
                        </p>
                        <p style="font-size: 0.625rem; color: #78350f; margin: 0; line-height: 1.4; font-family: 'Poppins', sans-serif;">
                            This reversal is pending Team Lead approval. Review will be available after approval.
                        </p>
                    </div>
                </div>
            </div>
            ` : ''}
            
            <!-- Reversal Journey Map / Roadmap - Compact Checkout Style (No Container) -->
            ${journeyMapHtml}
            
            ${decisionSectionHtml}
        </div>
    `;
    
    // Insert the approval interface right after the header section (before chat/error details)
    // Remove existing interface if it exists
    const existingApprovalInterface = document.getElementById('reversalApprovalInterface');
    if (existingApprovalInterface) {
        existingApprovalInterface.remove();
    }
    
    // Find the header section and insert right after it
    const auditFormHeader = document.getElementById('auditFormHeader');
    if (auditFormHeader && auditFormHeader.nextSibling) {
        // Insert after header, before the main content
        auditFormHeader.insertAdjacentHTML('afterend', approvalInterfaceHtml);
    } else if (auditFormHeader) {
        // If header exists but no next sibling, append after it
        auditFormHeader.insertAdjacentHTML('afterend', approvalInterfaceHtml);
    } else {
        // Fallback: try to find auditMainContent and insert before it
        const auditMainContent = document.getElementById('auditMainContent');
        if (auditMainContent) {
            auditMainContent.insertAdjacentHTML('beforebegin', approvalInterfaceHtml);
        } else {
            // Last fallback: append to end of audit content
            auditContentDiv.insertAdjacentHTML('beforeend', approvalInterfaceHtml);
        }
    }
    
    // Capture original state (only for auditors/CQC who can edit)
    if (!isTeamLeadReview) {
        // Capture original state from activity log (async)
        // This gets the true original state from when reversal was requested, not current state
        captureOriginalAuditState().then(() => {
        // Update score calculation on any parameter change (only for auditors/CQC)
        updateCalculatedScore();
        
            // Update parameter highlighting after a short delay to ensure DOM is ready
            setTimeout(() => {
                updateParameterChangeHighlighting();
            }, 200);
    }).catch(err => {
        console.error('Error capturing original audit state:', err);
        // Still try to update even if capture fails
        updateCalculatedScore();
        setTimeout(() => {
            updateParameterChangeHighlighting();
        }, 200);
    });
    }
    
    // Setup user profile hovers for team lead name
    setupUserProfileHovers();
}

// Function to fetch user by name
async function getUserByName(userName) {
    if (!userName || !window.supabaseClient) return null;
    
    try {
        const { data, error } = await window.supabaseClient
            .from('users')
            .select('*')
            .ilike('name', userName)
            .limit(1)
            .single();
        
        if (error) {
            // Try case-insensitive search if exact match fails
            const { data: allUsers } = await window.supabaseClient
                .from('users')
                .select('*')
                .limit(1000);
            
            const foundUser = allUsers?.find(u => 
                u.name && u.name.toLowerCase().trim() === userName.toLowerCase().trim()
            );
            return foundUser || null;
        }
    
        return data;
    } catch (error) {
        console.error('Error fetching user by name:', error);
        return null;
    }
}

// Function to show user profile modal
function showUserProfileModal(userData, element) {
    // Remove existing modal if any
    const existingModal = document.getElementById('userProfileModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    if (!userData) {
        return; // No user data to show
    }
    
    // Get element position
    const rect = element.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'userProfileModal';
    modal.style.cssText = `
        position: absolute;
        top: ${rect.bottom + scrollTop + 5}px;
        left: ${rect.left + scrollLeft}px;
        background: white;
        border-radius: 0.375rem;
        box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.15);
        padding: 0.75rem;
        min-width: 12.5rem;
        max-width: 18.75rem;
        z-index: 10000;
        border: 0.0625rem solid #e5e7eb;
        font-family: 'Poppins', sans-serif;
    `;
    
    // Get user avatar or initials
    const avatarUrl = userData.avatar_url || userData.avatar;
    const initials = userData.name ? userData.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2) : '?';
    
    // Build modal content
    modal.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 0.5625rem;">
            <div style="display: flex; align-items: center; gap: 0.5625rem; padding-bottom: 0.5625rem; border-bottom: 0.0625rem solid #e5e7eb;">
                ${avatarUrl ? `
                    <img src="${escapeHtml(avatarUrl)}" style="width: 2.5rem; height: 2.5rem; border-radius: 50%; object-fit: cover;" alt="${escapeHtml(userData.name || '')}">
                ` : `
                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 50%; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.875rem;">
                        ${initials}
                    </div>
                `}
                <div style="flex: 1; min-width: 0;">
                    <div style="font-weight: 600; font-size: 0.75rem; color: #1f2937; margin-bottom: 0.125rem;">${escapeHtml(userData.name || 'Unknown')}</div>
                    <div style="font-size: 0.5625rem; color: #6b7280;">${escapeHtml(userData.email || '')}</div>
                </div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 0.375rem; font-size: 0.6094rem;">
                ${userData.role ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Role:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.role)}</span>
                    </div>
                ` : ''}
                ${userData.department ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Department:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.department)}</span>
                    </div>
                ` : ''}
                ${userData.team ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Team:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.team)}</span>
                    </div>
                ` : ''}
                ${userData.channel ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Channel:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.channel)}</span>
                    </div>
                ` : ''}
                ${userData.designation ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Designation:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.designation)}</span>
                    </div>
                ` : ''}
                ${userData.employee_id ? `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6b7280; font-weight: 500;">Employee ID:</span>
                        <span style="color: #1f2937; font-weight: 600;">${escapeHtml(userData.employee_id)}</span>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Position modal to stay within viewport
    const modalRect = modal.getBoundingClientRect();
    if (modalRect.right > window.innerWidth) {
        modal.style.left = `${window.innerWidth - modalRect.width - 10}px`;
    }
    if (modalRect.bottom > window.innerHeight) {
        modal.style.top = `${rect.top + scrollTop - modalRect.height - 5}px`;
    }
    
    // Close modal when clicking outside or when mouse leaves
    const closeModal = (e) => {
        if (!modal.contains(e.target) && !element.contains(e.target)) {
            modal.remove();
            document.removeEventListener('click', closeModal);
        }
    };
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', closeModal);
    }, 100);
    
    // Close when mouse leaves the element and modal
    element.addEventListener('mouseleave', (e) => {
        const relatedTarget = e.relatedTarget;
        if (!modal.contains(relatedTarget)) {
            setTimeout(() => {
                if (!element.matches(':hover') && !modal.matches(':hover')) {
                    modal.remove();
                }
            }, 200);
        }
    });
    
    modal.addEventListener('mouseleave', () => {
        setTimeout(() => {
            if (!element.matches(':hover') && !modal.matches(':hover')) {
                modal.remove();
            }
        }, 200);
    });
}

// Setup hover event listeners for user profile
function setupUserProfileHovers() {
    // Use event delegation for dynamically created elements
    document.addEventListener('mouseenter', async function(e) {
        if (!e.target || typeof e.target.closest !== 'function') return;
        const hoverElement = e.target.closest('.user-profile-hover');
        if (!hoverElement) return;
        
        const userName = hoverElement.getAttribute('data-user-name');
        if (!userName || userName === 'Team Lead') return;
        
        // Fetch user data
        const userData = await getUserByName(userName);
        if (userData) {
            showUserProfileModal(userData, hoverElement);
        }
    }, true);
}

// Update parameter change highlighting dynamically
// Update parameter change highlighting dynamically - DISABLED
// Removed to avoid confusion - only show database values, not unsaved form changes
function updateParameterChangeHighlighting() {
    // Function disabled - no longer tracking unsaved changes
    // Only database values are displayed, not form input changes
    return;
}


// Team Lead: Approve reversal request
async function teamLeadApproveReversal() {
    // Get modified parameter comments if team leader edited them
    const modifiedParameterComments = {};
    const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    let hasModifiedComments = false;
    
    currentErrorFields.forEach(field => {
        const commentTextarea = document.getElementById(`teamLeadParamComment_${field.key}`);
        if (commentTextarea) {
            const modifiedComment = commentTextarea.value.trim();
            const originalComment = parameterComments[field.key];
            let originalCommentText = '';
            
            if (originalComment) {
                if (originalComment.comment && originalComment.comment.trim()) {
                    originalCommentText = originalComment.comment.trim();
                } else if (originalComment.comments && Array.isArray(originalComment.comments)) {
                    originalCommentText = originalComment.comments.filter(c => c && c.trim()).map(c => c.trim()).join('\n');
                }
            }
            
            if (modifiedComment !== originalCommentText) {
                hasModifiedComments = true;
                // Store as array format (for consistency with existing structure)
                modifiedParameterComments[field.key] = {
                    comments: modifiedComment ? [modifiedComment] : [],
                    commented_at: new Date().toISOString(),
                    commented_by: getCurrentUserEmail() || ''
                };
            }
        }
    });
    
    if (hasModifiedComments) {
        window.teamLeadModifiedParameterComments = modifiedParameterComments;
    }
    
    await processReversalDecision('approved');
}

// Team Lead: Show rejection reason section
function teamLeadRejectReversal() {
    const rejectionSection = document.getElementById('teamLeadRejectionSection');
    if (rejectionSection) {
        rejectionSection.style.display = 'block';
        // Scroll to rejection section
        rejectionSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        // Focus on rejection reason dropdown
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        if (reasonSelect) {
            setTimeout(() => reasonSelect.focus(), 100);
        }
    }
}

// Team Lead: Cancel rejection (hide rejection section)
function teamLeadCancelRejection() {
    const rejectionSection = document.getElementById('teamLeadRejectionSection');
    if (rejectionSection) {
        rejectionSection.style.display = 'none';
        // Clear rejection fields
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        const commentsTextarea = document.getElementById('teamLeadComments');
        if (reasonSelect) reasonSelect.value = '';
        if (commentsTextarea) commentsTextarea.value = '';
    }
}

// Team Lead: Confirm rejection (validate and process)
async function teamLeadConfirmRejectReversal() {
    const rejectionReason = document.getElementById('teamLeadRejectionReason')?.value || '';
    const comments = document.getElementById('teamLeadComments')?.value || '';
    
    if (!rejectionReason || rejectionReason.trim() === '') {
        alert('Please select a rejection reason.');
        const reasonSelect = document.getElementById('teamLeadRejectionReason');
        if (reasonSelect) {
            reasonSelect.focus();
            reasonSelect.style.borderColor = '#dc2626';
            setTimeout(() => {
                reasonSelect.style.borderColor = '#d1d5db';
            }, 2000);
        }
        return;
    }
    
    // Store rejection reason and comments for processReversalDecision
    window.teamLeadRejectionData = {
        reason: rejectionReason,
        comments: comments
    };
    
    await processReversalDecision('rejected');
}

// Approve reversal (for auditors/CQC)
async function approveReversal() {
    // Check if auditor is waiting for team lead review
    if (currentAudit) {
        const workflowState = getReversalWorkflowState(currentAudit);
        const isAuditor = isCurrentUserAuditor();
        const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
        const isAdmin = isCurrentUserAdmin();
        const isTeamLead = isCurrentUserTeamLead();
        
        const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                            (isAuditor || isOriginalAuditor) && 
                                            !isAdmin && 
                                            !isTeamLead;
        
        if (isAuditorWaitingForTeamLead) {
            alert('This reversal is currently under Team Lead review. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    }
    
    // Check if changes were made
    if (!hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    // Validate that response from auditor is provided
    const responseFromAuditor = document.getElementById('reversalDelayReason')?.value?.trim() || '';
    if (!responseFromAuditor) {
        alert('Error: Response From Auditor is required. Please provide your response before approving.');
        const responseField = document.getElementById('reversalDelayReason');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    await processReversalDecision('approved');
}

// Reject reversal (for auditors/CQC)
async function rejectReversal() {
    // Check if auditor is waiting for team lead review
    if (currentAudit) {
        const workflowState = getReversalWorkflowState(currentAudit);
        const isAuditor = isCurrentUserAuditor();
        const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
        const isAdmin = isCurrentUserAdmin();
        const isTeamLead = isCurrentUserTeamLead();
        
        const isAuditorWaitingForTeamLead = (workflowState === 'team_lead_review' || workflowState === 'pending') && 
                                            (isAuditor || isOriginalAuditor) && 
                                            !isAdmin && 
                                            !isTeamLead;
        
        if (isAuditorWaitingForTeamLead) {
            alert('This reversal is currently under Team Lead review. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    }
    
    // Validate that response from auditor is provided
    const responseFromAuditor = document.getElementById('reversalDelayReason')?.value?.trim() || '';
    if (!responseFromAuditor) {
        alert('Error: Response From Auditor is required. Please provide your response before rejecting.');
        const responseField = document.getElementById('reversalDelayReason');
        if (responseField) {
            responseField.focus();
            responseField.style.borderColor = '#dc2626';
            setTimeout(() => {
                responseField.style.borderColor = '#d1d5db';
            }, 3000);
        }
        return;
    }
    
    await processReversalDecision('rejected');
}

// Process reversal decision
async function processReversalDecision(decision) {
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not available');
        return;
    }
    
    // Get current workflow state
    const workflowState = getReversalWorkflowState(currentAudit);
    const userInfo = getCurrentUserInfo();
    const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
    const currentUserEmailFromInfo = userInfo?.email || getCurrentUserEmail() || '';
    const isOriginalAuditor = isCurrentUserOriginalAuditor(currentAudit);
    const isAdmin = isCurrentUserAdmin();
    const isTeamLead = isCurrentUserTeamLead();
    
    // Check if user is team supervisor (async check)
    const isTeamSupervisor = await isCurrentUserTeamSupervisor();
    const canReviewAsTeamLead = (isTeamLead || isTeamSupervisor) && (workflowState === 'team_lead_review' || workflowState === 'pending');
    
    // Check permissions: Only original auditor, admins, or team leads (for team_lead_review stage) can process
    if (!isOriginalAuditor && !isAdmin && !canReviewAsTeamLead) {
        alert('Error: Only the original auditor of this audit, Admins, or Team Leads can process reversals.');
        return;
    }
    
    // Determine what action this is based on workflow state and user role
    let actionType = 'final'; // default: final decision by auditor/admin
    let nextWorkflowState = '';
    let adminBypass = false; // Track if admin bypassed team leader approval
    
    if (workflowState === 'team_lead_review' || workflowState === 'pending') {
        // Team lead review stage
        if (canReviewAsTeamLead) {
            // Normal team lead review
            actionType = 'team_lead_review';
            if (decision === 'approved') {
                nextWorkflowState = 'pending - qa_review'; // Goes to QA/Auditor for review
            } else {
                nextWorkflowState = 'pending - team_lead_rejected'; // Final rejection, stops here
            }
        } else if (isAdmin) {
            // Admin bypass: Admin can process even if team leader hasn't approved
            actionType = 'admin_bypass';
            adminBypass = true;
            if (decision === 'approved') {
                nextWorkflowState = 'pending - qa_review'; // Goes to QA/Auditor for review
            } else {
                nextWorkflowState = 'pending - team_lead_rejected'; // Final rejection, stops here
            }
        } else {
            // This should not happen if UI is properly disabled, but show a helpful message
            alert('This reversal is currently under Team Lead review. Only Team Leads, Team Supervisors, or Admins can review reversals at this stage. You will be able to review and process this reversal once the Team Lead has approved it.');
            return;
        }
    } else if (workflowState === 'qa_review' || workflowState === 'cqc_review') {
        // QA/Auditor review stage - only original auditor or admin can process
        if (isOriginalAuditor || isAdmin) {
            actionType = 'qa_review';
            // Can edit audit parameters and then approve/reject
            if (decision === 'approved') {
                nextWorkflowState = 'pending - reversal_approved'; // Agent needs to acknowledge
            } else {
                nextWorkflowState = 'pending - reversal_rejected'; // Agent needs to acknowledge
            }
        } else {
            alert('Error: Only the original auditor of this audit or Admins can review reversals at this stage.');
            return;
        }
    } else if (workflowState === 'cqc_sent_back' || workflowState === 'agent_re_review') {
        // Agent needs to resubmit - this should trigger a new reversal request
        alert('This reversal was sent back by CQC. Please review and resubmit if needed.');
        return;
    } else if (workflowState === 'approved' || workflowState === 'rejected') {
        // Already processed - this shouldn't happen, but handle gracefully
        alert('This reversal has already been processed.');
        return;
    } else {
        // Final decision by original auditor or admin
        actionType = 'final';
        if (decision === 'approved') {
            nextWorkflowState = 'pending - reversal_approved';
        } else {
            nextWorkflowState = 'pending - reversal_rejected';
        }
    }
    
    // For QA approval (by auditor), require changes to audit parameters
    if (actionType === 'qa_review' && decision === 'approved' && !hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    try {
        // FIRST: Retrieve the original state from activity log (when reversal was requested)
        // This ensures we have the true original state, not the current state
        let loggedOriginalState = null;
        try {
            const { data: reversalRequestLog, error: logFetchError } = await window.supabaseClient
                .from('audit_activity_log')
                .select('*')
                .eq('audit_id', currentAudit.id)
                .eq('activity_type', 'reversal_requested')
                .order('activity_timestamp', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!logFetchError && reversalRequestLog) {
                loggedOriginalState = {
                    parameters: reversalRequestLog.parameters_snapshot || {},
                    feedback: reversalRequestLog.feedback_snapshot || {},
                    score: reversalRequestLog.score_snapshot || 0,
                    passingStatus: reversalRequestLog.passing_status_snapshot || ''
                };
                console.log('Retrieved original state from activity log:', loggedOriginalState);
            } else if (logFetchError) {
                console.warn('Could not retrieve original state from activity log:', logFetchError);
            }
        } catch (logErr) {
            console.warn('Error retrieving original state from activity log:', logErr);
        }
        
        // Use logged original state if available, otherwise fall back to originalAuditState
        const trueOriginalState = loggedOriginalState || originalAuditState;
        
        // First, save all parameter changes
        const auditData = {};
        
        // Collect parameter values
        const errorInputs = document.querySelectorAll('input[type="number"][id]:not([id^="feedback_"]):not([id^="comment_"]), input[type="radio"]:checked');
        errorInputs.forEach(input => {
            if (input.type === 'radio') {
                auditData[input.name] = parseInt(input.value) || 0;
            } else {
                const fieldId = input.id;
                if (fieldId && !fieldId.startsWith('feedback_') && !fieldId.startsWith('comment_')) {
                    auditData[fieldId] = parseInt(input.value) || 0;
                }
            }
        });
        
        // Collect feedback values
        const feedbackTextareas = document.querySelectorAll('textarea[id^="feedback_"]');
        const feedbackByField = {};
        feedbackTextareas.forEach(textarea => {
            const fieldId = textarea.id.replace(/^feedback_/, '').replace(/_\d+$/, '');
            if (!feedbackByField[fieldId]) {
                feedbackByField[fieldId] = [];
            }
            if (textarea.value && textarea.value.trim()) {
                feedbackByField[fieldId].push(textarea.value.trim());
            }
        });
        
        Object.keys(feedbackByField).forEach(fieldId => {
            const feedbacks = feedbackByField[fieldId];
            auditData[`feedback_${fieldId}`] = feedbacks.length > 0 ? feedbacks : null;
        });
        
        // Note: Feedback should never be cleared, even if error count is 0
        // This ensures feedback/comments remain visible regardless of error count changes
        
        // Calculate new score
        const newScore = calculateNewScore();
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        // Get user info
        const userInfo = getCurrentUserInfo();
        const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
        const logUserEmail = userInfo?.email || '';
        
        // Get reversal decision details
        const approvedBy = document.getElementById('reversalApprovedBy')?.value || currentUserName;
        const delayReason = document.getElementById('reversalDelayReason')?.value || null;
        const withinAuditorScope = document.getElementById('withinAuditorScope')?.checked ? 'true' : 'false';
        
        // Calculate SLA
        const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
        const respondedAt = new Date();
        let slaHours = 0;
        if (reversalRequestedAt) {
            const requestedAt = new Date(reversalRequestedAt);
            slaHours = ((respondedAt - requestedAt) / (1000 * 60 * 60));
        }
        
        // Count changed parameters and feedback (without storing detailed change data)
        let parametersChangedCount = 0;
        let feedbackChangedCount = 0;
        
        if (trueOriginalState) {
            currentErrorFields.forEach(field => {
                const fieldKey = field.key;
                let currentValue = 0;
                
                if (field.field_type === 'radio') {
                    const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
                    if (radioInput) {
                        currentValue = parseInt(radioInput.value) || 0;
                    }
                } else {
                    const numberInput = document.getElementById(fieldKey);
                    if (numberInput) {
                        currentValue = parseInt(numberInput.value) || 0;
                    }
                }
                
                const originalValue = trueOriginalState.parameters[fieldKey] || 0;
                if (currentValue !== originalValue) {
                    parametersChangedCount++;
                }
                
                // Check feedback changes
                const feedbackKey = `feedback_${fieldKey}`;
                const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
                const currentFeedbacks = Array.from(feedbackTextareas)
                    .map(ta => ta.value.trim())
                    .filter(v => v);
                
                const originalFeedback = trueOriginalState.feedback[fieldKey];
                let originalFeedbacks = [];
                if (originalFeedback) {
                    if (Array.isArray(originalFeedback)) {
                        originalFeedbacks = originalFeedback.filter(f => f && f.trim());
                    } else if (typeof originalFeedback === 'string') {
                        try {
                            const parsed = JSON.parse(originalFeedback);
                            originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                        } catch {
                            originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                        }
                    }
                }
                
                if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
                    feedbackChangedCount++;
                }
            });
        }
        
        // Prepare audit update data
        const originalScore = trueOriginalState?.score || currentAudit.averageScore || currentAudit.average_score || 0;
        const originalPassingStatus = trueOriginalState?.passingStatus || currentAudit.passingStatus || currentAudit.passing_status || '';
        
        // Set acknowledgement status based on workflow state and action type
        const updateData = {
            ...auditData,
            acknowledgement_status: nextWorkflowState,
            acknowledgement_status_updated_at: respondedAt.toISOString()
        };
        
        // Handle different action types
        if (actionType === 'team_lead_review') {
            // Team Lead review - don't update score yet, just set workflow state
            updateData.team_lead_reviewed_at = respondedAt.toISOString();
            // Store user's name instead of email
            updateData.team_lead_reviewed_by = currentUserName || currentUserEmailFromInfo || currentUserEmail || '';
            updateData.team_lead_approved = decision === 'approved';
            
            // If team leader modified parameter comments, merge them and rebuild justification
            if (decision === 'approved' && window.teamLeadModifiedParameterComments) {
                const existingComments = updateData.parameter_comments || {};
                // Merge: keep existing structure, update only modified fields
                Object.keys(window.teamLeadModifiedParameterComments).forEach(key => {
                    existingComments[key] = window.teamLeadModifiedParameterComments[key];
                });
                updateData.parameter_comments = existingComments;
                
                // Rebuild justification from reversal reason + modified parameter comments
                const reversalJustification = currentAudit?.reversalJustificationFromAgent || currentAudit?.reversal_justification_from_agent || '';
                let reversalReason = '';
                if (reversalJustification && reversalJustification.includes(':')) {
                    const parts = reversalJustification.split(':');
                    if (parts.length >= 2) {
                        reversalReason = parts[0].trim();
                    }
                }
                
                // Build new justification from reason + modified comments
                const justificationParts = [];
                currentErrorFields.forEach(field => {
                    const modifiedComment = existingComments[field.key];
                    if (modifiedComment) {
                        const commentText = modifiedComment.comment || (Array.isArray(modifiedComment.comments) ? modifiedComment.comments.filter(c => c && c.trim()).join('\n') : '');
                        if (commentText && commentText.trim()) {
                            justificationParts.push(`${field.label}: ${commentText.trim()}`);
                        }
                    }
                });
                
                const newJustification = reversalReason 
                    ? `${reversalReason}: ${justificationParts.join('\n\n')}`
                    : justificationParts.join('\n\n');
                
                updateData.reversal_justification_from_agent = newJustification;
                delete window.teamLeadModifiedParameterComments;
            }
            
            // If rejected, include rejection reason (final rejection, stops here)
            if (decision === 'rejected') {
                const rejectionData = window.teamLeadRejectionData || {};
                const rejectionReason = rejectionData.reason || '';
                const comments = rejectionData.comments || '';
                
                // Combine reason and comments
                let fullRejectionReason = rejectionReason;
                if (comments && comments.trim()) {
                    fullRejectionReason = `${rejectionReason}\n\nAdditional Comments: ${comments}`;
                }
                
                updateData.team_lead_rejection_reason = fullRejectionReason;
                
                // Clear the stored rejection data
                delete window.teamLeadRejectionData;
            }
            
            // reversal_processed_by/email are now tracked in reversal_workflow_states.entered_by_name/email
            // Don't write to audit table anymore - will be stored in workflow states
            
            // Don't set reversal_approved yet - that's for QA's final decision
        } else if (actionType === 'admin_bypass') {
            // Admin bypass - Admin processed without team leader approval
            updateData.team_lead_reviewed_at = respondedAt.toISOString();
            updateData.team_lead_reviewed_by = currentUserName || currentUserEmailFromInfo || currentUserEmail || '';
            updateData.team_lead_approved = decision === 'approved';
            // admin_bypass is now stored in reversal_requests table, not audit table
            // reversal_processed_by/email are now tracked in reversal_workflow_states.entered_by_name/email
            
            // Optional: Store bypass reason if provided (could add UI for this later)
            // updateData.admin_bypass_reason = bypassReason || '';
        } else if (actionType === 'qa_review') {
            // QA/Auditor review - can edit audit parameters and make final decision
            updateData.reversal_approved = decision === 'approved';
            updateData.reversal_responded_at = respondedAt.toISOString();
            updateData.reversal_approved_by = currentUserName;
            // reversal_resolved_by is deprecated - now stored in reversal_requests.final_decision_by_name
            // Keep for backward compatibility but don't write to it anymore
            // Set within_auditor_scope based on auditor's selection
            updateData.within_auditor_scope = withinAuditorScope;
            
            // reversal_processed_by/email are now tracked in reversal_workflow_states.entered_by_name/email
            // admin_bypass is now stored in reversal_requests table
            
            // Get response from auditor if provided
            const delayReason = document.getElementById('reversalDelayReason')?.value || '';
            if (delayReason) {
                updateData.response_from_auditor = delayReason;
            }
            updateData.sla_in_hours = parseFloat(slaHours.toFixed(2));
            
            // If approved, update score and passing status
            if (decision === 'approved') {
                updateData.average_score = newScore;
                updateData.passing_status = isPassing ? 'Passing' : 'Not Passing';
                updateData.score_after_appeal = newScore;
                updateData.did_result_in_pass = isPassing;
            }
        } else {
            // Legacy/old flow: Final decision by auditor (for backward compatibility)
            updateData.reversal_approved = decision === 'approved';
            updateData.reversal_responded_at = respondedAt.toISOString();
            updateData.reversal_approved_by = approvedBy;
            // reversal_resolved_by is deprecated - now stored in reversal_requests.final_decision_by_name
            // Keep for backward compatibility but don't write to it anymore
            if (delayReason) {
                updateData.response_from_auditor = delayReason;
            }
            updateData.sla_in_hours = parseFloat(slaHours.toFixed(2));
        
        // If approved, update score and passing status
        if (decision === 'approved') {
            updateData.average_score = newScore;
            updateData.passing_status = isPassing ? 'Passing' : 'Not Passing';
            updateData.score_after_appeal = newScore;
            // Note: passed_after_appeal column doesn't exist in schema, using did_result_in_pass instead
            updateData.did_result_in_pass = isPassing;
            }
        }
        
        // Update audit in database
        const { data: updatedAudit, error: updateError } = await window.supabaseClient
            .from(currentTableName)
            .update(updateData)
            .eq('id', currentAudit.id)
            .select();
        
        if (updateError) throw updateError;
        
        // Update reversal_requests and reversal_workflow_states (if reversal exists)
        try {
            // Find the reversal_request for this audit
            const { data: reversalRequest, error: rrFetchError } = await window.supabaseClient
                .from('reversal_requests')
                .select('id, current_state_id')
                .eq('audit_id', currentAudit.id)
                .eq('scorecard_table_name', currentTableName)
                .order('requested_at', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!rrFetchError && reversalRequest) {
                // Prepare reversal_requests update data
                const reversalUpdateData = {
                    updated_at: new Date().toISOString()
                };
                
                // Add admin_bypass if this is an admin bypass action
                if (actionType === 'admin_bypass') {
                    reversalUpdateData.admin_bypass = true;
                } else if (actionType === 'qa_review' && isAdmin) {
                    // Admin processed at QA stage (not a bypass, but admin processed)
                    reversalUpdateData.admin_bypass = false;
                }
                
                // Add final decision info if this is QA review or final decision
                if (actionType === 'qa_review' || actionType === 'final') {
                    reversalUpdateData.final_decision = decision;
                    reversalUpdateData.final_decision_at = respondedAt.toISOString();
                    reversalUpdateData.final_decision_by_name = currentUserName;
                    reversalUpdateData.final_decision_by_email = logUserEmail;
                    reversalUpdateData.new_score = decision === 'approved' ? newScore : null;
                    reversalUpdateData.new_passing_status = decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : null;
                    reversalUpdateData.sla_hours = parseFloat(slaHours.toFixed(2));
                    reversalUpdateData.within_auditor_scope = withinAuditorScope;
                }
                
                // Update reversal_requests
                const { error: rrUpdateError } = await window.supabaseClient
                    .from('reversal_requests')
                    .update(reversalUpdateData)
                    .eq('id', reversalRequest.id);
                
                if (rrUpdateError) {
                    console.warn('Error updating reversal_requests table:', rrUpdateError);
                    // Don't throw - audit update succeeded, this is secondary
                }
                
                // Create/update workflow state for this action
                // First, mark previous state as not current
                if (reversalRequest.current_state_id) {
                    await window.supabaseClient
                        .from('reversal_workflow_states')
                        .update({ is_current: false })
                        .eq('id', reversalRequest.current_state_id);
                }
                
                // Determine new workflow state based on action type
                let newWorkflowState = '';
                if (actionType === 'team_lead_review') {
                    newWorkflowState = decision === 'approved' ? 'team_lead_approved' : 'team_lead_rejected';
                } else if (actionType === 'admin_bypass') {
                    newWorkflowState = decision === 'approved' ? 'team_lead_approved' : 'team_lead_rejected';
                } else if (actionType === 'qa_review') {
                    newWorkflowState = decision === 'approved' ? 'approved' : 'rejected';
                } else {
                    newWorkflowState = decision === 'approved' ? 'approved' : 'rejected';
                }
                
                // Create new workflow state
                const { data: newWorkflowStateData, error: wsError } = await window.supabaseClient
                    .from('reversal_workflow_states')
                    .insert({
                        reversal_request_id: reversalRequest.id,
                        state: newWorkflowState,
                        entered_at: respondedAt.toISOString(),
                        entered_by_email: logUserEmail,
                        entered_by_name: currentUserName,
                        previous_state_id: reversalRequest.current_state_id || null,
                        is_current: true,
                        notes: actionType === 'admin_bypass' 
                            ? `Admin bypassed team lead approval - ${decision === 'approved' ? 'approved' : 'rejected'}`
                            : actionType === 'team_lead_review'
                            ? `Team Lead ${decision === 'approved' ? 'approved' : 'rejected'} reversal`
                            : `QA review - ${decision === 'approved' ? 'approved' : 'rejected'} reversal`
                    })
                    .select()
                    .single();
                
                if (!wsError && newWorkflowStateData) {
                    // Update reversal_requests with new current_state_id
                    await window.supabaseClient
                        .from('reversal_requests')
                        .update({ current_state_id: newWorkflowStateData.id })
                        .eq('id', reversalRequest.id);
                } else if (wsError) {
                    console.warn('Error creating workflow state:', wsError);
                    // Don't throw - audit update succeeded
                }
            }
        } catch (rrErr) {
            console.warn('Error updating reversal_requests/workflow_states:', rrErr);
            // Don't throw - audit update succeeded
        }
        
        // Log approval/rejection to activity log
        try {
            // Capture new state after update
            const newAuditState = {
                parameters: auditData,
                feedback: feedbackByField,
                score: decision === 'approved' ? newScore : originalScore,
                passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                acknowledgement_status: newAcknowledgementStatus
            };
            
            // Determine activity type based on action type
            let activityType = 'reversal_processed';
            if (actionType === 'team_lead_review') {
                activityType = decision === 'approved' ? 'reversal_team_lead_approved' : 'reversal_team_lead_rejected';
            } else if (actionType === 'qa_review') {
                activityType = decision === 'approved' ? 'reversal_approved' : 'reversal_rejected';
            } else {
                activityType = decision === 'approved' ? 'reversal_approved' : 'reversal_rejected';
            }
            
            const activityLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                activity_type: activityType,
                activity_timestamp: respondedAt.toISOString(),
                performed_by_email: logUserEmail,
                performed_by_name: currentUserName,
                audit_state_snapshot: newAuditState,
                parameters_snapshot: auditData,
                feedback_snapshot: feedbackByField,
                score_snapshot: newAuditState.score,
                passing_status_snapshot: newAuditState.passing_status,
                changes_made: {
                    score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                    passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed'))
                },
                change_reason: decision === 'approved' ? 'Reversal approved by quality analyst' : 'Reversal rejected by quality analyst',
                metadata: {
                    approved_by: approvedBy,
                    delay_reason: delayReason,
                    sla_hours: parseFloat(slaHours.toFixed(2)),
                    parameters_changed_count: parametersChangedCount,
                    feedback_changed_count: feedbackChangedCount
                }
            };
            
            const { error: activityLogError } = await window.supabaseClient
                .from('audit_activity_log')
                .insert(activityLogData);
            
            if (activityLogError) {
                console.error('Error logging reversal decision to activity log:', activityLogError);
                // Don't throw - audit update succeeded, logging is secondary
            } else {
                console.log('Successfully logged reversal decision to activity log');
            }
        } catch (activityLogErr) {
            console.error('Error creating activity log entry for reversal decision:', activityLogErr);
            // Don't throw - audit update succeeded
        }
        
        // Save to reversal_change_log table
        try {
            const changeLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                reversal_requested_at: reversalRequestedAt,
                original_score: originalScore,
                original_passing_status: originalPassingStatus,
                original_parameters: trueOriginalState?.parameters || {},
                original_feedback: trueOriginalState?.feedback || {},
                new_score: decision === 'approved' ? newScore : originalScore,
                new_passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                parameters_changed_count: parametersChangedCount,
                feedback_changed_count: feedbackChangedCount,
                score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed')),
                reversal_decision: decision,
                reversal_approved: decision === 'approved',
                reversal_responded_at: respondedAt.toISOString(),
                processed_by_email: logUserEmail,
                processed_by_name: currentUserName,
                approved_by_email: logUserEmail,
                approved_by_name: approvedBy,
                sla_hours: parseFloat(slaHours.toFixed(2)),
                delay_reason: delayReason
            };
            
            const { error: logError } = await window.supabaseClient
                .from('reversal_change_log')
                .insert(changeLogData);
            
            if (logError) {
                console.error('Error saving to reversal_change_log:', logError);
                // Don't throw - audit update succeeded, logging is secondary
            }
        } catch (logErr) {
            console.error('Error creating change log:', logErr);
            // Don't throw - audit update succeeded
        }
        
        // Show success message
        let successMessage = '';
        if (actionType === 'team_lead_review') {
            if (decision === 'approved') {
                successMessage = '✓ Reversal request has been sent to QC. The request is now under QC review.';
            } else {
                successMessage = '✓ Reversal request has been rejected. The agent will be notified.';
            }
        } else if (actionType === 'admin_bypass') {
            if (decision === 'approved') {
                successMessage = '✓ Reversal request has been processed by Admin (Team Leader approval bypassed). The request is now under QC review.';
            } else {
                successMessage = '✓ Reversal request has been rejected by Admin (Team Leader approval bypassed). The agent will be notified.';
            }
        } else if (actionType === 'qa_review') {
            successMessage = `✓ Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`;
        } else {
            // Legacy flow
            successMessage = `✓ Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`;
        }
        
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: successMessage,
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert(successMessage);
        }
        
        // Reload page to show updated state
        location.reload();
        
    } catch (error) {
        console.error('Error processing reversal:', error);
        alert('Failed to process reversal: ' + (error.message || 'Unknown error'));
    }
}

// Make functions globally accessible
window.approveReversal = approveReversal;
window.rejectReversal = rejectReversal;
window.deleteCurrentAudit = deleteCurrentAudit;

// Save Audit Changes Function
async function saveAuditChanges() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const tableName = urlParams.get('table');
    
    if (!auditId || !tableName) {
        alert('Error: Missing audit ID or table name');
        return;
    }
    
    // Check if audit is acknowledged - lock everything (no edits allowed)
    if (currentAudit) {
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('This audit has been acknowledged and cannot be edited.');
            return;
        }
    }
    
    try {
        // Collect all form data
        const auditData = {};
        
        // Collect error parameter values - inputs use field.key as ID/name directly
        const errorInputs = document.querySelectorAll('input[type="number"][id]:not([id^="feedback_"]):not([id^="comment_"]), input[type="radio"]:checked');
        errorInputs.forEach(input => {
            if (input.type === 'radio') {
                auditData[input.name] = parseInt(input.value) || 0;
            } else {
                // Only collect if it's a parameter field (not feedback or comment fields)
                const fieldId = input.id;
                if (fieldId && !fieldId.startsWith('feedback_') && !fieldId.startsWith('comment_')) {
                    auditData[fieldId] = parseInt(input.value) || 0;
                }
            }
        });
        
        // Collect feedback values from Quill editors - only include non-empty feedbacks
        const feedbackByField = {};
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const feedbackContainer = document.getElementById(`feedback_container_${field.key}`);
                if (feedbackContainer) {
                    const feedbacks = [];
                    
                    // Get feedback from Quill editors
                    const quillContainers = feedbackContainer.querySelectorAll('.quill-editor-container');
                    quillContainers.forEach((container, index) => {
                        const feedbackId = `feedback_${field.key}_${index}`;
                        if (quillInstances.has(feedbackId)) {
                            const quill = quillInstances.get(feedbackId);
                            const htmlContent = quill.root.innerHTML;
                            // Check if content is not empty (Quill returns '<p><br></p>' for empty)
                            if (htmlContent && htmlContent.trim() && htmlContent !== '<p><br></p>') {
                                // Sanitize HTML before storing
                                const sanitized = DOMPurify.sanitize(htmlContent, {
                                    ALLOWED_TAGS: ['p', 'br', 'strong', 'b', 'em', 'i', 'u', 'ul', 'ol', 'li', 'a', 'span'],
                                    ALLOWED_ATTR: ['href', 'target', 'rel', 'style'],
                                    ALLOW_DATA_ATTR: false
                                });
                                if (sanitized && sanitized.trim() && sanitized !== '<p><br></p>') {
                                    feedbacks.push(sanitized.trim());
                                }
                            }
                        }
                    });
                    
                    // Fallback to textareas for backward compatibility
                    if (feedbacks.length === 0) {
                        const feedbackTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${field.key}_"]`);
                        feedbackTextareas.forEach(textarea => {
                            if (textarea.value && textarea.value.trim()) {
                                feedbacks.push(textarea.value.trim());
                            }
                        });
                    }
                    
                    // Add feedback to auditData, and set to null if empty
                    auditData[`feedback_${field.key}`] = feedbacks.length > 0 ? feedbacks : null;
                }
            });
        }
        
        // Collect recommendations from Quill editor
        if (quillInstances.has('recommendations')) {
            const quill = quillInstances.get('recommendations');
            const htmlContent = quill.root.innerHTML;
            // Check if content is not empty (Quill returns '<p><br></p>' for empty)
            if (htmlContent && htmlContent.trim() && htmlContent !== '<p><br></p>') {
                // Sanitize HTML before storing
                const sanitized = DOMPurify.sanitize(htmlContent, {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'b', 'em', 'i', 'u', 'ul', 'ol', 'li', 'a'],
                    ALLOWED_ATTR: ['href', 'target', 'rel'],
                    ALLOW_DATA_ATTR: false
                });
                if (sanitized && sanitized.trim() && sanitized !== '<p><br></p>') {
                    auditData.recommendations = sanitized.trim();
                } else {
                    auditData.recommendations = null;
                }
            } else {
                auditData.recommendations = null;
            }
        } else {
            // Fallback to textarea for backward compatibility
            const recommendationsTextarea = document.getElementById('recommendations');
            if (recommendationsTextarea) {
                const value = recommendationsTextarea.value.trim();
                if (value) {
                    // Convert plain text to HTML
                    const htmlText = value.split('\n').map(line => `<p>${escapeHtml(line)}</p>`).join('');
                    auditData.recommendations = htmlText;
                } else {
                    auditData.recommendations = null;
                }
            } else {
                auditData.recommendations = null;
            }
        }
        
        // Collect parameter comments from all comment input fields
        // Comments should be saved even if error count is 0
        const parameterComments = {};
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    // Include all comments, even empty ones (to handle deletion)
                    const commentValue = input.value ? input.value.trim() : '';
                    comments.push(commentValue);
                });
                
                // Filter out empty comments at the end
                const nonEmptyComments = comments.filter(c => c.length > 0);
                
                // Always update the parameter comment entry if there are comment inputs OR if there are existing comments
                // This allows us to save comments even if error count is 0, and also delete comments if cleared
                // Check if there are existing comments for this parameter
                const existingParamComments = (currentAudit?.parameterComments || currentAudit?.parameter_comments || {})[field.key];
                const hasExistingComments = existingParamComments && existingParamComments.comments && existingParamComments.comments.length > 0;
                
                if (commentInputs.length > 0 || hasExistingComments) {
                    // Get current user email for commented_by
                    const userEmail = getCurrentUserEmail() || '';
                    if (nonEmptyComments.length > 0) {
                        // Save comments if there are any
                        parameterComments[field.key] = {
                            comments: nonEmptyComments,
                            commented_at: new Date().toISOString(),
                            commented_by: userEmail
                        };
                    } else if (commentInputs.length > 0) {
                        // If comment inputs exist but are all empty, remove the parameter comment entry
                        // Set to null to explicitly remove it
                        parameterComments[field.key] = null;
                    }
                    // If no comment inputs but existing comments, preserve existing comments
                    // (don't add to parameterComments, they'll be preserved in mergedComments)
                }
            });
        }
        
        // Merge with existing parameter comments
        // Start with existing comments, then update with new/cleared comments
        const existingComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const mergedComments = { ...existingComments };
        
        // Update merged comments with new values (including nulls for deletions)
        Object.keys(parameterComments).forEach(key => {
            if (parameterComments[key] === null) {
                // Remove the comment entry if it was cleared
                delete mergedComments[key];
            } else {
                // Update with new comments
                mergedComments[key] = parameterComments[key];
            }
        });
        
        // Note: Feedback should never be cleared, even if error count is 0
        // This ensures feedback/comments remain visible regardless of error count changes
        errorInputs.forEach(input => {
            // For radio buttons, use name; for number inputs, use id
            const fieldId = input.type === 'radio' ? input.name : (input.id || input.name);
            const errorValue = input.type === 'radio' ? (parseInt(input.value) || 0) : (parseInt(input.value) || 0);
            
            // Skip if this is not a parameter field (e.g., feedback or comment inputs)
            if (fieldId && (fieldId.startsWith('feedback_') || fieldId.startsWith('comment_'))) {
                return;
            }
            
            // Note: Feedback should never be cleared, even if error count is 0
            // This ensures feedback/comments remain visible regardless of error count changes
            // Ensure the error count field is set to the current value
            auditData[fieldId] = errorValue;
        });
        
        // Calculate total errors count and error category counts from current form values
        let totalErrorsCount = 0;
        let criticalFailTotal = 0;
        let criticalTotal = 0;
        let significantTotal = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                // Only count error parameters (not achievements/bonuses)
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    let errorCount = 0;
                    
                    if (field.field_type === 'radio') {
                        const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                        if (selectedRadio) {
                            const value = parseInt(selectedRadio.value) || 0;
                            errorCount = value;
                        }
                    } else {
                        const fieldInput = document.getElementById(field.key);
                        if (fieldInput) {
                            errorCount = parseInt(fieldInput.value) || 0;
                        }
                    }
                    
                    totalErrorsCount += errorCount;
                    
                    // Count by severity/error_category
                    if (errorCount > 0) {
                        // Use severity if available, otherwise map from error_category
                        let severity = field.severity;
                        if (!severity && field.error_category) {
                            const category = field.error_category || '';
                            if (category.includes('Fail')) {
                                severity = 'Critical Fail';
                            } else if (category.includes('Critical')) {
                                severity = 'Critical';
                            } else if (category.includes('Significant') || category.includes('Major') || category.includes('Minor')) {
                                severity = 'Significant';
                            } else {
                                severity = 'Significant'; // default
                            }
                        }
                        
                        if (severity === 'Critical Fail') {
                            criticalFailTotal += errorCount;
                        } else if (severity === 'Critical') {
                            criticalTotal += errorCount;
                        } else if (severity === 'Significant' || severity === 'Major' || severity === 'Minor') {
                            significantTotal += errorCount;
                        }
                    }
                }
            });
        }
        
        // Calculate average score
        const calculatedAverageScore = calculateNewScore();
        
        // Calculate passing status
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = parseFloat(scorecard.passing_threshold) || 85;
        
        // Check if any "fail all" parameters have errors
        let hasFailAllError = false;
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                if (field.is_fail_all) {
                    let errorCount = 0;
                    
                    if (field.field_type === 'radio') {
                        const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                        if (selectedRadio) {
                            const value = parseInt(selectedRadio.value) || 0;
                            if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                                errorCount = value === 0 ? 1 : 0;
                            } else {
                                errorCount = value;
                            }
                        }
                    } else {
                        const fieldInput = document.getElementById(field.key);
                        if (fieldInput) {
                            errorCount = parseInt(fieldInput.value) || 0;
                        }
                    }
                    
                    if (errorCount > 0) {
                        hasFailAllError = true;
                    }
                }
            });
        }
        
        // Determine passing status
        let passingStatus = 'Not Passing';
        if (hasFailAllError) {
            passingStatus = 'Not Passing';
        } else if (calculatedAverageScore >= passingThreshold) {
            passingStatus = 'Passing';
        } else {
            passingStatus = 'Not Passing';
        }
        
        // Build update payload
        const updatePayload = {};
        
        // Add error parameter values
        Object.keys(auditData).forEach(key => {
            if (key.startsWith('feedback_')) {
                updatePayload[key] = auditData[key];
            } else {
                updatePayload[key] = auditData[key];
            }
        });
        
        // Add calculated fields
        updatePayload.total_errors_count = totalErrorsCount;
        updatePayload.critical_errors = criticalTotal;
        updatePayload.critical_fail_error = criticalFailTotal;
        updatePayload.significant_error = significantTotal;
        updatePayload.average_score = parseFloat(calculatedAverageScore.toFixed(2));
        updatePayload.passing_status = passingStatus;
        
        console.log('Calculated average score:', calculatedAverageScore, 'Will save as:', updatePayload.average_score);
        console.log('Calculated passing status:', passingStatus);
        console.log('Calculated error counts - Critical:', criticalTotal, 'Critical Fail:', criticalFailTotal, 'Significant:', significantTotal);
        
        // Add parameter comments (always include, even if empty, to ensure comments are saved)
        // Comments should be saved even if error count is 0
        updatePayload.parameter_comments = mergedComments;
        
        // Helper function to retry database operations on schema cache errors
        async function retryOnSchemaCacheError(operation, maxRetries = 3) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                if (attempt > 0) {
                    // Wait longer on each retry (exponential backoff)
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
                
                const result = await operation();
                
                // If no error, return success
                if (!result.error) {
                    return result;
                }
                
                // If it's a schema cache error, retry
                if (result.error.message && result.error.message.includes('schema cache')) {
                    continue;
                }
                
                // If it's not a schema cache error, return immediately
                return result;
            }
            
            // Return last result after all retries exhausted
            return await operation();
        }
        
        // Update in Supabase with retry logic for schema cache errors
        const { data, error } = await retryOnSchemaCacheError(async () => {
            return await window.supabaseClient
                .from(tableName)
                .update(updatePayload)
                .eq('id', auditId)
                .select();
        });
        
        if (error) {
            console.error('Error saving audit:', error);
            throw error;
        }
        
        // Show success message
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: '✓ Audit changes saved successfully!',
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert('✓ Audit changes saved successfully!');
        }
        
        // Redirect to audit-view.html to see the changes
        // Use the already-declared variables from the beginning of the function
        const scorecardId = urlParams.get('scorecard');
        
        if (auditId && scorecardId && tableName) {
            window.location.href = `audit-view.html?id=${auditId}&scorecard=${scorecardId}&table=${tableName}`;
        } else {
            // Fallback to reload if parameters are missing
            location.reload();
        }
        
    } catch (error) {
        console.error('Error saving audit changes:', error);
        alert('Error saving audit changes: ' + error.message);
    }
}

// Delete Audit Function
async function deleteCurrentAudit() {
    // Verify that current user is the auditor
    if (!isCurrentUserAuditor()) {
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Access Denied',
                message: 'Only the auditor who created this audit can delete it.',
                confirmText: 'OK',
                type: 'error'
            });
        } else {
            alert('Only the auditor who created this audit can delete it.');
        }
        return;
    }
    
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not loaded');
        return;
    }
    
    // Show confirmation dialog
    const confirmed = await window.confirmationDialog.show({
        title: 'Delete Audit?',
        message: `Are you sure you want to delete this audit?\n\nEmployee: ${currentAudit.employeeName || currentAudit.employee_name || 'Unknown'}\nInteraction ID: ${currentAudit.interactionId || currentAudit.interaction_id || 'N/A'}\n\nThis action cannot be undone. The audit will be permanently deleted and any related assignments will be reset to pending.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        type: 'warning'
    });
    
    if (!confirmed) return;
    
    try {
        const auditId = currentAudit.id;
        
        // First, find and update audit_assignments that reference this audit
        const { data: assignments, error: assignmentsError } = await window.supabaseClient
            .from('audit_assignments')
            .select('id')
            .eq('audit_id', auditId);
        
        if (assignmentsError) {
            console.error('Error finding audit assignments:', assignmentsError);
            // Continue with deletion even if we can't find assignments
        } else if (assignments && assignments.length > 0) {
            // Update all assignments to pending status
            const assignmentIds = assignments.map(a => a.id);
            const { error: updateError } = await window.supabaseClient
                .from('audit_assignments')
                .update({
                    status: 'pending',
                    completed_at: null,
                    audit_id: null
                })
                .in('id', assignmentIds);
            
            if (updateError) {
                console.error('Error updating audit assignments:', updateError);
                // Continue with deletion even if update fails
            } else {
                console.log(`Updated ${assignmentIds.length} assignment(s) to pending status`);
            }
        }
        
        // Delete the audit from the table
        const { error: deleteError } = await window.supabaseClient
            .from(currentTableName)
            .delete()
            .eq('id', auditId);
        
        if (deleteError) {
            throw deleteError;
        }
        
        // Show success message
        await window.confirmationDialog.show({
            title: 'Success!',
            message: 'Audit deleted successfully. Any related assignments have been reset to pending status.',
            confirmText: 'OK',
            type: 'success'
        });
        
        // Redirect to expert-audits page or go back
        window.location.href = 'audit-reports.html';
        
    } catch (error) {
        console.error('Error deleting audit:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to delete audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

</script>

    <!-- Image Viewer Modal -->
    <div id="imageViewerModal" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; cursor: pointer;" onclick="if(event.target.id === 'imageViewerModal') closeImageViewer();" onkeydown="if(event.key === 'Escape') closeImageViewer(); if(event.key === 'ArrowLeft') navigateImage('prev'); if(event.key === 'ArrowRight') navigateImage('next');">
        <!-- Close Button -->
        <button id="imageViewerClose" onclick="closeImageViewer(); event.stopPropagation();" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 2.5rem; height: 2.5rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">
            ×
        </button>
        
        <!-- Previous Button -->
        <button id="imageViewerPrev" onclick="navigateImage('prev'); event.stopPropagation();" style="position: absolute; left: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Previous (←)">
            ‹
        </button>
        
        <!-- Next Button -->
        <button id="imageViewerNext" onclick="navigateImage('next'); event.stopPropagation();" style="position: absolute; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Next (→)">
            ›
        </button>
        
        <!-- Image Counter -->
        <div id="imageViewerCounter" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 0.5rem 1rem; border-radius: 1.5rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; z-index: 10001;">
            1 / 1
        </div>
        
        <!-- Image Container -->
        <div style="max-width: 95%; max-height: 95%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation();">
            <img id="imageViewerImg" src="" alt="Conversation image" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 0.5rem 2rem rgba(0,0,0,0.5);">
        </div>
    </div>

</body>
</html>